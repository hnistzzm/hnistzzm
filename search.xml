<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>javaScript面试手写知识点整理</title>
      <link href="/2022/03/22/javaScript%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
      <url>/2022/03/22/javaScript%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="1-JavaScript有哪些数据类型，它们的区别？"><a href="#1-JavaScript有哪些数据类型，它们的区别？" class="headerlink" title="1. JavaScript有哪些数据类型，它们的区别？"></a>1. JavaScript有哪些数据类型，它们的区别？</h3><p>JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。</p><p>其中 Symbol 和 BigInt 是ES6 中新增的数据类型：</p><ul><li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li><li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li></ul><p>这些数据可以分为原始数据类型和引用数据类型：</p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><p>两种类型的区别在于<strong>存储位置的不同：</strong></p><ul><li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li><li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p><ul><li>在数据结构中，栈中数据的存取方式为先进后出。</li><li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li></ul><p>在操作系统中，内存被分为栈区和堆区：</p><ul><li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li><li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li></ul><h3 id="2-数据类型检测的方式有哪些"><a href="#2-数据类型检测的方式有哪些" class="headerlink" title="2. 数据类型检测的方式有哪些"></a>2. 数据类型检测的方式有哪些</h3><p><strong>（1）typeof</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object    </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其中数组、对象、null都会被判断为object，其他判断都正确。</p><p><strong>（2）instanceof</strong></p><p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false </span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p><p><strong>（3） constructor</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span>).constructor === <span class="built_in">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).constructor === <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="string">&#x27;str&#x27;</span>).constructor === <span class="built_in">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(([]).constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">Fn.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fn();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===Fn);    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===<span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>（4）Object.prototype.toString.call()</strong></p><p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">true</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="string">&#x27;str&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call([]));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(&#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">undefined</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">null</span>));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p><p>这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p><h3 id="3-判断数组的方式有哪些"><a href="#3-判断数组的方式有哪些" class="headerlink" title="3. 判断数组的方式有哪些"></a>3. 判断数组的方式有哪些</h3><ul><li>通过Object.prototype.toString.call()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>,-<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>通过原型链做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.__proto__ === <span class="built_in">Array</span>.prototype;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>通过ES6的Array.isArray()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArrray(obj);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>通过instanceof做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Array</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>通过Array.prototype.isPrototypeOf</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf(obj)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="4-null和undefined区别"><a href="#4-null和undefined区别" class="headerlink" title="4. null和undefined区别"></a>4. null和undefined区别</h3><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p><p>undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p><p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p><p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p><h3 id="5-typeof-null-的结果是什么，为什么？"><a href="#5-typeof-null-的结果是什么，为什么？" class="headerlink" title="5. typeof null 的结果是什么，为什么？"></a>5. typeof null 的结果是什么，为什么？</h3><p>typeof null 的结果是Object。</p><p>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000</span>: object   - 当前存储的数据指向一个对象。</span><br><span class="line">  <span class="number">1</span>: int      - 当前存储的数据是一个 <span class="number">31</span> 位的有符号整数。</span><br><span class="line"><span class="number">010</span>: double   - 当前存储的数据指向一个双精度的浮点数。</span><br><span class="line"><span class="number">100</span>: string   - 当前存储的数据指向一个字符串。</span><br><span class="line"><span class="number">110</span>: boolean  - 当前存储的数据是布尔值。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。</p><p>有两种特殊数据类型：</p><ul><li>undefined的值是 (-2)30(一个超出整数范围的数字)；</li><li>null 的值是机器码 NULL 指针(null 指针的值全是 0)</li></ul><p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p><h3 id="6-intanceof-操作符的实现原理及实现"><a href="#6-intanceof-操作符的实现原理及实现" class="headerlink" title="6. intanceof 操作符的实现原理及实现"></a>6. intanceof 操作符的实现原理及实现</h3><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取对象的原型</span></span><br><span class="line">  <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(left)</span><br><span class="line">  <span class="comment">// 获取构造函数的 prototype 对象</span></span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span></span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeOf(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="7-为什么0-1-0-2-0-3，如何让其相等"><a href="#7-为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="7. 为什么0.1+0.2 ! == 0.3，如何让其相等"></a>7. 为什么0.1+0.2 ! == 0.3，如何让其相等</h3><p>在开发过程中遇到类似这样的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n1 = <span class="number">0.1</span>, n2 = <span class="number">0.2</span></span><br><span class="line"><span class="built_in">console</span>.log(n1 + n2)  <span class="comment">// 0.30000000000000004</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(n1 + n2).toFixed(<span class="number">2</span>) <span class="comment">// 注意，toFixed为四舍五入</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？</p><p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p><p>一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p><p>根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。</p><p>下面看一下<strong>双精度数是如何保存</strong>的： <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221928223.webp" alt="img"></p><ul><li>第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位</li><li>第二部分（绿色）：用来存储指数（exponent），占用11位</li><li>第三部分（红色）：用来存储小数（fraction），占用52位</li></ul><p>对于0.1，它的二进制为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011001</span> <span class="number">10011.</span>..</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>转为科学计数法（科学计数法的结果就是浮点数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1001100110011001100110011001100110011001100110011001</span>*<span class="number">2</span>^-<span class="number">4</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看出0.1的符号位为0，指数位为-4，小数位为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1001100110011001100110011001100110011001100110011001</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？</p><p>IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。</p><ul><li>当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023= -1022，e最大值是2046，则2046-1023=1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。</li><li>当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023= -1022。</li><li>当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s=0时表示正无穷，s=1时候表示负无穷。</li></ul><p>对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：<code>1111111011</code>.</p><p>所以，0.1表示为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1111111011</span> <span class="number">1001100110011001100110011001100110011001100110011001</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>说了这么多，是时候该最开始的问题了，如何实现0.1+0.2=0.3呢？</p><p>对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 ===0.3</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numberepsilon</span>(<span class="params">arg1,arg2</span>)</span>&#123;                   </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(arg1 - arg2) &lt; <span class="built_in">Number</span>.EPSILON;        </span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numberepsilon(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)); <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="8-如何获取安全的-undefined-值？"><a href="#8-如何获取安全的-undefined-值？" class="headerlink" title="8. 如何获取安全的 undefined 值？"></a>8. 如何获取安全的 undefined 值？</h3><p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。</p><h3 id="9-typeof-NaN-的结果是什么？"><a href="#9-typeof-NaN-的结果是什么？" class="headerlink" title="9. typeof NaN 的结果是什么？"></a>9. typeof NaN 的结果是什么？</h3><p>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// &quot;number&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。</p><h3 id="10-isNaN-和-Number-isNaN-函数的区别？"><a href="#10-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="10. isNaN 和 Number.isNaN 函数的区别？"></a>10. isNaN 和 Number.isNaN 函数的区别？</h3><ul><li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li><li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</li></ul><h3 id="11-操作符的强制类型转换规则？"><a href="#11-操作符的强制类型转换规则？" class="headerlink" title="11. == 操作符的强制类型转换规则？"></a>11. == 操作符的强制类型转换规则？</h3><p>对于 <code>==</code> 来说，如果对比双方的类型<strong>不一样</strong>，就会进行<strong>类型转换</strong>。假如对比 <code>x</code> 和 <code>y</code> 是否相同，就会进行如下判断流程：</p><ol><li>首先会判断两者类型是否<strong>相同，</strong>相同的话就比较两者的大小；</li><li>类型不相同的话，就会进行类型转换；</li><li>会先判断是否在对比 <code>null</code> 和 <code>undefined</code>，是的话就会返回 <code>true</code></li><li>判断两者类型是否为 <code>string</code> 和 <code>number</code>，是的话就会将字符串转换为 <code>number</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">&#x27;1&#x27;</span></span><br><span class="line">      ↓</span><br><span class="line"><span class="number">1</span> ==  <span class="number">1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li>判断其中一方是否为 <code>boolean</code>，是的话就会把 <code>boolean</code> 转为 <code>number</code> 再进行判断</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span> == <span class="literal">true</span></span><br><span class="line">        ↓</span><br><span class="line"><span class="string">&#x27;1&#x27;</span> ==  <span class="number">1</span></span><br><span class="line">        ↓</span><br><span class="line"> <span class="number">1</span>  ==  <span class="number">1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li>判断其中一方是否为 <code>object</code> 且另一方为 <code>string</code>、<code>number</code> 或者 <code>symbol</code>，是的话就会把 <code>object</code> 转为原始类型再进行判断</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span> == &#123; <span class="attr">name</span>: <span class="string">&#x27;js&#x27;</span> &#125;        ↓<span class="string">&#x27;1&#x27;</span> == <span class="string">&#x27;[object Object]&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其流程图如下： <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221929529.webp" alt="img"></p><h3 id="12-其他值到字符串的转换规则？"><a href="#12-其他值到字符串的转换规则？" class="headerlink" title="12. 其他值到字符串的转换规则？"></a>12. 其他值到字符串的转换规则？</h3><ul><li>Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，</li><li>Boolean 类型，true 转换为 “true”，false 转换为 “false”。</li><li>Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</li><li>Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</li><li>对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。</li></ul><h3 id="13-其他值到数字值的转换规则？"><a href="#13-其他值到数字值的转换规则？" class="headerlink" title="13. 其他值到数字值的转换规则？"></a>13. 其他值到数字值的转换规则？</h3><ul><li>Undefined 类型的值转换为 NaN。</li><li>Null 类型的值转换为 0。</li><li>Boolean 类型的值，true 转换为 1，false 转换为 0。</li><li>String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</li><li>Symbol 类型的值不能转换为数字，会报错。</li><li>对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</li></ul><p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。</p><p>如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</p><h3 id="14-其他值到布尔类型的值的转换规则？"><a href="#14-其他值到布尔类型的值的转换规则？" class="headerlink" title="14. 其他值到布尔类型的值的转换规则？"></a>14. 其他值到布尔类型的值的转换规则？</h3><p>以下这些是假值： • undefined • null • false • +0、-0 和 NaN • “”</p><p>假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</p><h3 id="15-和-amp-amp-操作符的返回值？"><a href="#15-和-amp-amp-操作符的返回值？" class="headerlink" title="15. || 和 &amp;&amp; 操作符的返回值？"></a>15. || 和 &amp;&amp; 操作符的返回值？</h3><p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。</p><ul><li>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</li><li>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</li></ul><p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</p><h3 id="16-Object-is-与比较操作符-“-”、“-”-的区别？"><a href="#16-Object-is-与比较操作符-“-”、“-”-的区别？" class="headerlink" title="16. Object.is() 与比较操作符 “===”、“==” 的区别？"></a>16. Object.is() 与比较操作符 “===”、“==” 的区别？</h3><ul><li>使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</li><li>使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</li><li>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</li></ul><h3 id="17-什么是-JavaScript-中的包装类型？"><a href="#17-什么是-JavaScript-中的包装类型？" class="headerlink" title="17. 什么是 JavaScript 中的包装类型？"></a>17. 什么是 JavaScript 中的包装类型？</h3><p>在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">a.length; <span class="comment">// 3</span></span><br><span class="line">a.toUpperCase(); <span class="comment">// &quot;ABC&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在访问<code>&#39;abc&#39;.length</code>时，JavaScript 将<code>&#39;abc&#39;</code>在后台转换成<code>String(&#39;abc&#39;)</code>，然后再访问其<code>length</code>属性。</p><p>JavaScript也可以使用<code>Object</code>函数显式地将基本类型转换为包装类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>(a) <span class="comment">// String &#123;&quot;abc&quot;&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>也可以使用<code>valueOf</code>方法将包装类型倒转成基本类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>(a)</span><br><span class="line"><span class="keyword">var</span> c = b.valueOf() <span class="comment">// &#x27;abc&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>看看如下代码会打印出什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Boolean</span>( <span class="literal">false</span> );</span><br><span class="line"><span class="keyword">if</span> (!a) &#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;Oops&quot;</span> ); <span class="comment">// never runs</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>答案是什么都不会打印，因为虽然包裹的基本类型是<code>false</code>，但是<code>false</code>被包裹成包装类型后就成了对象，所以其非值为<code>false</code>，所以循环体中的内容不会运行。</p><h3 id="18-JavaScript-中如何进行隐式类型转换？"><a href="#18-JavaScript-中如何进行隐式类型转换？" class="headerlink" title="18. JavaScript 中如何进行隐式类型转换？"></a>18. JavaScript 中如何进行隐式类型转换？</h3><p>首先要介绍<code>ToPrimitive</code>方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@obj </span>需要转换的对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@type </span>期望的结果类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ToPrimitive(obj,type)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>type</code>的值为<code>number</code>或者<code>string</code>。</p><p><strong>（1）当</strong><code>type</code><strong>为</strong><code>number</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>valueOf</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>toString</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p><strong>（2）当</strong><code>type</code><strong>为</strong><code>string</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>toString</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>valueOf</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p>可以看出两者的主要区别在于调用<code>toString</code>和<code>valueOf</code>的先后顺序。默认情况下：</p><ul><li>如果对象为 Date 对象，则<code>type</code>默认为<code>string</code>；</li><li>其他情况下，<code>type</code>默认为<code>number</code>。</li></ul><p>总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objToNumber = <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">Number</span>(value.valueOf().toString())</span><br><span class="line">objToNumber([]) === <span class="number">0</span></span><br><span class="line">objToNumber(&#123;&#125;) === <span class="literal">NaN</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>而 JavaScript 中的隐式类型转换主要发生在<code>+、-、*、/</code>以及<code>==、&gt;、&lt;</code>这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用<code>ToPrimitive</code>转换成基本类型，再进行操作。</p><p>以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被<code>ToPrimitive</code>转换成基本类型，所以最终还是要应用基本类型转换规则）：</p><ol><li><code>+</code><strong>操作符</strong></li></ol><p><code>+</code>操作符的两边有至少一个<code>string</code>类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;23&#x27;</span> <span class="comment">// &#x27;123&#x27;</span></span><br><span class="line"> <span class="number">1</span> + <span class="literal">false</span> <span class="comment">// 1 </span></span><br><span class="line"> <span class="number">1</span> + <span class="built_in">Symbol</span>() <span class="comment">// Uncaught TypeError: Cannot convert a Symbol value to a number</span></span><br><span class="line"> <span class="string">&#x27;1&#x27;</span> + <span class="literal">false</span> <span class="comment">// &#x27;1false&#x27;</span></span><br><span class="line"> <span class="literal">false</span> + <span class="literal">true</span> <span class="comment">// 1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li><code>-</code>、<code>*</code>、<code>\</code><strong>操作符</strong></li></ol><p><code>NaN</code>也是一个数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> * <span class="string">&#x27;23&#x27;</span> <span class="comment">// 23</span></span><br><span class="line"> <span class="number">1</span> * <span class="literal">false</span> <span class="comment">// 0</span></span><br><span class="line"> <span class="number">1</span> / <span class="string">&#x27;aa&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li><strong>对于</strong><code>==</code><strong>操作符</strong></li></ol><p>操作符两边的值都尽量转成<code>number</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> == <span class="literal">true</span> <span class="comment">// false, 3 转为number为3，true转为number为1</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">false</span> <span class="comment">//true, &#x27;0&#x27;转为number为0，false转为number为0</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="number">0</span> <span class="comment">// &#x27;0&#x27;转为number为0</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li><strong>对于</strong><code>&lt;</code><strong>和</strong><code>&gt;</code><strong>比较符</strong></li></ol><p>如果两边都是字符串，则比较字母表顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;ca&#x27;</span> &lt; <span class="string">&#x27;bd&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> &lt; <span class="string">&#x27;b&#x27;</span> <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其他情况下，转换为数字再比较：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;12&#x27;</span> &lt; <span class="number">13</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> &gt; -<span class="number">1</span> <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上说的是基本类型的隐式转换，而对象会被<code>ToPrimitive</code>转换为基本类型再进行转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line">a &gt; <span class="number">2</span> <span class="comment">// false</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其对比过程如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a.valueOf() <span class="comment">// &#123;&#125;, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span></span><br><span class="line">a.toString() <span class="comment">// &quot;[object Object]&quot;，现在是一个字符串了</span></span><br><span class="line"><span class="built_in">Number</span>(a.toString()) <span class="comment">// NaN，根据上面 &lt; 和 &gt; 操作符的规则，要转换成数字</span></span><br><span class="line"><span class="literal">NaN</span> &gt; <span class="number">2</span> <span class="comment">//false，得出比较结果</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>又比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>:<span class="string">&#x27;Jack&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line">a + b <span class="comment">// &quot;[object Object][object Object]&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>运算过程如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a.valueOf() <span class="comment">// &#123;&#125;，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span></span><br><span class="line">a.toString() <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line">b.valueOf() <span class="comment">// 同理</span></span><br><span class="line">b.toString() <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line">a + b <span class="comment">// &quot;[object Object][object Object]&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="19-操作符什么时候用于字符串的拼接？"><a href="#19-操作符什么时候用于字符串的拼接？" class="headerlink" title="19. + 操作符什么时候用于字符串的拼接？"></a>19. <code>+</code> 操作符什么时候用于字符串的拼接？</h3><p>根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p><p>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。</p><p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p><h3 id="20-为什么会有BigInt的提案？"><a href="#20-为什么会有BigInt的提案？" class="headerlink" title="20. 为什么会有BigInt的提案？"></a>20. 为什么会有<strong>BigInt</strong>的提案？</h3><p>JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。</p><h3 id="21-object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别"><a href="#21-object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别" class="headerlink" title="21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别"></a>21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别</h3><p>扩展运算符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outObj = &#123;</span><br><span class="line">  <span class="attr">inObj</span>: &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = &#123;...outObj&#125;</span><br><span class="line">newObj.inObj.a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(outObj) <span class="comment">// &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Object.assign():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outObj = &#123;</span><br><span class="line">  <span class="attr">inObj</span>: &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;, outObj)</span><br><span class="line">newObj.inObj.a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(outObj) <span class="comment">// &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看到，两者都是浅拷贝。</p><ul><li>Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</li><li>扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。</li></ul><h2 id="二、ES6"><a href="#二、ES6" class="headerlink" title="二、ES6"></a>二、ES6</h2><h3 id="1-let、const、var的区别"><a href="#1-let、const、var的区别" class="headerlink" title="1. let、const、var的区别"></a>1. let、const、var的区别</h3><p><strong>（1）块级作用域：</strong> 块作用域由 <code>&#123; &#125;</code>包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</p><ul><li>内层变量可能覆盖外层变量</li><li>用来计数的循环变量泄露为全局变量</li></ul><p><strong>（2）变量提升：</strong> var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p><p><strong>（3）给全局添加属性：</strong> 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。</p><p><strong>（4）重复声明：</strong> var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</p><p><strong>（5）暂时性死区：</strong> 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为<strong>暂时性死区</strong>。使用var声明的变量不存在暂时性死区。</p><p><strong>（6）初始值设置：</strong> 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</p><p><strong>（7）指针指向：</strong> let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p><table><thead><tr><th><strong>区别</strong></th><th><strong>var</strong></th><th><strong>let</strong></th><th><strong>const</strong></th></tr></thead><tbody><tr><td>是否有块级作用域</td><td>×</td><td>✔️</td><td>✔️</td></tr><tr><td>是否存在变量提升</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>是否添加全局属性</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>能否重复声明变量</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>是否存在暂时性死区</td><td>×</td><td>✔️</td><td>✔️</td></tr><tr><td>是否必须设置初始值</td><td>×</td><td>×</td><td>✔️</td></tr><tr><td>能否改变指针指向</td><td>✔️</td><td>✔️</td><td>×</td></tr></tbody></table><h3 id="2-const对象的属性可以修改吗"><a href="#2-const对象的属性可以修改吗" class="headerlink" title="2. const对象的属性可以修改吗"></a>2. const对象的属性可以修改吗</h3><p>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。</p><p>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p><h3 id="3-如果new一个箭头函数的会怎么样"><a href="#3-如果new一个箭头函数的会怎么样" class="headerlink" title="3. 如果new一个箭头函数的会怎么样"></a>3. 如果new一个箭头函数的会怎么样</h3><p>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p><p>new操作符的实现步骤如下：</p><ol><li>创建一个对象</li><li>将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）</li><li>指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）</li><li>返回新的对象</li></ol><p>所以，上面的第二、三步，箭头函数都是没有办法执行的。</p><h3 id="4-箭头函数与普通函数的区别"><a href="#4-箭头函数与普通函数的区别" class="headerlink" title="4. 箭头函数与普通函数的区别"></a>4. 箭头函数与普通函数的区别</h3><p><strong>（1）箭头函数比普通函数更加简洁</strong></p><ul><li>如果没有参数，就直接写一个空括号即可</li><li>如果只有一个参数，可以省去参数的括号</li><li>如果有多个参数，用逗号分割</li><li>如果函数体的返回值只有一句，可以省略大括号</li><li>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function">() =&gt;</span> <span class="keyword">void</span> doesNotReturn();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>（2）箭头函数没有自己的this</strong></p><p>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</p><p><strong>（3）箭头函数继承来的this指向永远不会改变</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;GLOBAL&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;OBJ&#x27;</span>,</span><br><span class="line">  <span class="attr">a</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.a();    <span class="comment">// &#x27;OBJ&#x27;</span></span><br><span class="line">obj.b();    <span class="comment">// &#x27;GLOBAL&#x27;</span></span><br><span class="line"><span class="keyword">new</span> obj.a()  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">new</span> obj.b()  <span class="comment">// Uncaught TypeError: obj.b is not a constructor</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号<code>&#123;&#125;</code>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p><p><strong>（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;Global&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> fun1 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id)</span><br><span class="line">&#125;;</span><br><span class="line">fun1();                     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.call(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.apply(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);    <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.bind(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;)();   <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>（5）箭头函数不能作为构造函数使用</strong></p><p>构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</p><p><strong>（6）箭头函数没有自己的arguments</strong></p><p>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</p><p><strong>（7）箭头函数没有prototype</strong></p><p><strong>（8）箭头函数不能用作Generator函数，不能使用yeild关键字</strong></p><h3 id="5-箭头函数的this指向哪⾥？"><a href="#5-箭头函数的this指向哪⾥？" class="headerlink" title="5. 箭头函数的this指向哪⾥？"></a>5. 箭头函数的<strong>this</strong>指向哪⾥？</h3><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p><p>可以⽤Babel理解⼀下箭头函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 </span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; </span><br><span class="line">  <span class="function"><span class="title">getArrow</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span> === obj); </span><br><span class="line">    &#125;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>转化后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5，由 Babel 转译</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">   <span class="attr">getArrow</span>: <span class="function"><span class="keyword">function</span> <span class="title">getArrow</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">     <span class="keyword">var</span> _this = <span class="built_in">this</span>; </span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(_this === obj); </span><br><span class="line">     &#125;; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="6-扩展运算符的作用及使用场景"><a href="#6-扩展运算符的作用及使用场景" class="headerlink" title="6. 扩展运算符的作用及使用场景"></a>6. 扩展运算符的作用及使用场景</h3><p><strong>（1）对象扩展运算符</strong></p><p>对象的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> baz = &#123; ...bar &#125;; <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上述方法实际上等价于:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="built_in">Object</span>.assign(&#123;&#125;, bar); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>Object.assign</code>方法用于对象的合并，将源对象<code>（source）</code>的所有可枚举属性，复制到目标对象<code>（target）</code>。<code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。(<strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</strong>)。</p><p>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> baz = &#123;...bar, ...&#123;<span class="attr">a</span>:<span class="number">2</span>, <span class="attr">b</span>: <span class="number">4</span>&#125;&#125;;  <span class="comment">// &#123;a: 2, b: 4&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>利用上述特性就可以很方便的修改对象的部分属性。在<code>redux</code>中的<code>reducer</code>函数规定必须是<strong>一个纯函数</strong>，<code>reducer</code>中的<code>state</code>对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。</p><p>需要注意：<strong>扩展运算符对对象实例的拷贝属于浅拷贝</strong>。</p><p><strong>（2）数组扩展运算符</strong></p><p>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>])</span><br><span class="line"><span class="comment">// 1 [2, 3, 4] 5</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>下面是数组的扩展运算符的应用：</p><ul><li><strong>将数组转换为参数序列</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">add(...numbers) <span class="comment">// 3</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>复制数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [...arr1];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>要记住：<strong>扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</strong>，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。</p><ul><li><strong>合并数组</strong></li></ul><p>如果想在数组内合并数组，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];<span class="keyword">const</span> arr2 = [<span class="string">&#x27;one&#x27;</span>, ...arr1, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>];<span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>扩展运算符与解构赋值结合起来，用于生成数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];first <span class="comment">// 1rest  // [2, 3, 4, 5]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>需要注意：<strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [...rest, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];         <span class="comment">// 报错const [first, ...rest, last] = [1, 2, 3, 4, 5];  // 报错</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>将字符串转为真正的数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]    <span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组</strong></li></ul><p>比较常见的应用是可以将某些数据结构转为数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> args = [...arguments];</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>用于替换<code>es5</code>中的<code>Array.prototype.slice.call(arguments)</code>写法。</p><ul><li><strong>使用</strong><code>Math</code><strong>函数获取数组中特定的值</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>];</span><br><span class="line"><span class="built_in">Math</span>.min(...numbers); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.max(...numbers); <span class="comment">// 9</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="7-Proxy-可以实现什么功能？"><a href="#7-Proxy-可以实现什么功能？" class="headerlink" title="7. Proxy 可以实现什么功能？"></a>7. Proxy 可以实现什么功能？</h3><p>在 Vue3.0 中通过 <code>Proxy</code> 来替换原本的 <code>Object.defineProperty</code> 来实现数据响应式。</p><p>Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>target</code> 代表需要添加代理的对象，<code>handler</code> 用来自定义对象中的操作，比如可以用来自定义 <code>set</code> 或者 <code>get</code> 函数。</p><p>下面来通过 <code>Proxy</code> 来实现一个数据响应式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> onWatch = <span class="function">(<span class="params">obj, setBind, getLogger</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, property, receiver</span>)</span> &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, property, value, receiver</span>)</span> &#123;</span><br><span class="line">      setBind(value, property)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, property, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> p = onWatch(</span><br><span class="line">  obj,</span><br><span class="line">  <span class="function">(<span class="params">v, property</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`监听到属性<span class="subst">$&#123;property&#125;</span>改变为<span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">target, property</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`&#x27;<span class="subst">$&#123;property&#125;</span>&#x27; = <span class="subst">$&#123;target[property]&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">p.a = <span class="number">2</span> <span class="comment">// 监听到属性a改变</span></span><br><span class="line">p.a <span class="comment">// &#x27;a&#x27; = 2</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在上述代码中，通过自定义 <code>set</code> 和 <code>get</code> 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。</p><p>当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要在 <code>get</code> 中收集依赖，在 <code>set</code> 派发更新，之所以 Vue3.0 要使用 <code>Proxy</code> 替换原本的 API 原因在于 <code>Proxy</code> 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 <code>Proxy</code> 可以完美监听到任何方式的数据改变，唯一缺陷就是浏览器的兼容性不好。</p><h3 id="8-对对象与数组的解构的理解"><a href="#8-对对象与数组的解构的理解" class="headerlink" title="8. 对对象与数组的解构的理解"></a>8. 对对象与数组的解构的理解</h3><p>解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。 <strong>1）数组的解构</strong> 在解构数组时，以元素的位置为匹配条件来提取想要的数据的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>最终，a、b、c分别被赋予了数组第0、1、2个索引位的值： <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221929067.webp" alt="img"> 数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a,,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量： <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221929660.webp" alt="img"></p><p><strong>2）对象的解构</strong> 对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stu = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>假如想要解构它的两个自有属性，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = stu</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样就得到了 name 和 age 两个和 stu 平级的变量： <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221929625.webp" alt="img"></p><p>注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; age, name &#125; = stu</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="9-如何提取高度嵌套的对象里的指定属性？"><a href="#9-如何提取高度嵌套的对象里的指定属性？" class="headerlink" title="9. 如何提取高度嵌套的对象里的指定属性？"></a>9. <strong>如何提取高度嵌套的对象里的指定属性？</strong></h3><p>有时会遇到一些嵌套程度非常深的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">   <span class="attr">classes</span>: &#123;</span><br><span class="line">      <span class="attr">stu</span>: &#123;</span><br><span class="line">         <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">         <span class="attr">age</span>: <span class="number">24</span>,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name &#125; = school</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; classes &#125; = school</span><br><span class="line"><span class="keyword">const</span> &#123; stu &#125; = classes</span><br><span class="line"><span class="keyword">const</span> &#123; name &#125; = stu</span><br><span class="line">name <span class="comment">// &#x27;Bob&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>但是还有一种更标准的做法，可以用一行代码来解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">classes</span>: &#123; <span class="attr">stu</span>: &#123; name &#125; &#125;&#125; = school</span><br><span class="line">       </span><br><span class="line"><span class="built_in">console</span>.log(name)  <span class="comment">// &#x27;Bob&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。</p><h3 id="10-对-rest-参数的理解"><a href="#10-对-rest-参数的理解" class="headerlink" title="10. 对 rest 参数的理解"></a>10. 对 rest 参数的理解</h3><p>扩展运算符被用在函数形参上时，<strong>它还可以把一个分离的参数序列整合成一个数组</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mutiple</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> args) &#123;</span><br><span class="line">    result *= val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">mutiple(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 24</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mutiple</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args)</span><br><span class="line">&#125;</span><br><span class="line">mutiple(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点<strong>经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</strong></p><h3 id="11-ES6中模板语法与字符串处理"><a href="#11-ES6中模板语法与字符串处理" class="headerlink" title="11. ES6中模板语法与字符串处理"></a>11. ES6中模板语法与字符串处理</h3><p>ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;css&#x27;</span>   </span><br><span class="line"><span class="keyword">var</span> career = <span class="string">&#x27;coder&#x27;</span> </span><br><span class="line"><span class="keyword">var</span> hobby = [<span class="string">&#x27;coding&#x27;</span>, <span class="string">&#x27;writing&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> finalString = <span class="string">&#x27;my name is &#x27;</span> + name + <span class="string">&#x27;, I work as a &#x27;</span> + career + <span class="string">&#x27;, I love &#x27;</span> + hobby[<span class="number">0</span>] + <span class="string">&#x27; and &#x27;</span> + hobby[<span class="number">1</span>]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;css&#x27;</span>   </span><br><span class="line"><span class="keyword">var</span> career = <span class="string">&#x27;coder&#x27;</span> </span><br><span class="line"><span class="keyword">var</span> hobby = [<span class="string">&#x27;coding&#x27;</span>, <span class="string">&#x27;writing&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> finalString = <span class="string">`my name is <span class="subst">$&#123;name&#125;</span>, I work as a <span class="subst">$&#123;career&#125;</span> I love <span class="subst">$&#123;hobby[<span class="number">0</span>]&#125;</span> and <span class="subst">$&#123;hobby[<span class="number">1</span>]&#125;</span>`</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：</p><ul><li>在模板字符串中，空格、缩进、换行都会被保留</li><li>模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算</li></ul><p>基于第一点，可以在模板字符串里无障碍地直接写 html 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;列表项1&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;列表项2&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 正确输出，不存在报错</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> finalString = <span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a+b&#125;</span>`</span></span><br><span class="line">  <span class="built_in">console</span>.log(finalString)</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 输出 &#x27;1 + 2 = 3&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：</p><p>（1）<strong>存在性判定</strong>：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf &gt; -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。</p><ul><li><strong>includes</strong>：判断字符串与子串的包含关系：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> son = <span class="string">&#x27;haha&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span></span><br><span class="line">father.includes(son) <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>startsWith</strong>：判断字符串是否以某个/某串字符开头：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span></span><br><span class="line">father.startsWith(<span class="string">&#x27;haha&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">father.startsWith(<span class="string">&#x27;xixi&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>endsWith</strong>：判断字符串是否以某个/某串字符结尾：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span></span><br><span class="line">  father.endsWith(<span class="string">&#x27;hehe&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（2）<strong>自动重复</strong>：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sourceCode = <span class="string">&#x27;repeat for 3 times;&#x27;</span></span><br><span class="line"><span class="keyword">const</span> repeated = sourceCode.repeat(<span class="number">3</span>) </span><br><span class="line"><span class="built_in">console</span>.log(repeated) <span class="comment">// repeat for 3 times;repeat for 3 times;repeat for 3 times;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="三、JavaScript基础"><a href="#三、JavaScript基础" class="headerlink" title="三、JavaScript基础"></a>三、JavaScript基础</h2><h3 id="1-new操作符的实现原理"><a href="#1-new操作符的实现原理" class="headerlink" title="1. new操作符的实现原理"></a>1. new操作符的实现原理</h3><p><strong>new操作符的执行过程：</strong></p><p>（1）首先创建了一个新的空对象</p><p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p><p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p><p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><p>具体实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="title">constructor</span> = <span class="title">Array</span>.<span class="title">prototype</span>.<span class="title">shift</span>.<span class="title">call</span>(<span class="params"><span class="built_in">arguments</span></span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断参数是否是一个函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title">constructor</span> !== &quot;<span class="title">function</span>&quot;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="built_in">Object</span>.create(<span class="title">constructor</span>.<span class="title">prototype</span>);</span><br><span class="line">  <span class="comment">// 将 this 指向新建对象，并执行函数</span></span><br><span class="line">  result = <span class="title">constructor</span>.<span class="title">apply</span>(<span class="params">newObject, <span class="built_in">arguments</span></span>);</span><br><span class="line">  <span class="comment">// 判断返回对象</span></span><br><span class="line">  <span class="keyword">let</span> flag = result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line">  <span class="comment">// 判断返回结果</span></span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">objectFactory(构造函数, 初始化参数);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="2-map和Object的区别"><a href="#2-map和Object的区别" class="headerlink" title="2. map和Object的区别"></a>2. map和Object的区别</h3><table><thead><tr><th></th><th>Map</th><th>Object</th></tr></thead><tbody><tr><td>意外的键</td><td>Map默认情况不包含任何键，只包含显式插入的键。</td><td>Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。</td></tr><tr><td>键的类型</td><td>Map的键可以是任意值，包括函数、对象或任意基本类型。</td><td>Object 的键必须是 String 或是Symbol。</td></tr><tr><td>键的顺序</td><td>Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。</td><td>Object 的键是无序的</td></tr><tr><td>Size</td><td>Map 的键值对个数可以轻易地通过size 属性获取</td><td>Object 的键值对个数只能手动计算</td></tr><tr><td>迭代</td><td>Map 是 iterable 的，所以可以直接被迭代。</td><td>迭代Object需要以某种方式获取它的键然后才能迭代。</td></tr><tr><td>性能</td><td>在频繁增删键值对的场景下表现更好。</td><td>在频繁添加和删除键值对的场景下未作出优化。</td></tr></tbody></table><h3 id="3-map和weakMap的区别"><a href="#3-map和weakMap的区别" class="headerlink" title="3. map和weakMap的区别"></a>3. map和weakMap的区别</h3><p><strong>（1）Map</strong> map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。</p><p>实际上Map是一个数组，它的每一个数据也都是一个数组，其形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = [</span><br><span class="line">     [<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>],</span><br><span class="line">     [<span class="string">&quot;age&quot;</span>,<span class="number">18</span>],</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Map数据结构有以下操作方法：</p><ul><li><strong>size</strong>： <code>map.size</code> 返回Map结构的成员总数。</li><li>**set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li><li>**get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined。</li><li>**has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li><li>**delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false。</li><li>**clear()**：map.clear()清除所有成员，没有返回值。</li></ul><p>Map结构原生提供是三个遍历器生成函数和一个遍历方法</p><ul><li>keys()：返回键名的遍历器。</li><li>values()：返回键值的遍历器。</li><li>entries()：返回所有成员的遍历器。</li><li>forEach()：遍历Map的所有成员。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">     [<span class="string">&quot;foo&quot;</span>,<span class="number">1</span>],</span><br><span class="line">     [<span class="string">&quot;bar&quot;</span>,<span class="number">2</span>],</span><br><span class="line">])</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> map.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);  <span class="comment">// foo bar</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> map.values())&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(value); <span class="comment">// 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> items <span class="keyword">of</span> map.entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(items);  <span class="comment">// [&quot;foo&quot;,1]  [&quot;bar&quot;,2]</span></span><br><span class="line">&#125;</span><br><span class="line">map.forEach( <span class="function">(<span class="params">value,key,map</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(key,value); <span class="comment">// foo 1    bar 2</span></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>（2）WeakMap</strong> WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。<strong>其键必须是对象</strong>，原始数据类型不能作为key值，而值可以是任意的。</p><p>该对象也有以下几种方法：</p><ul><li>**set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li><li>**get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined。</li><li>**has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li><li>**delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false。</li></ul><p>其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。</p><p>WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。</p><p>而WeakMap的<strong>键名所引用的对象都是弱引用</strong>，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的<strong>键名对象和所对应的键值对会自动消失，不用手动删除引用</strong>。</p><p><strong>总结：</strong></p><ul><li>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li><li>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li></ul><h3 id="4-JavaScript有哪些内置对象"><a href="#4-JavaScript有哪些内置对象" class="headerlink" title="4. JavaScript有哪些内置对象"></a>4. JavaScript有哪些内置对象</h3><p>全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在 全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p><p><strong>标准内置对象的分类：</strong></p><p>（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量</p><p>（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等</p><p>（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等</p><p>（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date</p><p>（5）字符串，用来表示和操作字符串的对象。例如 String、RegExp</p><p>（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</p><p>（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。 例如 Map、Set、WeakMap、WeakSet</p><p>（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。 例如 SIMD 等</p><p>（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等</p><p>（10）控制抽象对象 例如 Promise、Generator 等</p><p>（11）反射。例如 Reflect、Proxy</p><p>（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等</p><p>（13）WebAssembly</p><p>（14）其他。例如 arguments</p><p><strong>总结：</strong> js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。</p><h3 id="5-常用的正则表达式有哪些？"><a href="#5-常用的正则表达式有哪些？" class="headerlink" title="5. 常用的正则表达式有哪些？"></a>5. 常用的正则表达式有哪些？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）匹配 16 进制颜色值</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）匹配 qq 号</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）手机号码正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^1[34578]\d&#123;9&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （5）用户名正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="6-对JSON的理解"><a href="#6-对JSON的理解" class="headerlink" title="6. 对JSON的理解"></a>6. 对JSON的理解</h3><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p><p>在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p><p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p><p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，</p><ul><li>JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</li><li>JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</li></ul><h3 id="7-JavaScript脚本延迟加载的方式有哪些？"><a href="#7-JavaScript脚本延迟加载的方式有哪些？" class="headerlink" title="7. JavaScript脚本延迟加载的方式有哪些？"></a>7. JavaScript脚本延迟加载的方式有哪些？</h3><p>延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</p><p>一般有以下几种方式：</p><ul><li><strong>defer 属性：</strong> 给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</li><li><strong>async 属性：</strong> 给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</li><li><strong>动态创建 DOM 方式：</strong> 动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</li><li><strong>使用 setTimeout 延迟方法：</strong> 设置一个定时器来延迟加载js脚本文件</li><li><strong>让 JS 最后加载：</strong> 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</li></ul><h3 id="8-JavaScript-类数组对象的定义？"><a href="#8-JavaScript-类数组对象的定义？" class="headerlink" title="8. JavaScript 类数组对象的定义？"></a>8. JavaScript 类数组对象的定义？</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。</p><p>常见的类数组转换为数组的方法有这样几种：</p><p>（1）通过 call 调用数组的 slice 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（2）通过 call 调用数组的 splice 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（3）通过 apply 调用数组的 concat 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（4）通过 Array.from 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="9-数组有哪些原生方法？"><a href="#9-数组有哪些原生方法？" class="headerlink" title="9. 数组有哪些原生方法？"></a>9. 数组有哪些原生方法？</h3><ul><li>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li><li>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li><li>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li><li>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li><li>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li><li>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li><li>数组归并方法 reduce() 和 reduceRight() 方法</li></ul><h3 id="10-Unicode、UTF-8、UTF-16、UTF-32的区别？"><a href="#10-Unicode、UTF-8、UTF-16、UTF-32的区别？" class="headerlink" title="10. Unicode、UTF-8、UTF-16、UTF-32的区别？"></a>10. <strong>Unicode、UTF-8、UTF-16、UTF-32的区别？</strong></h3><h4 id="（1）Unicode"><a href="#（1）Unicode" class="headerlink" title="（1）Unicode"></a>（1）Unicode</h4><p>在说<code>Unicode</code>之前需要先了解一下<code>ASCII</code>码：ASCII 码（<code>American Standard Code for Information Interchange</code>）称为美国标准信息交换码。</p><ul><li>它是基于拉丁字母的一套电脑编码系统。</li><li>它定义了一个用于代表常见字符的字典。</li><li>它包含了”A-Z”(包含大小写)，数据”0-9” 以及一些常见的符号。</li><li>它是专门为英语而设计的，有128个编码，对其他语言无能为力</li></ul><p><code>ASCII</code>码可以表示的编码有限，要想表示其他语言的编码，还是要使用<code>Unicode</code>来表示，可以说<code>Unicode</code>是<code>ASCII</code> 的超集。</p><p><code>Unicode</code>全称 <code>Unicode Translation Format</code>，又叫做统一码、万国码、单一码。<code>Unicode</code> 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</p><p><code>Unicode</code>的实现方式（也就是编码方式）有很多种，常见的是<strong>UTF-8</strong>、<strong>UTF-16</strong>、<strong>UTF-32</strong>和<strong>USC-2</strong>。</p><h4 id="（2）UTF-8"><a href="#（2）UTF-8" class="headerlink" title="（2）UTF-8"></a>（2）UTF-8</h4><p><code>UTF-8</code>是使用最广泛的<code>Unicode</code>编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容<code>ASCII</code>码的128个字符。</p><p><strong>注意：</strong> <code>UTF-8</code> 是一种编码方式，<code>Unicode</code>是一个字符集合。</p><p><code>UTF-8</code>的编码规则：</p><ul><li>对于<strong>单字节</strong>的符号，字节的第一位为0，后面的7位为这个字符的<code>Unicode</code>编码，因此对于英文字母，它的<code>Unicode</code>编码和<code>ACSII</code>编码一样。</li><li>对于<strong>n字节</strong>的符号，第一个字节的前n位都是1，第n+1位设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制位，全部为这个符号的<code>Unicode</code>码 。</li></ul><p>来看一下具体的<code>Unicode</code>编号范围与对应的<code>UTF-8</code>二进制格式 ：</p><table><thead><tr><th>编码范围（编号对应的十进制数）</th><th>二进制格式</th></tr></thead><tbody><tr><td>0x00—0x7F （0-127）</td><td>0xxxxxxx</td></tr><tr><td>0x80—0x7FF （128-2047）</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>0x800—0xFFFF  （2048-65535）</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>0x10000—0x10FFFF  （65536以上）</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>那该如何通过具体的<code>Unicode</code>编码，进行具体的<code>UTF-8</code>编码呢？<strong>步骤如下：</strong></p><ul><li>找到该<code>Unicode</code>编码的所在的编号范围，进而找到与之对应的二进制格式</li><li>将<code>Unicode</code>编码转换为二进制数（去掉最高位的0）</li><li>将二进制数从右往左一次填入二进制格式的<code>X</code>中，如果有<code>X</code>未填，就设为0</li></ul><p>来看一个实际的例子： “<strong>马</strong>” 字的<code>Unicode</code>编码是：<code>0x9A6C</code>，整数编号是<code>39532</code> （1）首选确定了该字符在第三个范围内，它的格式是 <code>1110xxxx 10xxxxxx 10xxxxxx</code> （2）39532对应的二进制数为<code>1001 1010 0110 1100</code> （3）将二进制数填入X中，结果是：<code>11101001 10101001 10101100</code></p><h4 id="（3）UTF-16"><a href="#（3）UTF-16" class="headerlink" title="（3）UTF-16"></a>（3）UTF-16</h4><p><strong>1. 平面的概念</strong></p><p>在了解<code>UTF-16</code>之前，先看一下<strong>平面</strong>的概念： <code>Unicode</code>编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放<strong>65536</strong>（216）个字符，这称为一个<strong>平面</strong>，目前总共有17 个平面。</p><p>最前面的一个平面称为<strong>基本平面</strong>，它的码点从<strong>0 — 216-1</strong>，写成16进制就是<code>U+0000 — U+FFFF</code>，那剩下的16个平面就是<strong>辅助平面</strong>，码点范围是 <code>U+10000—U+10FFFF</code>。</p><p><strong>2. UTF-16 概念：</strong></p><p><code>UTF-16</code>也是<code>Unicode</code>编码集的一种编码形式，把<code>Unicode</code>字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。<code>Unicode</code>字符的码位需要1个或者2个16位长的码元来表示，因此<code>UTF-16</code>也是用变长字节表示的。</p><p><strong>3. UTF-16 编码规则：</strong></p><ul><li>编号在 <code>U+0000—U+FFFF</code> 的字符（常用字符集），直接用两个字节表示。</li><li>编号在 <code>U+10000—U+10FFFF</code> 之间的字符，需要用四个字节表示。</li></ul><p><strong>4. 编码识别</strong></p><p>那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？</p><p><code>UTF-16</code> 编码肯定也考虑到了这个问题，在基本平面内，从 <code>U+D800 — U+DFFF</code> 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。</p><p>辅助平面共有 <strong>220</strong> 个字符位，因此表示这些字符至少需要 20 个二进制位。<code>UTF-16</code> 将这 20 个二进制位分成两半，前 10 位映射在 <code>U+D800 — U+DBFF</code>，称为<strong>高位</strong>（H），后 10 位映射在 <code>U+DC00 — U+DFFF</code>，称为<strong>低位</strong>（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。</p><p>因此，当遇到两个字节时，发现它的码点在 <code>U+D800 —U+DBFF</code>之间，就可以知道，它后面的两个字节的码点应该在 <code>U+DC00 — U+DFFF</code> 之间，这四个字节必须放在一起进行解读。</p><p><strong>5. 举例说明</strong></p><p>以 “<strong>𡠀</strong>“ 字为例，它的 <code>Unicode</code> 码点为 <code>0x21800</code>，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：</p><ul><li>首先计算超出部分的结果：<code>0x21800 - 0x10000</code></li><li>将上面的计算结果转为20位的二进制数，不足20位就在前面补0，结果为：<code>0001000110 0000000000</code></li><li>将得到的两个10位二进制数分别对应到两个区间中</li><li><code>U+D800</code> 对应的二进制数为 <code>1101100000000000</code>， 将<code>0001000110</code>填充在它的后10 个二进制位，得到 <code>1101100001000110</code>，转成 16 进制数为 <code>0xD846</code>。同理，低位为 <code>0xDC00</code>，所以这个字的<code>UTF-16</code> 编码为 <code>0xD846 0xDC00</code></li></ul><h4 id="（4）-UTF-32"><a href="#（4）-UTF-32" class="headerlink" title="（4） UTF-32"></a>（4） UTF-32</h4><p><code>UTF-32</code> 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。</p><p>比如“<strong>马</strong>” 字的Unicode编号是：<code>U+9A6C</code>，整数编号是<code>39532</code>，直接转化为二进制：<code>1001 1010 0110 1100</code>，这就是它的UTF-32编码。</p><h4 id="（5）总结"><a href="#（5）总结" class="headerlink" title="（5）总结"></a>（5）总结</h4><p><strong>Unicode、UTF-8、UTF-16、UTF-32有什么区别？</strong></p><ul><li><code>Unicode</code> 是编码字符集（字符集），而<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>是字符集编码（编码规则）；</li><li><code>UTF-16</code> 使用变长码元序列的编码方式，相较于定长码元序列的<code>UTF-32</code>算法更复杂，甚至比同样是变长码元序列的<code>UTF-8</code>也更为复杂，因为其引入了独特的<strong>代理对</strong>这样的代理机制；</li><li><code>UTF-8</code>需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而<code>UTF-16</code>不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；</li><li>如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用<code>UTF-8</code>就比<code>UTF-16</code>节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么<code>UTF-16</code>就占优势了，可以节省很多空间；</li></ul><h3 id="11-常见的位运算符有哪些？其计算规则是什么？"><a href="#11-常见的位运算符有哪些？其计算规则是什么？" class="headerlink" title="11. 常见的位运算符有哪些？其计算规则是什么？"></a>11. 常见的位运算符有哪些？其计算规则是什么？</h3><p>现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。</p><p>常见的位运算有以下几种：</p><table><thead><tr><th>运算符</th><th>描述</th><th>运算规则</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>与</td><td>两个位都为1时，结果才为1</td></tr><tr><td>`</td><td>`</td><td>或</td></tr><tr><td><code>^</code></td><td>异或</td><td>两个位相同为0，相异为1</td></tr><tr><td><code>~</code></td><td>取反</td><td>0变1，1变0</td></tr><tr><td><code>&lt;&lt;</code></td><td>左移</td><td>各二进制位全部左移若干位，高位丢弃，低位补0</td></tr><tr><td><code>&gt;&gt;</code></td><td>右移</td><td>各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃</td></tr></tbody></table><h4 id="1-按位与运算符（-amp-）"><a href="#1-按位与运算符（-amp-）" class="headerlink" title="1. 按位与运算符（&amp;）"></a>1. 按位与运算符（&amp;）</h4><p><strong>定义：</strong> 参加运算的两个数据<strong>按二进制位</strong>进行“与”运算。 <strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> &amp; <span class="number">0</span> = <span class="number">0</span>  </span><br><span class="line"><span class="number">0</span> &amp; <span class="number">1</span> = <span class="number">0</span>  </span><br><span class="line"><span class="number">1</span> &amp; <span class="number">0</span> = <span class="number">0</span>  </span><br><span class="line"><span class="number">1</span> &amp; <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>总结：两位同时为1，结果才为1，否则结果为0。 例如：3&amp;5 即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span> </span><br><span class="line">   <span class="number">0000</span> <span class="number">0101</span> </span><br><span class="line"> = <span class="number">0000</span> <span class="number">0001</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>因此 3&amp;5 的值为1。 注意：负数按补码形式参加按位与运算。</p><p><strong>用途：</strong></p><p><strong>（1）判断奇偶</strong></p><p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用<code>if ((i &amp; 1) == 0)</code>代替<code>if (i % 2 == 0)</code>来判断a是不是偶数。</p><p><strong>（2）清零</strong></p><p>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</p><h4 id="2-按位或运算符（-）"><a href="#2-按位或运算符（-）" class="headerlink" title="2. 按位或运算符（|）"></a>2. 按位或运算符（|）</h4><p><strong>定义：</strong> 参加运算的两个对象按二进制位进行“或”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> | <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> | <span class="number">1</span> = <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> | <span class="number">0</span> = <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> | <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象只要有一个为1，其值为1。 例如：3|5即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">  <span class="number">0000</span> <span class="number">0101</span> </span><br><span class="line">= <span class="number">0000</span> <span class="number">0111</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>因此，3|5的值为7。 注意：负数按补码形式参加按位或运算。</p><h4 id="3-异或运算符（-）"><a href="#3-异或运算符（-）" class="headerlink" title="3. 异或运算符（^）"></a>3. 异或运算符（^）</h4><p><strong>定义：</strong> 参加运算的两个数据按二进制位进行“异或”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ^ <span class="number">0</span> = <span class="number">0</span>  </span><br><span class="line"><span class="number">0</span> ^ <span class="number">1</span> = <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> ^ <span class="number">0</span> = <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> ^ <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。 例如：3|5即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">  <span class="number">0000</span> <span class="number">0101</span> </span><br><span class="line">= <span class="number">0000</span> <span class="number">0110</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>因此，3^5的值为6。 异或运算的性质:</p><ul><li>交换律：<code>(a^b)^c == a^(b^c)</code></li><li>结合律：<code>(a + b)^c == a^b + b^c</code></li><li>对于任何数x，都有 <code>x^x=0，x^0=x</code></li><li>自反性: <code>a^b^b=a^0=a</code>;</li></ul><h4 id="4-取反运算符"><a href="#4-取反运算符" class="headerlink" title="4. 取反运算符 (~)"></a>4. 取反运算符 (~)</h4><p><strong>定义：</strong> 参加运算的一个数据按二进制进行“取反”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="number">1</span> = <span class="number">0</span>~ <span class="number">0</span> = <span class="number">1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>总结：对一个二进制数按位取反，即将0变1，1变0。 例如：~6 即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0110</span>= <span class="number">1111</span> <span class="number">1001</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。 当发现按位取反为负数时，就<strong>直接取其补码</strong>，变为十进制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0110</span>   = <span class="number">1111</span> <span class="number">1001</span>反码：<span class="number">1000</span> <span class="number">0110</span>补码：<span class="number">1000</span> <span class="number">0111</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>因此，~6的值为-7。</p><h4 id="5-左移运算符（-lt-lt-）"><a href="#5-左移运算符（-lt-lt-）" class="headerlink" title="5. 左移运算符（&lt;&lt;）"></a>5. 左移运算符（&lt;&lt;）</h4><p><strong>定义：</strong> 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。 设 a=1010 1110，a = a&lt;&lt; 2 将a的二进制位左移2位、右补0，即得a=1011 1000。 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</p><h4 id="6-右移运算符（-gt-gt-）"><a href="#6-右移运算符（-gt-gt-）" class="headerlink" title="6. 右移运算符（&gt;&gt;）"></a>6. 右移运算符（&gt;&gt;）</h4><p><strong>定义：</strong> 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 例如：a=a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。 操作数每右移一位，相当于该数除以2。</p><h4 id="7-原码、补码、反码"><a href="#7-原码、补码、反码" class="headerlink" title="7. 原码、补码、反码"></a>7. 原码、补码、反码</h4><p>上面提到了补码、反码等知识，这里就补充一下。 计算机中的<strong>有符号数</strong>有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。</p><p><strong>（1）原码</strong></p><p>原码就是一个数的二进制数。例如：10的原码为0000 1010</p><p><strong>（2）反码</strong></p><ul><li>正数的反码与原码相同，如：10 反码为 0000 1010</li><li>负数的反码为除符号位，按位取反，即0变1，1变0。</li></ul><p>例如：-10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原码：<span class="number">1000</span> <span class="number">1010</span></span><br><span class="line">反码：<span class="number">1111</span> <span class="number">0101</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>（3）补码</strong></p><ul><li>正数的补码与原码相同，如：10 补码为 0000 1010</li><li>负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。</li></ul><p>例如：-10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原码：<span class="number">1000</span> <span class="number">1010</span></span><br><span class="line">反码：<span class="number">1111</span> <span class="number">0101</span></span><br><span class="line">补码：<span class="number">1111</span> <span class="number">0110</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?"></a>12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</h3><p><code>arguments</code>是一个对象，它的属性是从 0 开始依次递增的数字，还有<code>callee</code>和<code>length</code>等属性，与数组相似；但是它却没有数组常见的方法属性，如<code>forEach</code>, <code>reduce</code>等，所以叫它们类数组。</p><p>要遍历类数组，有三个方法：</p><p>（1）将数组的方法应用到类数组上，这时候就可以使用<code>call</code>和<code>apply</code>方法，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, <span class="function"><span class="params">a</span> =&gt;</span> <span class="built_in">console</span>.log(a))</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（2）使用Array.from方法将类数组转化成数组：‌</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">const</span> arrArgs = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>) </span><br><span class="line">  arrArgs.forEach(<span class="function"><span class="params">a</span> =&gt;</span> <span class="built_in">console</span>.log(a))</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（3）使用展开运算符将类数组转化成数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">const</span> arrArgs = [...arguments] </span><br><span class="line">    arrArgs.forEach(<span class="function"><span class="params">a</span> =&gt;</span> <span class="built_in">console</span>.log(a)) </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="13-什么是-DOM-和-BOM？"><a href="#13-什么是-DOM-和-BOM？" class="headerlink" title="13. 什么是 DOM 和 BOM？"></a>13. 什么是 DOM 和 BOM？</h3><ul><li>DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</li><li>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</li></ul><h3 id="14-对类数组对象的理解，如何转化为数组"><a href="#14-对类数组对象的理解，如何转化为数组" class="headerlink" title="14. 对类数组对象的理解，如何转化为数组"></a>14. 对类数组对象的理解，如何转化为数组</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。</p><p>常见的类数组转换为数组的方法有这样几种：</p><ul><li>通过 call 调用数组的 slice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>通过 call 调用数组的 splice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>通过 apply 调用数组的 concat 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>通过 Array.from 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="15-escape、encodeURI、encodeURIComponent-的区别"><a href="#15-escape、encodeURI、encodeURIComponent-的区别" class="headerlink" title="15. escape、encodeURI、encodeURIComponent 的区别"></a>15. escape、encodeURI、encodeURIComponent 的区别</h3><ul><li>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</li><li>encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</li><li>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</li></ul><h3 id="16-对AJAX的理解，实现一个AJAX请求"><a href="#16-对AJAX的理解，实现一个AJAX请求" class="headerlink" title="16. 对AJAX的理解，实现一个AJAX请求"></a>16. 对AJAX的理解，实现一个AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>创建AJAX请求的步骤：</p><ul><li><strong>创建一个 XMLHttpRequest 对象。</strong></li><li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li><li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li><li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SERVER_URL = <span class="string">&quot;/server&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 创建 Http 请求</span></span><br><span class="line">xhr.open(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置状态监听函数</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 当请求成功时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">    handle(<span class="built_in">this</span>.response);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="built_in">this</span>.statusText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="built_in">this</span>.statusText);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">xhr.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"><span class="comment">// 发送 Http 请求</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>使用Promise封装AJAX：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise 封装实现：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="comment">// 新建一个 http 请求</span></span><br><span class="line">    xhr.open(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 设置状态的监听函数</span></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 当请求成功或失败时，改变 promise 的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="built_in">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置错误监听函数</span></span><br><span class="line">    xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置响应的数据类型</span></span><br><span class="line">    xhr.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    <span class="comment">// 设置请求头信息</span></span><br><span class="line">    xhr.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    <span class="comment">// 发送 http 请求</span></span><br><span class="line">    xhr.send(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="17-JavaScript为什么要进行变量提升，它导致了什么问题？"><a href="#17-JavaScript为什么要进行变量提升，它导致了什么问题？" class="headerlink" title="17. JavaScript为什么要进行变量提升，它导致了什么问题？"></a>17. JavaScript为什么要进行变量提升，它导致了什么问题？</h3><p>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。</p><p>造成变量声明提升的<strong>本质原因</strong>是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。</p><p>首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。</p><ul><li><p>在解析阶段</p><p>，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p><ul><li>全局上下文：变量定义，函数声明</li><li>函数上下文：变量定义，函数声明，this，arguments</li></ul></li><li><p><strong>在执行阶段</strong>，就是按照代码的顺序依次执行。</p></li></ul><p>那为什么会进行变量提升呢？主要有以下两个原因：</p><ul><li>提高性能</li><li>容错性更好</li></ul><p><strong>（1）提高性能</strong> 在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。</p><p>在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。</p><p><strong>（2）容错性更好</strong></p><p>变量提升可以在一定程度上提高JS的容错性，看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;<span class="keyword">var</span> a;<span class="built_in">console</span>.log(a);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。</p><p>虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。</p><p><strong>总结：</strong></p><ul><li>解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间</li><li>声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</li></ul><p>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(tmp);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();  <span class="comment">// undefined</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tmp.length; i++) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(tmp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 11</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。</p><h3 id="18-什么是尾调用，使用尾调用有什么好处？"><a href="#18-什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="18. 什么是尾调用，使用尾调用有什么好处？"></a>18. 什么是尾调用，使用尾调用有什么好处？</h3><p>尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p><h3 id="19-ES6模块与CommonJS模块有什么异同？"><a href="#19-ES6模块与CommonJS模块有什么异同？" class="headerlink" title="19.  ES6模块与CommonJS模块有什么异同？"></a>19.  <strong>ES6</strong>模块与<strong>CommonJS</strong>模块有什么异同？</h3><p>ES6 Module和CommonJS模块的区别：</p><ul><li>CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；</li><li>import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。</li></ul><p>ES6 Module和CommonJS模块的共同点：</p><ul><li>CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。</li></ul><h3 id="20-常见的DOM操作有哪些"><a href="#20-常见的DOM操作有哪些" class="headerlink" title="20. 常见的DOM操作有哪些"></a>20. 常见的DOM操作有哪些</h3><h4 id="1）DOM-节点的获取"><a href="#1）DOM-节点的获取" class="headerlink" title="1）DOM 节点的获取"></a>1）DOM 节点的获取</h4><p>DOM 节点的获取的API及使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">getElementById <span class="comment">// 按照 id 查询</span></span><br><span class="line">getElementsByTagName <span class="comment">// 按照标签名查询</span></span><br><span class="line">getElementsByClassName <span class="comment">// 按照类名查询</span></span><br><span class="line">querySelectorAll <span class="comment">// 按照 css 选择器查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照 id 查询</span></span><br><span class="line"><span class="keyword">var</span> imooc = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;imooc&#x27;</span>) <span class="comment">// 查询到 id 为 imooc 的元素</span></span><br><span class="line"><span class="comment">// 按照标签名查询</span></span><br><span class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>)  <span class="comment">// 查询到标签为 p 的集合</span></span><br><span class="line"><span class="built_in">console</span>.log(divList.length)</span><br><span class="line"><span class="built_in">console</span>.log(divList[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// 按照类名查询</span></span><br><span class="line"><span class="keyword">var</span> moocList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;mooc&#x27;</span>) <span class="comment">// 查询到类名为 mooc 的集合</span></span><br><span class="line"><span class="comment">// 按照 css 选择器查询</span></span><br><span class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.mooc&#x27;</span>) <span class="comment">// 查询到类名为 mooc 的集合</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="2）DOM-节点的创建"><a href="#2）DOM-节点的创建" class="headerlink" title="2）DOM 节点的创建"></a>2）DOM 节点的创建</h4><p><strong>创建一个新节点，并把它添加到指定节点的后面。</strong> 已知的 HTML 结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DEMO<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先获取父节点</span></span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建新节点</span></span><br><span class="line"><span class="keyword">var</span> targetSpan = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line"><span class="comment">// 设置 span 节点的内容</span></span><br><span class="line">targetSpan.innerHTML = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="comment">// 把新创建的元素塞进父节点里去</span></span><br><span class="line">container.appendChild(targetSpan)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="3）DOM-节点的删除"><a href="#3）DOM-节点的删除" class="headerlink" title="3）DOM 节点的删除"></a>3）DOM 节点的删除</h4><p><strong>删除指定的 DOM 节点，</strong> 已知的 HTML 结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DEMO<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>需要删除 id 为 title 的元素，做法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取目标元素的父元素</span></span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取目标元素</span></span><br><span class="line"><span class="keyword">var</span> targetNode = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"><span class="comment">// 删除目标元素</span></span><br><span class="line">container.removeChild(targetNode)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>或者通过子节点数组来完成删除：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取目标元素的父元素var container = document.getElementById(&#x27;container&#x27;)// 获取目标元素var targetNode = container.childNodes[1]// 删除目标元素container.removeChild(targetNode)</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="4）修改-DOM-元素"><a href="#4）修改-DOM-元素" class="headerlink" title="4）修改 DOM 元素"></a>4）修改 DOM 元素</h4><p>修改 DOM 元素这个动作可以分很多维度，比如说移动 DOM 元素的位置，修改 DOM 元素的属性等。</p><p><strong>将指定的两个 DOM 元素交换位置，</strong> 已知的 HTML 结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DEMO<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span>我是内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>现在需要调换 title 和 content 的位置，可以考虑 insertBefore 或者 appendChild：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取父元素</span></span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)   </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取两个需要被交换的元素</span></span><br><span class="line"><span class="keyword">var</span> title = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;content&#x27;</span>)</span><br><span class="line"><span class="comment">// 交换两个元素，把 content 置于 title 前面</span></span><br><span class="line">container.insertBefore(content, title)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="21-use-strict是什么意思-使用它区别是什么？"><a href="#21-use-strict是什么意思-使用它区别是什么？" class="headerlink" title="21. use strict是什么意思 ? 使用它区别是什么？"></a>21. use strict是什么意思 ? 使用它区别是什么？</h3><p>use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：</p><ul><li>消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;</li><li>消除代码运行的不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 Javascript 做好铺垫。</li></ul><p>区别：</p><ul><li>禁止使用 with 语句。</li><li>禁止 this 关键字指向全局对象。</li><li>对象不能有重名的属性。</li></ul><h3 id="22-如何判断一个对象是否属于某个类？"><a href="#22-如何判断一个对象是否属于某个类？" class="headerlink" title="22. 如何判断一个对象是否属于某个类？"></a>22. 如何判断一个对象是否属于某个类？</h3><ul><li>第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</li><li>第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</li><li>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</li></ul><h3 id="23-强类型语言和弱类型语言的区别"><a href="#23-强类型语言和弱类型语言的区别" class="headerlink" title="23. 强类型语言和弱类型语言的区别"></a>23. 强类型语言和弱类型语言的区别</h3><ul><li><strong>强类型语言</strong>：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。</li><li><strong>弱类型语言</strong>：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串’12’和整数3进行连接得到字符串’123’，在相加的时候会进行强制类型转换。</li></ul><p>两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。</p><h3 id="24-解释性语言和编译型语言的区别"><a href="#24-解释性语言和编译型语言的区别" class="headerlink" title="24. 解释性语言和编译型语言的区别"></a>24. 解释性语言和编译型语言的区别</h3><p>（1）解释型语言 使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下</p><ul><li>解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；</li><li>只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；</li><li>JavaScript、Python等属于解释型语言。</li></ul><p>（2）编译型语言 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：</p><ul><li>一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；</li><li>与特定平台相关，一般无法移植到其他平台；</li><li>C、C++等属于编译型语言。</li></ul><p><strong>两者主要区别在于：</strong> 前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。</p><h3 id="25-for…in和for…of的区别"><a href="#25-for…in和for…of的区别" class="headerlink" title="25. for…in和for…of的区别"></a>25. for…in和for…of的区别</h3><p>for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下</p><ul><li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li><li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li><li>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</li></ul><p><strong>总结：</strong> for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p><h3 id="26-如何使用for…of遍历对象"><a href="#26-如何使用for…of遍历对象" class="headerlink" title="26. 如何使用for…of遍历对象"></a>26. 如何使用for…of遍历对象</h3><p>for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。</p><p>如果需要遍历的对象是类数组对象，用Array.from转成数组即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="number">0</span>:<span class="string">&#x27;one&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>:<span class="string">&#x27;two&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">obj = <span class="built_in">Array</span>.from(obj);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>);</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(count&lt;keys.length)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">value</span>: obj[keys[count++]],<span class="attr">done</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">of</span> obj)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">of</span> keys)&#123;</span><br><span class="line">        <span class="keyword">yield</span> [k,obj[k]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> [k,v] <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k,v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="27-ajax、axios、fetch的区别"><a href="#27-ajax、axios、fetch的区别" class="headerlink" title="27. ajax、axios、fetch的区别"></a>27. ajax、axios、fetch的区别</h3><p><strong>（1）AJAX</strong> Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：</p><ul><li>本身是针对MVC编程，不符合前端MVVM的浪潮</li><li>基于原生XHR开发，XHR本身的架构不清晰</li><li>不符合关注分离（Separation of Concerns）的原则</li><li>配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li></ul><p><strong>（2）Fetch</strong> fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。<strong>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象</strong>。</p><p>fetch的优点：</p><ul><li>语法简洁，更加语义化</li><li>基于标准 Promise 实现，支持 async/await</li><li>更加底层，提供的API丰富（request, response）</li><li>脱离了XHR，是ES规范里新的实现方式</li></ul><p>fetch的缺点：</p><ul><li>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li><li>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})</li><li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li><li>fetch没有办法原生监测请求的进度，而XHR可以</li></ul><p><strong>（3）Axios</strong> Axios 是一种基于Promise封装的HTTP客户端，其特点如下：</p><ul><li>浏览器端发起XMLHttpRequests请求</li><li>node端发起http请求</li><li>支持Promise API</li><li>监听请求和返回</li><li>对请求和返回进行转化</li><li>取消请求</li><li>自动转换json数据</li><li>客户端支持抵御XSRF攻击</li></ul><h3 id="28-数组的遍历方法有哪些"><a href="#28-数组的遍历方法有哪些" class="headerlink" title="28. 数组的遍历方法有哪些"></a>28. 数组的遍历方法有哪些</h3><table><thead><tr><th><strong>方法</strong></th><th><strong>是否改变原数组</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>forEach()</td><td>否</td><td>数组方法，不改变原数组，没有返回值</td></tr><tr><td>map()</td><td>否</td><td>数组方法，不改变原数组，有返回值，可链式调用</td></tr><tr><td>filter()</td><td>否</td><td>数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</td></tr><tr><td>for…of</td><td>否</td><td>for…of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环</td></tr><tr><td>every() 和 some()</td><td>否</td><td>数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.</td></tr><tr><td>find() 和 findIndex()</td><td>否</td><td>数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td></tr><tr><td>reduce() 和 reduceRight()</td><td>否</td><td>数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作</td></tr></tbody></table><p>遍历方法的详细解释：<a href="https://link.juejin.cn/?target=https://cuggz.blog.csdn.net/article/details/107649549">《细数JavaScript中那些遍历和循环》</a></p><h3 id="29-forEach和map方法有什么区别"><a href="#29-forEach和map方法有什么区别" class="headerlink" title="29. forEach和map方法有什么区别"></a>29. forEach和map方法有什么区别</h3><p>这方法都是用来遍历数组的，两者区别如下：</p><ul><li>forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</li><li>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</li></ul><h2 id="四、原型与原型链"><a href="#四、原型与原型链" class="headerlink" title="四、原型与原型链"></a>四、原型与原型链</h2><h3 id="1-对原型、原型链的理解"><a href="#1-对原型、原型链的理解" class="headerlink" title="1. 对原型、原型链的理解"></a>1. 对原型、原型链的理解</h3><p>在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。</p><p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。</p><p><strong>特点：</strong> JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c68fcad75ea54d62a9404aa02cafc65c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><h3 id="2-原型修改、重写"><a href="#2-原型修改、重写" class="headerlink" title="2. 原型修改、重写"></a>2. 原型修改、重写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改原型</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 重写原型</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype)        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="comment">// false</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候<code>p.constructor === Object</code> ，而不是<code>p.constructor === Person</code>。要想成立，就要用constructor指回来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">p.constructor = Person</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype)        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="3-原型链指向"><a href="#3-原型链指向" class="headerlink" title="3. 原型链指向"></a>3. 原型链指向</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p.__proto__  <span class="comment">// Person.prototype</span></span><br><span class="line">Person.prototype.__proto__  <span class="comment">// Object.prototype</span></span><br><span class="line">p.__proto__.__proto__ <span class="comment">//Object.prototype</span></span><br><span class="line">p.__proto__.constructor.prototype.__proto__ <span class="comment">// Object.prototype</span></span><br><span class="line">Person.prototype.constructor.prototype.__proto__ <span class="comment">// Object.prototype</span></span><br><span class="line">p1.__proto__.constructor <span class="comment">// Person</span></span><br><span class="line">Person.prototype.constructor  <span class="comment">// Person</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="4-原型链的终点是什么？如何打印出原型链的终点？"><a href="#4-原型链的终点是什么？如何打印出原型链的终点？" class="headerlink" title="4. 原型链的终点是什么？如何打印出原型链的终点？"></a>4. 原型链的终点是什么？如何打印出原型链的终点？</h3><p>由于<code>Object</code>是构造函数，原型链终点是<code>Object.prototype.__proto__</code>，而<code>Object.prototype.__proto__=== null // true</code>，所以，原型链的终点是<code>null</code>。原型链上的所有原型都是对象，所有的对象最终都是由<code>Object</code>构造的，而<code>Object.prototype</code>的下一级是<code>Object.prototype.__proto__</code>。 <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221928408.webp" alt="img"></p><h3 id="5-如何获得对象非原型链上的属性？"><a href="#5-如何获得对象非原型链上的属性？" class="headerlink" title="5. 如何获得对象非原型链上的属性？"></a>5. 如何获得对象非原型链上的属性？</h3><p>使用后<code>hasOwnProperty()</code>方法来判断属性是否属于原型链的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> res=[];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.hasOwnProperty(key))</span><br><span class="line">           res.push(key+<span class="string">&#x27;: &#x27;</span>+obj[key]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="五、执行上下文-作用域链-闭包"><a href="#五、执行上下文-作用域链-闭包" class="headerlink" title="五、执行上下文/作用域链/闭包"></a>五、执行上下文/作用域链/闭包</h2><h3 id="1-对闭包的理解"><a href="#1-对闭包的理解" class="headerlink" title="1. 对闭包的理解"></a>1. 对闭包的理解</h3><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><p>闭包有两个常用的用途；</p><ul><li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li><li>闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li></ul><p>比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="built_in">window</span>.B = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br><span class="line">B() <span class="comment">// 1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。解决办法有三种：</p><ul><li>第一种是使用闭包的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;  ;(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;      <span class="built_in">console</span>.log(j)    &#125;, j * <span class="number">1000</span>)  &#125;)(i)&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在上述代码中，首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的。</p><ul><li>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;,</span><br><span class="line">    i * <span class="number">1000</span>,</span><br><span class="line">    i</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="2-对作用域、作用域链的理解"><a href="#2-对作用域、作用域链的理解" class="headerlink" title="2. 对作用域、作用域链的理解"></a>2. 对作用域、作用域链的理解</h3><h5 id="1）全局作用域和函数作用域"><a href="#1）全局作用域和函数作用域" class="headerlink" title="1）全局作用域和函数作用域"></a>1）全局作用域和函数作用域</h5><p>（1）全局作用域</p><ul><li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li><li>所有未定义直接赋值的变量自动声明为全局作用域</li><li>所有window对象的属性拥有全局作用域</li><li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li></ul><p>（2）函数作用域</p><ul><li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li><li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li></ul><h5 id="2）块级作用域"><a href="#2）块级作用域" class="headerlink" title="2）块级作用域"></a>2）块级作用域</h5><ul><li>使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li><li>let和const声明的变量不会有变量提升，也不可以重复声明</li><li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li></ul><p><strong>作用域链：</strong> 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。</p><p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p><p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p><p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p><h3 id="3-对执行上下文的理解"><a href="#3-对执行上下文的理解" class="headerlink" title="3. 对执行上下文的理解"></a>3. 对执行上下文的理解</h3><h5 id="1-执行上下文类型"><a href="#1-执行上下文类型" class="headerlink" title="1. 执行上下文类型"></a>1. 执行上下文类型</h5><p><strong>（1）全局执行上下文</strong></p><p>任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。</p><p><strong>（2）函数执行上下文</strong></p><p>当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。</p><p><strong>（3）</strong><code>eval</code><strong>函数执行上下文</strong></p><p>执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。</p><h5 id="2-执行上下文栈"><a href="#2-执行上下文栈" class="headerlink" title="2. 执行上下文栈"></a>2. 执行上下文栈</h5><ul><li>JavaScript引擎使用执行上下文栈来管理执行上下文</li><li>当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Inside first function&#x27;</span>);</span><br><span class="line">  second();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Again inside first function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Inside second function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br><span class="line"><span class="comment">//执行顺序</span></span><br><span class="line"><span class="comment">//先执行second(),在执行first()</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h5 id="3-创建执行上下文"><a href="#3-创建执行上下文" class="headerlink" title="3. 创建执行上下文"></a>3. 创建执行上下文</h5><p>创建执行上下文有两个阶段：<strong>创建阶段</strong>和<strong>执行阶段</strong></p><p><strong>1）创建阶段</strong></p><p>（1）this绑定</p><ul><li>在全局执行上下文中，this指向全局对象（window对象）</li><li>在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</li></ul><p>（2）创建词法环境组件</p><ul><li>词法环境是一种有<strong>标识符——变量映射</strong>的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。</li><li>词法环境的内部有两个组件：<strong>加粗样式</strong>：环境记录器:用来储存变量个函数声明的实际位置<strong>外部环境的引用</strong>：可以访问父级作用域</li></ul><p>（3）创建变量环境组件</p><ul><li>变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。</li></ul><p><strong>2）执行阶段</strong> 此阶段会完成对变量的分配，最后执行完代码。</p><p><strong>简单来说执行上下文就是指：</strong></p><p>在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。</p><p>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p><ul><li>全局上下文：变量定义，函数声明</li><li>函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li></ul><p><strong>注：</strong> 由于字数限制，剩余内容在下篇进行总结哦。</p><h2 id="六、this-call-apply-bind"><a href="#六、this-call-apply-bind" class="headerlink" title="六、this/call/apply/bind"></a>六、this/call/apply/bind</h2><h3 id="1-对this对象的理解"><a href="#1-对this对象的理解" class="headerlink" title="1. 对this对象的理解"></a>1. 对this对象的理解</h3><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p><ul><li>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li><li>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li><li>第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li><li>第四种是 <strong>apply 、 call 和 bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li></ul><p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p><h3 id="2-call-和-apply-的区别？"><a href="#2-call-和-apply-的区别？" class="headerlink" title="2. call() 和 apply() 的区别？"></a>2. call() 和 apply() 的区别？</h3><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p><ul><li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li><li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li></ul><h3 id="3-实现call、apply-及-bind-函数"><a href="#3-实现call、apply-及-bind-函数" class="headerlink" title="3. 实现call、apply 及 bind 函数"></a>3. 实现call、apply 及 bind 函数</h3><p><strong>（1）call 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>处理传入的参数，截取第一个参数后的所有参数。</li><li>将函数作为上下文对象的一个属性。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;  <span class="comment">// 判断调用对象  if (typeof this !== &quot;function&quot;) &#123;    console.error(&quot;type error&quot;);  &#125;  // 获取参数  let args = [...arguments].slice(1),    result = null;  // 判断 context 是否传入，如果未传入则设置为 window  context = context || window;  // 将调用函数设为对象的方法  context.fn = this;  // 调用函数  result = context.fn(...args);  // 将属性删除  delete context.fn;  return result;&#125;;复制代码</span></span><br></pre></td></tr></table></figure><p><strong>（2）apply 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>将函数作为上下文对象的一个属性。</li><li>判断参数值是否传入</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性</li><li>返回结果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;  <span class="comment">// 判断调用对象是否为函数  if (typeof this !== &quot;function&quot;) &#123;    throw new TypeError(&quot;Error&quot;);  &#125;  let result = null;  // 判断 context 是否存在，如果未传入则为 window  context = context || window;  // 将函数设为对象的方法  context.fn = this;  // 调用方法  if (arguments[1]) &#123;    result = context.fn(...arguments[1]);  &#125; else &#123;    result = context.fn();  &#125;  // 将属性删除  delete context.fn;  return result;&#125;;复制代码</span></span><br></pre></td></tr></table></figure><p><strong>（3）bind 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回</li><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;  <span class="comment">// 判断调用对象是否为函数  if (typeof this !== &quot;function&quot;) &#123;    throw new TypeError(&quot;Error&quot;);  &#125;  // 获取参数  var args = [...arguments].slice(1),    fn = this;  return function Fn() &#123;    // 根据调用方式，传入不同绑定值    return fn.apply(      this instanceof Fn ? this : context,      args.concat(...arguments)    );  &#125;;&#125;;复制代码</span></span><br></pre></td></tr></table></figure><h2 id="七、异步编程"><a href="#七、异步编程" class="headerlink" title="七、异步编程"></a>七、异步编程</h2><h3 id="1-异步编程的实现方式？"><a href="#1-异步编程的实现方式？" class="headerlink" title="1. 异步编程的实现方式？"></a>1. 异步编程的实现方式？</h3><p>JavaScript中的异步机制可以分为以下几种：</p><ul><li><strong>回调函数</strong> 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</li><li><strong>Promise</strong> 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</li><li><strong>generator</strong> 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</li><li><strong>async 函数</strong> 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li></ul><h3 id="2-setTimeout、Promise、Async-Await-的区别"><a href="#2-setTimeout、Promise、Async-Await-的区别" class="headerlink" title="2. setTimeout、Promise、Async/Await 的区别"></a>2. setTimeout、Promise、Async/Await 的区别</h3><h4 id="（1）setTimeout"><a href="#（1）setTimeout" class="headerlink" title="（1）setTimeout"></a>（1）setTimeout</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)<span class="comment">//1. 打印 script startsetTimeout(function()&#123;    console.log(&#x27;settimeout&#x27;)// 4. 打印 settimeout&#125;)// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数console.log(&#x27;script end&#x27;)//3. 打印 script start// 输出顺序：script start-&gt;script end-&gt;settimeout复制代码</span></span><br></pre></td></tr></table></figure><h4 id="（2）Promise"><a href="#（2）Promise" class="headerlink" title="（2）Promise"></a>（2）Promise</h4><p>Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)<span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)    resolve()    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1 end&#x27;</span>)&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)&#125;)<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;settimeout&#x27;</span>)&#125;)<span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)<span class="comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout复制代码</span></span><br></pre></td></tr></table></figure><p>当JS主线程执行到Promise对象时：</p><ul><li>promise1.then() 的回调就是一个 task</li><li>promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li><li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li><li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li></ul><h4 id="（3）async-await"><a href="#（3）async-await" class="headerlink" title="（3）async/await"></a>（3）async/await</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;   <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);    <span class="keyword">await</span> async2();    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)&#125;<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)&#125;<span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);async1();<span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)<span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end复制代码</span></span><br></pre></td></tr></table></figure><p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> <span class="number">1</span>&#125;<span class="built_in">console</span>.log(func1())复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40194bdc07024b78b6da8bb43d84a7d8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"> func1的运行结果其实就是一个Promise对象。因此也可以使用then来处理后续逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func1().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;    <span class="built_in">console</span>.log(res);  <span class="comment">// 30&#125;)复制代码</span></span><br></pre></td></tr></table></figure><p>await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p><h3 id="3-对Promise的理解"><a href="#3-对Promise的理解" class="headerlink" title="3. 对Promise的理解"></a>3. 对Promise的理解</h3><p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。</p><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>（1）Promise的实例有<strong>三个状态</strong>:</p><ul><li>Pending（进行中）</li><li>Resolved（已完成）</li><li>Rejected（已拒绝）</li></ul><p>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</p><p>（2）Promise的实例有<strong>两个过程</strong>：</p><ul><li>pending -&gt; fulfilled : Resolved（已完成）</li><li>pending -&gt; rejected：Rejected（已拒绝）</li></ul><p>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</p><p><strong>Promise的特点：</strong></p><ul><li>对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“<strong>承诺</strong>”；</li><li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>，从<code>pending</code>变为<code>rejected</code>。这时就称为<code>resolved</code>（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li></ul><p><strong>Promise的缺点：</strong></p><ul><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul><p><strong>总结：</strong> Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。</p><p>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p><p><strong>注意：</strong> 在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p><h3 id="4-Promise的基本用法"><a href="#4-Promise的基本用法" class="headerlink" title="4. Promise的基本用法"></a>4. Promise的基本用法</h3><h4 id="（1）创建Promise对象"><a href="#（1）创建Promise对象" class="headerlink" title="（1）创建Promise对象"></a>（1）创建Promise对象</h4><p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;  <span class="comment">// ... some code  if (/* 异步操作成功 */)&#123;    resolve(value);  &#125; else &#123;    reject(error);  &#125;&#125;);复制代码</span></span><br></pre></td></tr></table></figure><p><strong>一般情况下都会使用</strong><code>new Promise()</code><strong>来创建promise对象，但是也可以使用</strong><code>promise.resolve</code><strong>和</strong><code>promise.reject</code><strong>这两个方法：</strong></p><ul><li><strong>Promise.resolve</strong></li></ul><p><code>Promise.resolve(value)</code>的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">11</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;  <span class="built_in">console</span>.log(value); <span class="comment">// 打印出11&#125;);复制代码</span></span><br></pre></td></tr></table></figure><p><code>resolve(11)</code>代码中，会让promise对象进入确定(<code>resolve</code>状态)，并将参数<code>11</code>传递给后面的<code>then</code>所指定的<code>onFulfilled</code> 函数；</p><p>创建promise对象可以使用<code>new Promise</code>的形式创建对象，也可以使用<code>Promise.resolve(value)</code>的形式创建promise对象；</p><ul><li><strong>Promise.reject</strong></li></ul><p><code>Promise.reject</code> 也是<code>new Promise</code>的快捷形式，也创建一个promise对象。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(“我错了，请原谅俺！！”));复制代码</span><br></pre></td></tr></table></figure><p>就是下面的代码new Promise的简单形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;   reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;我错了！&quot;</span>));&#125;);复制代码</span><br></pre></td></tr></table></figure><p>下面是使用resolve方法和reject方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testPromise</span>(<span class="params">ready</span>) </span>&#123;  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;    <span class="keyword">if</span>(ready) &#123;      resolve(<span class="string">&quot;hello world&quot;</span>);    &#125;<span class="keyword">else</span> &#123;      reject(<span class="string">&quot;No thanks&quot;</span>);    &#125;  &#125;);&#125;;<span class="comment">// 方法调用testPromise(true).then(function(msg)&#123;  console.log(msg);&#125;,function(error)&#123;  console.log(error);&#125;);复制代码</span></span><br></pre></td></tr></table></figure><p>上面的代码的含义是给<code>testPromise</code>方法传递一个参数，返回一个promise对象，如果为<code>true</code>的话，那么调用promise对象中的<code>resolve()</code>方法，并且把其中的参数传递给后面的<code>then</code>第一个函数内，因此打印出 “<code>hello world</code>”, 如果为<code>false</code>的话，会调用promise对象中的<code>reject()</code>方法，则会进入<code>then</code>的第二个函数内，会打印<code>No thanks</code>；</p><h4 id="（2）Promise方法"><a href="#（2）Promise方法" class="headerlink" title="（2）Promise方法"></a>（2）Promise方法</h4><p>Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。</p><ol><li><strong>then()</strong></li></ol><p>当Promise执行的内容符合成功条件时，调用<code>resolve</code>函数，失败就调用<code>reject</code>函数。Promise创建完了，那该如何调用呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(function(value) &#123;  // success&#125;, function(error) &#123;  // failure&#125;);复制代码</span><br></pre></td></tr></table></figure><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为<code>resolved</code>时调用，第二个回调函数是Promise对象的状态变为<code>rejected</code>时调用。其中第二个参数可以省略。 <code>then</code>方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个then方法。</p><p>当要写有顺序的异步事件时，需要串行时，可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;    ajax(<span class="string">&#x27;first&#x27;</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;        resolve(res);    &#125;)&#125;)promise.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle,reject</span>)=&gt;</span>&#123;        ajax(<span class="string">&#x27;second&#x27;</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;            resolve(res)        &#125;)    &#125;)&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle,reject</span>)=&gt;</span>&#123;        ajax(<span class="string">&#x27;second&#x27;</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;            resolve(res)        &#125;)    &#125;)&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;    &#125;)复制代码</span><br></pre></td></tr></table></figure><p>那当要写的事件没有顺序或者关系时，还如何写呢？可以使用<code>all</code> 方法来解决。</p><p><strong>2. catch()</strong></p><p>Promise对象除了有then方法，还有一个catch方法，该方法相当于<code>then</code>方法的第二个参数，指向<code>reject</code>的回调函数。不过<code>catch</code>方法还有一个作用，就是在执行<code>resolve</code>回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入<code>catch</code>方法中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;     <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>,data);&#125;,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;     <span class="built_in">console</span>.log(<span class="string">&#x27;rejected&#x27;</span>,err);     &#125;); p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>,data);&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;rejected&#x27;</span>,err);&#125;);复制代码</span><br></pre></td></tr></table></figure><p><strong>3. all()</strong></p><p><code>all</code>方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个<code>promise</code>对象。当数组中所有的<code>promise</code>的状态都达到<code>resolved</code>的时候，<code>all</code>方法的状态就会变成<code>resolved</code>，如果有一个状态变成了<code>rejected</code>，那么<code>all</code>方法的状态就会变成<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascriptlet promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;       resolve(<span class="number">1</span>);&#125;,<span class="number">2000</span>)&#125;);<span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;       resolve(<span class="number">2</span>);&#125;,<span class="number">1000</span>)&#125;);<span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;       resolve(<span class="number">3</span>);&#125;,<span class="number">3000</span>)&#125;);<span class="built_in">Promise</span>.all([promise1,promise2,promise3]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;    <span class="built_in">console</span>.log(res);    <span class="comment">//结果为：[1,2,3] &#125;)复制代码</span></span><br></pre></td></tr></table></figure><p>调用<code>all</code>方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象<code>resolve</code>执行时的值。</p><p><strong>（4）race()</strong></p><p><code>race</code>方法和<code>all</code>一样，接受的参数是一个每项都是<code>promise</code>的数组，但是与<code>all</code>不同的是，当最先执行完的事件执行完之后，就直接返回该<code>promise</code>对象的值。如果第一个<code>promise</code>对象状态变成<code>resolved</code>，那自身的状态变成了<code>resolved</code>；反之第一个<code>promise</code>变成<code>rejected</code>，那自身状态就会变成<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;       reject(<span class="number">1</span>);&#125;,<span class="number">2000</span>)&#125;);<span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;       resolve(<span class="number">2</span>);&#125;,<span class="number">1000</span>)&#125;);<span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;       resolve(<span class="number">3</span>);&#125;,<span class="number">3000</span>)&#125;);<span class="built_in">Promise</span>.race([promise1,promise2,promise3]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(res);<span class="comment">//结果：2&#125;,rej=&gt;&#123;    console.log(rej)&#125;;)复制代码</span></span><br></pre></td></tr></table></figure><p>那么<code>race</code>方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([promise1,timeOutPromise(<span class="number">5000</span>)]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)复制代码</span><br></pre></td></tr></table></figure><p><strong>5. finally()</strong></p><p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;).finally(<span class="function">() =&gt;</span> &#123;···&#125;);复制代码</span><br></pre></td></tr></table></figure><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.listen(port)  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="comment">// ...  &#125;)  .finally(server.stop);复制代码</span></span><br></pre></td></tr></table></figure><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。<code>finally</code>本质上是<code>then</code>方法的特例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.finally(<span class="function">() =&gt;</span> &#123;  <span class="comment">// 语句&#125;);// 等同于promise.then(  result =&gt; &#123;    // 语句    return result;  &#125;,  error =&gt; &#123;    // 语句    throw error;  &#125;);复制代码</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p><h3 id="5-Promise解决了什么问题"><a href="#5-Promise解决了什么问题" class="headerlink" title="5. Promise解决了什么问题"></a>5. Promise解决了什么问题</h3><p>在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)fs.readFile(<span class="string">&#x27;./a.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;  fs.readFile(data,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;    fs.readFile(data,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;      <span class="built_in">console</span>.log(data)    &#125;)  &#125;)&#125;)复制代码</span><br></pre></td></tr></table></figure><p>上面的代码有如下缺点：</p><ul><li>后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。</li><li>如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。</li></ul><p><code>Promise</code>出现之后，代码变成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)<span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">url</span>)</span>&#123;  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;    fs.readFile(url,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,data</span>)</span>&#123;      error &amp;&amp; reject(error)      resolve(data)    &#125;)  &#125;)&#125;read(<span class="string">&#x27;./a.txt&#x27;</span>).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;  <span class="keyword">return</span> read(data) &#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;  <span class="keyword">return</span> read(data)  &#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;  <span class="built_in">console</span>.log(data)&#125;)复制代码</span><br></pre></td></tr></table></figure><p>这样代码看起了就简洁了很多，解决了地狱回调的问题。</p><h3 id="6-Promise-all和Promise-race的区别的使用场景"><a href="#6-Promise-all和Promise-race的区别的使用场景" class="headerlink" title="6. Promise.all和Promise.race的区别的使用场景"></a>6. Promise.all和Promise.race的区别的使用场景</h3><p><strong>（1）Promise.all</strong> <code>Promise.all</code>可以将多个<code>Promise</code>实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是<strong>一个结果数组</strong>，而失败的时候则返回<strong>最先被reject失败状态的值</strong>。</p><p>Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。</p><p>需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。</p><p><strong>（2）Promise.race</strong></p><p>顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([promise1,timeOutPromise(<span class="number">5000</span>)]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)复制代码</span><br></pre></td></tr></table></figure><h3 id="7-对async-await-的理解"><a href="#7-对async-await-的理解" class="headerlink" title="7.  对async/await 的理解"></a>7.  对async/await 的理解</h3><p>async/await其实是<code>Generator</code> 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsy</span>(<span class="params"></span>)</span>&#123;   <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;&#125;<span class="keyword">let</span> result = testAsy(); <span class="built_in">console</span>.log(result)复制代码</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221934780.webp" alt="img"></p><p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p><p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsy</span>(<span class="params"></span>)</span>&#123;   <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>&#125;<span class="keyword">let</span> result = testAsy() <span class="built_in">console</span>.log(result)result.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;    <span class="built_in">console</span>.log(v)   <span class="comment">// hello world&#125;)复制代码</span></span><br></pre></td></tr></table></figure><p>那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p><p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p><p><strong>注意：</strong><code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p><h3 id="8-await-到底在等啥？"><a href="#8-await-到底在等啥？" class="headerlink" title="8. await 到底在等啥？"></a>8. await 到底在等啥？</h3><p><strong>await 在等待什么呢？</strong> 一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p><p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomething</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> <span class="string">&quot;something&quot;</span>;&#125;<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;hello async&quot;</span>);&#125;<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">const</span> v1 = <span class="keyword">await</span> getSomething();    <span class="keyword">const</span> v2 = <span class="keyword">await</span> testAsync();    <span class="built_in">console</span>.log(v1, v2);&#125;test();复制代码</span><br></pre></td></tr></table></figure><p>await 表达式的运算结果取决于它等的是什么。</p><ul><li>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li><li>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li></ul><p>来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAsy</span>(<span class="params">x</span>)</span>&#123;   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;       resolve(x);     &#125;, <span class="number">3000</span>)    &#125;   )&#125;<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAwt</span>(<span class="params"></span>)</span>&#123;      <span class="keyword">let</span> result =  <span class="keyword">await</span> testAsy(<span class="string">&#x27;hello world&#x27;</span>);  <span class="built_in">console</span>.log(result);    <span class="comment">// 3秒钟之后出现hello world  console.log(&#x27;cuger&#x27;)   // 3秒钟之后出现cug&#125;testAwt();console.log(&#x27;cug&#x27;)  //立即输出cug复制代码</span></span><br></pre></td></tr></table></figure><p>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以’cug’’最先输出，hello world’和‘cuger’是3秒钟后同时出现的。</p><h3 id="9-async-await的优势"><a href="#9-async-await的优势" class="headerlink" title="9.  async/await的优势"></a>9.  async/await的优势</h3><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。</p><p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 <code>setTimeout</code> 来模拟异步操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 传入参数 n，表示这个函数执行的时间（毫秒） * 执行的结果是 n + 200，这个值将用于下一步骤 */</span><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(n + <span class="number">200</span>), n);    &#125;);&#125;<span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);    <span class="keyword">return</span> takeLongTime(n);&#125;<span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">n</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);    <span class="keyword">return</span> takeLongTime(n);&#125;<span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">n</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);    <span class="keyword">return</span> takeLongTime(n);&#125;复制代码</span><br></pre></td></tr></table></figure><p>现在用 Promise 方式来实现这三个步骤的处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.time(<span class="string">&quot;doIt&quot;</span>);    <span class="keyword">const</span> time1 = <span class="number">300</span>;    step1(time1)        .then(<span class="function"><span class="params">time2</span> =&gt;</span> step2(time2))        .then(<span class="function"><span class="params">time3</span> =&gt;</span> step3(time3))        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;            <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);            <span class="built_in">console</span>.timeEnd(<span class="string">&quot;doIt&quot;</span>);        &#125;);&#125;doIt();<span class="comment">// c:\var\test&gt;node --harmony_async_await .// step1 with 300// step2 with 500// step3 with 700// result is 900// doIt: 1507.251ms复制代码</span></span><br></pre></td></tr></table></figure><p>输出结果 <code>result</code> 是 <code>step3()</code> 的参数 <code>700 + 200</code> = <code>900</code>。<code>doIt()</code> 顺序执行了三个步骤，一共用了 <code>300 + 500 + 700 = 1500</code> 毫秒，和 <code>console.time()/console.timeEnd()</code> 计算的结果一致。</p><p>如果用 async/await 来实现呢，会是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.time(<span class="string">&quot;doIt&quot;</span>);    <span class="keyword">const</span> time1 = <span class="number">300</span>;    <span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1);    <span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time2);    <span class="keyword">const</span> result = <span class="keyword">await</span> step3(time3);    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);    <span class="built_in">console</span>.timeEnd(<span class="string">&quot;doIt&quot;</span>);&#125;doIt();复制代码</span><br></pre></td></tr></table></figure><p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p><h3 id="10-async-await对比Promise的优势"><a href="#10-async-await对比Promise的优势" class="headerlink" title="10. async/await对比Promise的优势"></a>10. async/await对比Promise的优势</h3><ul><li>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担</li><li>Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅</li><li>错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余</li><li>调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。</li></ul><h3 id="11-async-await-如何捕获异常"><a href="#11-async-await-如何捕获异常" class="headerlink" title="11. async/await 如何捕获异常"></a>11. async/await 如何捕获异常</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;    <span class="keyword">try</span>&#123;        <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;error&#x27;</span>)    &#125;<span class="keyword">catch</span>(error)&#123;        <span class="built_in">console</span>.log(error)    &#125;&#125;复制代码</span><br></pre></td></tr></table></figure><h3 id="12-并发与并行的区别？"><a href="#12-并发与并行的区别？" class="headerlink" title="12. 并发与并行的区别？"></a>12. 并发与并行的区别？</h3><ul><li>并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。</li><li>并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</li></ul><h3 id="13-什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？"><a href="#13-什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？" class="headerlink" title="13. 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？"></a>13. 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？</h3><p>以下代码就是一个回调函数的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, <span class="function">() =&gt;</span> &#123;    <span class="comment">// 处理逻辑&#125;)复制代码</span></span><br></pre></td></tr></table></figure><p>回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，可能会有如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, <span class="function">() =&gt;</span> &#123;    <span class="comment">// 处理逻辑    ajax(url1, () =&gt; &#123;        // 处理逻辑        ajax(url2, () =&gt; &#123;            // 处理逻辑        &#125;)    &#125;)&#125;)复制代码</span></span><br></pre></td></tr></table></figure><p>以上代码看起来不利于阅读和维护，当然，也可以把函数分开来写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstAjax</span>(<span class="params"></span>) </span>&#123;  ajax(url1, <span class="function">() =&gt;</span> &#123;    <span class="comment">// 处理逻辑    secondAjax()  &#125;)&#125;function secondAjax() &#123;  ajax(url2, () =&gt; &#123;    // 处理逻辑  &#125;)&#125;ajax(url, () =&gt; &#123;  // 处理逻辑  firstAjax()&#125;)复制代码</span></span><br></pre></td></tr></table></figure><p>以上的代码虽然看上去利于阅读了，但是还是没有解决根本问题。回调地狱的根本问题就是：</p><ol><li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li><li>嵌套函数一多，就很难处理错误</li></ol><p>当然，回调函数还存在着别的几个缺点，比如不能使用 <code>try catch</code> 捕获错误，不能直接 <code>return</code>。</p><h3 id="14-setTimeout、setInterval、requestAnimationFrame-各有什么特点？"><a href="#14-setTimeout、setInterval、requestAnimationFrame-各有什么特点？" class="headerlink" title="14. setTimeout、setInterval、requestAnimationFrame 各有什么特点？"></a>14. setTimeout、setInterval、requestAnimationFrame 各有什么特点？</h3><p>异步编程当然少不了定时器了，常见的定时器函数有 <code>setTimeout</code>、<code>setInterval</code>、<code>requestAnimationFrame</code>。最常用的是<code>setTimeout</code>，很多人认为 <code>setTimeout</code> 是延时多久，那就应该是多久后执行。</p><p>其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 <code>setTimeout</code> 不会按期执行。当然了，可以通过代码去修正 <code>setTimeout</code>，从而使定时器相对准确：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> period = <span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span> * 2<span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()<span class="keyword">let</span> count = 0<span class="keyword">let</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + periodlet interval = 1000<span class="keyword">let</span> currentInterval = intervalfunction <span class="function"><span class="title">loop</span>(<span class="params"></span>)</span> &#123;  count++  <span class="comment">// 代码执行所消耗的时间  let offset = new Date().getTime() - (startTime + count * interval);  let diff = end - new Date().getTime()  let h = Math.floor(diff / (60 * 1000 * 60))  let hdiff = diff % (60 * 1000 * 60)  let m = Math.floor(hdiff / (60 * 1000))  let mdiff = hdiff % (60 * 1000)  let s = mdiff / (1000)  let sCeil = Math.ceil(s)  let sFloor = Math.floor(s)  // 得到下一次循环所消耗的时间  currentInterval = interval - offset   console.log(&#x27;时：&#x27;+h, &#x27;分：&#x27;+m, &#x27;毫秒：&#x27;+s, &#x27;秒向上取整：&#x27;+sCeil, &#x27;代码执行时间：&#x27;+offset, &#x27;下次循环间隔&#x27;+currentInterval)   setTimeout(loop, currentInterval)&#125;setTimeout(loop, currentInterval)复制代码</span></span><br></pre></td></tr></table></figure><p>接下来看 <code>setInterval</code>，其实这个函数作用和 <code>setTimeout</code> 基本一致，只是该函数是每隔一段时间执行一次回调函数。</p><p>通常来说不建议使用 <code>setInterval</code>。第一，它和 <code>setTimeout</code> 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="number">2</span>)  &#125;,<span class="number">1000</span>)  sleep(<span class="number">2000</span>)&#125;demo()复制代码</span><br></pre></td></tr></table></figure><p>以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。</p><p>如果有循环定时器的需求，其实完全可以通过 <code>requestAnimationFrame</code> 来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInterval</span>(<span class="params">callback, interval</span>) </span>&#123;  <span class="keyword">let</span> timer  <span class="keyword">const</span> now = <span class="built_in">Date</span>.now  <span class="keyword">let</span> startTime = now()  <span class="keyword">let</span> endTime = startTime  <span class="keyword">const</span> loop = <span class="function">() =&gt;</span> &#123;    timer = <span class="built_in">window</span>.requestAnimationFrame(loop)    endTime = now()    <span class="keyword">if</span> (endTime - startTime &gt;= interval) &#123;      startTime = endTime = now()      callback(timer)    &#125;  &#125;  timer = <span class="built_in">window</span>.requestAnimationFrame(loop)  <span class="keyword">return</span> timer&#125;<span class="keyword">let</span> a = 0<span class="built_in">setInterval</span>(<span class="function"><span class="params">timer</span> =&gt;</span> &#123;  <span class="built_in">console</span>.log(<span class="number">1</span>)  a++  <span class="keyword">if</span> (a === <span class="number">3</span>) cancelAnimationFrame(timer)&#125;, <span class="number">1000</span>)复制代码</span><br></pre></td></tr></table></figure><p>首先 <code>requestAnimationFrame</code> 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 <code>setTimeout</code>。</p><h2 id="八、面向对象"><a href="#八、面向对象" class="headerlink" title="八、面向对象"></a>八、面向对象</h2><h3 id="1-对象创建的方式有哪些？"><a href="#1-对象创建的方式有哪些？" class="headerlink" title="1. 对象创建的方式有哪些？"></a>1. 对象创建的方式有哪些？</h3><p>一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：</p><p>（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</p><p>（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</p><p>（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</p><p>（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</p><p>（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</p><p>（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</p><h3 id="2-对象继承的方式有哪些？"><a href="#2-对象继承的方式有哪些？" class="headerlink" title="2. 对象继承的方式有哪些？"></a>2. 对象继承的方式有哪些？</h3><p>（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p><p>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p><p>（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p><p>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p><p>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。</p><p>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p><h2 id="九、垃圾回收与内存泄漏"><a href="#九、垃圾回收与内存泄漏" class="headerlink" title="九、垃圾回收与内存泄漏"></a>九、垃圾回收与内存泄漏</h2><h3 id="1-浏览器的垃圾回收机制"><a href="#1-浏览器的垃圾回收机制" class="headerlink" title="1. 浏览器的垃圾回收机制"></a>1. 浏览器的垃圾回收机制</h3><h4 id="（1）垃圾回收的概念"><a href="#（1）垃圾回收的概念" class="headerlink" title="（1）垃圾回收的概念"></a>（1）垃圾回收的概念</h4><p><strong>垃圾回收</strong>：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。</p><p><strong>回收机制</strong>：</p><ul><li>Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li><li>JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。</li><li>不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</li></ul><h4 id="（2）垃圾回收的方式"><a href="#（2）垃圾回收的方式" class="headerlink" title="（2）垃圾回收的方式"></a>（2）垃圾回收的方式</h4><p>浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。 <strong>1）标记清除</strong></p><ul><li>标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</li></ul><p><strong>2）引用计数</strong></p><ul><li>另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。</li><li>这种方法会引起<strong>循环引用</strong>的问题：例如：<code> obj1</code>和<code>obj2</code>通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，<code>obj1</code>和<code>obj2</code>还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line">    obj1.a = obj2; <span class="comment">// obj1 引用 obj2</span></span><br><span class="line">    obj2.a = obj1; <span class="comment">// obj2 引用 obj1</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这种情况下，就要手动释放变量占用的内存：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj1.a =  <span class="literal">null</span></span><br><span class="line"> obj2.a =  <span class="literal">null</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（3）减少垃圾回收"><a href="#（3）减少垃圾回收" class="headerlink" title="（3）减少垃圾回收"></a>（3）减少垃圾回收</h4><p>虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。</p><ul><li><strong>对数组进行优化：</strong> 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。</li><li><strong>对</strong><code>object</code><strong>进行优化：</strong> 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。</li><li><strong>对函数进行优化：</strong> 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</li></ul><h3 id="2-哪些情况会导致内存泄漏"><a href="#2-哪些情况会导致内存泄漏" class="headerlink" title="2. 哪些情况会导致内存泄漏"></a>2. 哪些情况会导致内存泄漏</h3><p>以下四种情况会造成内存的泄漏：</p><ul><li><strong>意外的全局变量：</strong> 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><li><strong>被遗忘的计时器或回调函数：</strong> 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li><strong>脱离 DOM 的引用：</strong> 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li><li><strong>闭包：</strong> 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript面试题整理</title>
      <link href="/2022/03/22/javaScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2022/03/22/javaScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="1-JavaScript有哪些数据类型，它们的区别？"><a href="#1-JavaScript有哪些数据类型，它们的区别？" class="headerlink" title="1. JavaScript有哪些数据类型，它们的区别？"></a>1. JavaScript有哪些数据类型，它们的区别？</h3><p>JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。</p><p>其中 Symbol 和 BigInt 是ES6 中新增的数据类型：</p><ul><li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li><li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li></ul><p>这些数据可以分为原始数据类型和引用数据类型：</p><ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li></ul><p>两种类型的区别在于<strong>存储位置的不同：</strong></p><ul><li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li><li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p><ul><li>在数据结构中，栈中数据的存取方式为先进后出。</li><li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li></ul><p>在操作系统中，内存被分为栈区和堆区：</p><ul><li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li><li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li></ul><h3 id="2-数据类型检测的方式有哪些"><a href="#2-数据类型检测的方式有哪些" class="headerlink" title="2. 数据类型检测的方式有哪些"></a>2. 数据类型检测的方式有哪些</h3><p><strong>（1）typeof</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;str&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object    </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其中数组、对象、null都会被判断为object，其他判断都正确。</p><p><strong>（2）instanceof</strong></p><p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false </span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p><p><strong>（3） constructor</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span>).constructor === <span class="built_in">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).constructor === <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="string">&#x27;str&#x27;</span>).constructor === <span class="built_in">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(([]).constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> </span><br><span class="line">Fn.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fn();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===Fn);    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor===<span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>（4）Object.prototype.toString.call()</strong></p><p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">true</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="string">&#x27;str&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call([]));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(&#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">undefined</span>));</span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">null</span>));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p><p>这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p><h3 id="3-判断数组的方式有哪些"><a href="#3-判断数组的方式有哪些" class="headerlink" title="3. 判断数组的方式有哪些"></a>3. 判断数组的方式有哪些</h3><ul><li>通过Object.prototype.toString.call()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>,-<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>通过原型链做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.__proto__ === <span class="built_in">Array</span>.prototype;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>通过ES6的Array.isArray()做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArrray(obj);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>通过instanceof做判断</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Array</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>通过Array.prototype.isPrototypeOf</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf(obj)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="4-null和undefined区别"><a href="#4-null和undefined区别" class="headerlink" title="4. null和undefined区别"></a>4. null和undefined区别</h3><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p><p>undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p><p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p><p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p><h3 id="5-typeof-null-的结果是什么，为什么？"><a href="#5-typeof-null-的结果是什么，为什么？" class="headerlink" title="5. typeof null 的结果是什么，为什么？"></a>5. typeof null 的结果是什么，为什么？</h3><p>typeof null 的结果是Object。</p><p>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000</span>: object   - 当前存储的数据指向一个对象。</span><br><span class="line">  <span class="number">1</span>: int      - 当前存储的数据是一个 <span class="number">31</span> 位的有符号整数。</span><br><span class="line"><span class="number">010</span>: double   - 当前存储的数据指向一个双精度的浮点数。</span><br><span class="line"><span class="number">100</span>: string   - 当前存储的数据指向一个字符串。</span><br><span class="line"><span class="number">110</span>: boolean  - 当前存储的数据是布尔值。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。</p><p>有两种特殊数据类型：</p><ul><li>undefined的值是 (-2)30(一个超出整数范围的数字)；</li><li>null 的值是机器码 NULL 指针(null 指针的值全是 0)</li></ul><p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p><h3 id="6-intanceof-操作符的实现原理及实现"><a href="#6-intanceof-操作符的实现原理及实现" class="headerlink" title="6. intanceof 操作符的实现原理及实现"></a>6. intanceof 操作符的实现原理及实现</h3><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取对象的原型</span></span><br><span class="line">  <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(left)</span><br><span class="line">  <span class="comment">// 获取构造函数的 prototype 对象</span></span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span></span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeOf(proto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="7-为什么0-1-0-2-0-3，如何让其相等"><a href="#7-为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="7. 为什么0.1+0.2 ! == 0.3，如何让其相等"></a>7. 为什么0.1+0.2 ! == 0.3，如何让其相等</h3><p>在开发过程中遇到类似这样的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n1 = <span class="number">0.1</span>, n2 = <span class="number">0.2</span></span><br><span class="line"><span class="built_in">console</span>.log(n1 + n2)  <span class="comment">// 0.30000000000000004</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(n1 + n2).toFixed(<span class="number">2</span>) <span class="comment">// 注意，toFixed为四舍五入</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？</p><p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p><p>一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p><p>根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。</p><p>下面看一下<strong>双精度数是如何保存</strong>的： <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221928223.webp" alt="img"></p><ul><li>第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位</li><li>第二部分（绿色）：用来存储指数（exponent），占用11位</li><li>第三部分（红色）：用来存储小数（fraction），占用52位</li></ul><p>对于0.1，它的二进制为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011001</span> <span class="number">10011.</span>..</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>转为科学计数法（科学计数法的结果就是浮点数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1001100110011001100110011001100110011001100110011001</span>*<span class="number">2</span>^-<span class="number">4</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看出0.1的符号位为0，指数位为-4，小数位为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1001100110011001100110011001100110011001100110011001</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？</p><p>IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。</p><ul><li>当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023= -1022，e最大值是2046，则2046-1023=1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。</li><li>当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023= -1022。</li><li>当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s=0时表示正无穷，s=1时候表示负无穷。</li></ul><p>对于上面的0.1的指数位为-4，-4+1023 = 1019 转化为二进制就是：<code>1111111011</code>.</p><p>所以，0.1表示为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1111111011</span> <span class="number">1001100110011001100110011001100110011001100110011001</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>说了这么多，是时候该最开始的问题了，如何实现0.1+0.2=0.3呢？</p><p>对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 ===0.3</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numberepsilon</span>(<span class="params">arg1,arg2</span>)</span>&#123;                   </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(arg1 - arg2) &lt; <span class="built_in">Number</span>.EPSILON;        </span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numberepsilon(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)); <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="8-如何获取安全的-undefined-值？"><a href="#8-如何获取安全的-undefined-值？" class="headerlink" title="8. 如何获取安全的 undefined 值？"></a>8. 如何获取安全的 undefined 值？</h3><p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。</p><h3 id="9-typeof-NaN-的结果是什么？"><a href="#9-typeof-NaN-的结果是什么？" class="headerlink" title="9. typeof NaN 的结果是什么？"></a>9. typeof NaN 的结果是什么？</h3><p>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// &quot;number&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。</p><h3 id="10-isNaN-和-Number-isNaN-函数的区别？"><a href="#10-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="10. isNaN 和 Number.isNaN 函数的区别？"></a>10. isNaN 和 Number.isNaN 函数的区别？</h3><ul><li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li><li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</li></ul><h3 id="11-操作符的强制类型转换规则？"><a href="#11-操作符的强制类型转换规则？" class="headerlink" title="11. == 操作符的强制类型转换规则？"></a>11. == 操作符的强制类型转换规则？</h3><p>对于 <code>==</code> 来说，如果对比双方的类型<strong>不一样</strong>，就会进行<strong>类型转换</strong>。假如对比 <code>x</code> 和 <code>y</code> 是否相同，就会进行如下判断流程：</p><ol><li>首先会判断两者类型是否<strong>相同，</strong>相同的话就比较两者的大小；</li><li>类型不相同的话，就会进行类型转换；</li><li>会先判断是否在对比 <code>null</code> 和 <code>undefined</code>，是的话就会返回 <code>true</code></li><li>判断两者类型是否为 <code>string</code> 和 <code>number</code>，是的话就会将字符串转换为 <code>number</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> == <span class="string">&#x27;1&#x27;</span></span><br><span class="line">      ↓</span><br><span class="line"><span class="number">1</span> ==  <span class="number">1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li>判断其中一方是否为 <code>boolean</code>，是的话就会把 <code>boolean</code> 转为 <code>number</code> 再进行判断</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span> == <span class="literal">true</span></span><br><span class="line">        ↓</span><br><span class="line"><span class="string">&#x27;1&#x27;</span> ==  <span class="number">1</span></span><br><span class="line">        ↓</span><br><span class="line"> <span class="number">1</span>  ==  <span class="number">1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li>判断其中一方是否为 <code>object</code> 且另一方为 <code>string</code>、<code>number</code> 或者 <code>symbol</code>，是的话就会把 <code>object</code> 转为原始类型再进行判断</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span> == &#123; <span class="attr">name</span>: <span class="string">&#x27;js&#x27;</span> &#125;        ↓<span class="string">&#x27;1&#x27;</span> == <span class="string">&#x27;[object Object]&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其流程图如下： <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221929529.webp" alt="img"></p><h3 id="12-其他值到字符串的转换规则？"><a href="#12-其他值到字符串的转换规则？" class="headerlink" title="12. 其他值到字符串的转换规则？"></a>12. 其他值到字符串的转换规则？</h3><ul><li>Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，</li><li>Boolean 类型，true 转换为 “true”，false 转换为 “false”。</li><li>Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</li><li>Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</li><li>对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。</li></ul><h3 id="13-其他值到数字值的转换规则？"><a href="#13-其他值到数字值的转换规则？" class="headerlink" title="13. 其他值到数字值的转换规则？"></a>13. 其他值到数字值的转换规则？</h3><ul><li>Undefined 类型的值转换为 NaN。</li><li>Null 类型的值转换为 0。</li><li>Boolean 类型的值，true 转换为 1，false 转换为 0。</li><li>String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</li><li>Symbol 类型的值不能转换为数字，会报错。</li><li>对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</li></ul><p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。</p><p>如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</p><h3 id="14-其他值到布尔类型的值的转换规则？"><a href="#14-其他值到布尔类型的值的转换规则？" class="headerlink" title="14. 其他值到布尔类型的值的转换规则？"></a>14. 其他值到布尔类型的值的转换规则？</h3><p>以下这些是假值： • undefined • null • false • +0、-0 和 NaN • “”</p><p>假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</p><h3 id="15-和-amp-amp-操作符的返回值？"><a href="#15-和-amp-amp-操作符的返回值？" class="headerlink" title="15. || 和 &amp;&amp; 操作符的返回值？"></a>15. || 和 &amp;&amp; 操作符的返回值？</h3><p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。</p><ul><li>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</li><li>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</li></ul><p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</p><h3 id="16-Object-is-与比较操作符-“-”、“-”-的区别？"><a href="#16-Object-is-与比较操作符-“-”、“-”-的区别？" class="headerlink" title="16. Object.is() 与比较操作符 “===”、“==” 的区别？"></a>16. Object.is() 与比较操作符 “===”、“==” 的区别？</h3><ul><li>使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</li><li>使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</li><li>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</li></ul><h3 id="17-什么是-JavaScript-中的包装类型？"><a href="#17-什么是-JavaScript-中的包装类型？" class="headerlink" title="17. 什么是 JavaScript 中的包装类型？"></a>17. 什么是 JavaScript 中的包装类型？</h3><p>在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">a.length; <span class="comment">// 3</span></span><br><span class="line">a.toUpperCase(); <span class="comment">// &quot;ABC&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在访问<code>&#39;abc&#39;.length</code>时，JavaScript 将<code>&#39;abc&#39;</code>在后台转换成<code>String(&#39;abc&#39;)</code>，然后再访问其<code>length</code>属性。</p><p>JavaScript也可以使用<code>Object</code>函数显式地将基本类型转换为包装类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>(a) <span class="comment">// String &#123;&quot;abc&quot;&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>也可以使用<code>valueOf</code>方法将包装类型倒转成基本类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>(a)</span><br><span class="line"><span class="keyword">var</span> c = b.valueOf() <span class="comment">// &#x27;abc&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>看看如下代码会打印出什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Boolean</span>( <span class="literal">false</span> );</span><br><span class="line"><span class="keyword">if</span> (!a) &#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;Oops&quot;</span> ); <span class="comment">// never runs</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>答案是什么都不会打印，因为虽然包裹的基本类型是<code>false</code>，但是<code>false</code>被包裹成包装类型后就成了对象，所以其非值为<code>false</code>，所以循环体中的内容不会运行。</p><h3 id="18-JavaScript-中如何进行隐式类型转换？"><a href="#18-JavaScript-中如何进行隐式类型转换？" class="headerlink" title="18. JavaScript 中如何进行隐式类型转换？"></a>18. JavaScript 中如何进行隐式类型转换？</h3><p>首先要介绍<code>ToPrimitive</code>方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@obj </span>需要转换的对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@type </span>期望的结果类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ToPrimitive(obj,type)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>type</code>的值为<code>number</code>或者<code>string</code>。</p><p><strong>（1）当</strong><code>type</code><strong>为</strong><code>number</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>valueOf</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>toString</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p><strong>（2）当</strong><code>type</code><strong>为</strong><code>string</code><strong>时规则如下：</strong></p><ul><li>调用<code>obj</code>的<code>toString</code>方法，如果为原始值，则返回，否则下一步；</li><li>调用<code>obj</code>的<code>valueOf</code>方法，后续同上；</li><li>抛出<code>TypeError</code> 异常。</li></ul><p>可以看出两者的主要区别在于调用<code>toString</code>和<code>valueOf</code>的先后顺序。默认情况下：</p><ul><li>如果对象为 Date 对象，则<code>type</code>默认为<code>string</code>；</li><li>其他情况下，<code>type</code>默认为<code>number</code>。</li></ul><p>总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objToNumber = <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">Number</span>(value.valueOf().toString())</span><br><span class="line">objToNumber([]) === <span class="number">0</span></span><br><span class="line">objToNumber(&#123;&#125;) === <span class="literal">NaN</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>而 JavaScript 中的隐式类型转换主要发生在<code>+、-、*、/</code>以及<code>==、&gt;、&lt;</code>这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用<code>ToPrimitive</code>转换成基本类型，再进行操作。</p><p>以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被<code>ToPrimitive</code>转换成基本类型，所以最终还是要应用基本类型转换规则）：</p><ol><li><code>+</code><strong>操作符</strong></li></ol><p><code>+</code>操作符的两边有至少一个<code>string</code>类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;23&#x27;</span> <span class="comment">// &#x27;123&#x27;</span></span><br><span class="line"> <span class="number">1</span> + <span class="literal">false</span> <span class="comment">// 1 </span></span><br><span class="line"> <span class="number">1</span> + <span class="built_in">Symbol</span>() <span class="comment">// Uncaught TypeError: Cannot convert a Symbol value to a number</span></span><br><span class="line"> <span class="string">&#x27;1&#x27;</span> + <span class="literal">false</span> <span class="comment">// &#x27;1false&#x27;</span></span><br><span class="line"> <span class="literal">false</span> + <span class="literal">true</span> <span class="comment">// 1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li><code>-</code>、<code>*</code>、<code>\</code><strong>操作符</strong></li></ol><p><code>NaN</code>也是一个数字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> * <span class="string">&#x27;23&#x27;</span> <span class="comment">// 23</span></span><br><span class="line"> <span class="number">1</span> * <span class="literal">false</span> <span class="comment">// 0</span></span><br><span class="line"> <span class="number">1</span> / <span class="string">&#x27;aa&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li><strong>对于</strong><code>==</code><strong>操作符</strong></li></ol><p>操作符两边的值都尽量转成<code>number</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> == <span class="literal">true</span> <span class="comment">// false, 3 转为number为3，true转为number为1</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="literal">false</span> <span class="comment">//true, &#x27;0&#x27;转为number为0，false转为number为0</span></span><br><span class="line"><span class="string">&#x27;0&#x27;</span> == <span class="number">0</span> <span class="comment">// &#x27;0&#x27;转为number为0</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ol><li><strong>对于</strong><code>&lt;</code><strong>和</strong><code>&gt;</code><strong>比较符</strong></li></ol><p>如果两边都是字符串，则比较字母表顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;ca&#x27;</span> &lt; <span class="string">&#x27;bd&#x27;</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;a&#x27;</span> &lt; <span class="string">&#x27;b&#x27;</span> <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其他情况下，转换为数字再比较：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;12&#x27;</span> &lt; <span class="number">13</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> &gt; -<span class="number">1</span> <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上说的是基本类型的隐式转换，而对象会被<code>ToPrimitive</code>转换为基本类型再进行转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line">a &gt; <span class="number">2</span> <span class="comment">// false</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其对比过程如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a.valueOf() <span class="comment">// &#123;&#125;, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span></span><br><span class="line">a.toString() <span class="comment">// &quot;[object Object]&quot;，现在是一个字符串了</span></span><br><span class="line"><span class="built_in">Number</span>(a.toString()) <span class="comment">// NaN，根据上面 &lt; 和 &gt; 操作符的规则，要转换成数字</span></span><br><span class="line"><span class="literal">NaN</span> &gt; <span class="number">2</span> <span class="comment">//false，得出比较结果</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>又比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">name</span>:<span class="string">&#x27;Jack&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line">a + b <span class="comment">// &quot;[object Object][object Object]&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>运算过程如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a.valueOf() <span class="comment">// &#123;&#125;，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span></span><br><span class="line">a.toString() <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line">b.valueOf() <span class="comment">// 同理</span></span><br><span class="line">b.toString() <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line">a + b <span class="comment">// &quot;[object Object][object Object]&quot;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="19-操作符什么时候用于字符串的拼接？"><a href="#19-操作符什么时候用于字符串的拼接？" class="headerlink" title="19. + 操作符什么时候用于字符串的拼接？"></a>19. <code>+</code> 操作符什么时候用于字符串的拼接？</h3><p>根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p><p>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。</p><p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p><h3 id="20-为什么会有BigInt的提案？"><a href="#20-为什么会有BigInt的提案？" class="headerlink" title="20. 为什么会有BigInt的提案？"></a>20. 为什么会有<strong>BigInt</strong>的提案？</h3><p>JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。</p><h3 id="21-object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别"><a href="#21-object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别" class="headerlink" title="21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别"></a>21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别</h3><p>扩展运算符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outObj = &#123;</span><br><span class="line">  <span class="attr">inObj</span>: &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = &#123;...outObj&#125;</span><br><span class="line">newObj.inObj.a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(outObj) <span class="comment">// &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Object.assign():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outObj = &#123;</span><br><span class="line">  <span class="attr">inObj</span>: &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">Object</span>.assign(&#123;&#125;, outObj)</span><br><span class="line">newObj.inObj.a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(outObj) <span class="comment">// &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看到，两者都是浅拷贝。</p><ul><li>Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</li><li>扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。</li></ul><h2 id="二、ES6"><a href="#二、ES6" class="headerlink" title="二、ES6"></a>二、ES6</h2><h3 id="1-let、const、var的区别"><a href="#1-let、const、var的区别" class="headerlink" title="1. let、const、var的区别"></a>1. let、const、var的区别</h3><p><strong>（1）块级作用域：</strong> 块作用域由 <code>&#123; &#125;</code>包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</p><ul><li>内层变量可能覆盖外层变量</li><li>用来计数的循环变量泄露为全局变量</li></ul><p><strong>（2）变量提升：</strong> var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p><p><strong>（3）给全局添加属性：</strong> 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。</p><p><strong>（4）重复声明：</strong> var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</p><p><strong>（5）暂时性死区：</strong> 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为<strong>暂时性死区</strong>。使用var声明的变量不存在暂时性死区。</p><p><strong>（6）初始值设置：</strong> 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</p><p><strong>（7）指针指向：</strong> let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p><table><thead><tr><th><strong>区别</strong></th><th><strong>var</strong></th><th><strong>let</strong></th><th><strong>const</strong></th></tr></thead><tbody><tr><td>是否有块级作用域</td><td>×</td><td>✔️</td><td>✔️</td></tr><tr><td>是否存在变量提升</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>是否添加全局属性</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>能否重复声明变量</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>是否存在暂时性死区</td><td>×</td><td>✔️</td><td>✔️</td></tr><tr><td>是否必须设置初始值</td><td>×</td><td>×</td><td>✔️</td></tr><tr><td>能否改变指针指向</td><td>✔️</td><td>✔️</td><td>×</td></tr></tbody></table><h3 id="2-const对象的属性可以修改吗"><a href="#2-const对象的属性可以修改吗" class="headerlink" title="2. const对象的属性可以修改吗"></a>2. const对象的属性可以修改吗</h3><p>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。</p><p>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p><h3 id="3-如果new一个箭头函数的会怎么样"><a href="#3-如果new一个箭头函数的会怎么样" class="headerlink" title="3. 如果new一个箭头函数的会怎么样"></a>3. 如果new一个箭头函数的会怎么样</h3><p>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p><p>new操作符的实现步骤如下：</p><ol><li>创建一个对象</li><li>将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）</li><li>指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）</li><li>返回新的对象</li></ol><p>所以，上面的第二、三步，箭头函数都是没有办法执行的。</p><h3 id="4-箭头函数与普通函数的区别"><a href="#4-箭头函数与普通函数的区别" class="headerlink" title="4. 箭头函数与普通函数的区别"></a>4. 箭头函数与普通函数的区别</h3><p><strong>（1）箭头函数比普通函数更加简洁</strong></p><ul><li>如果没有参数，就直接写一个空括号即可</li><li>如果只有一个参数，可以省去参数的括号</li><li>如果有多个参数，用逗号分割</li><li>如果函数体的返回值只有一句，可以省略大括号</li><li>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function">() =&gt;</span> <span class="keyword">void</span> doesNotReturn();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>（2）箭头函数没有自己的this</strong></p><p>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</p><p><strong>（3）箭头函数继承来的this指向永远不会改变</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;GLOBAL&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;OBJ&#x27;</span>,</span><br><span class="line">  <span class="attr">a</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.a();    <span class="comment">// &#x27;OBJ&#x27;</span></span><br><span class="line">obj.b();    <span class="comment">// &#x27;GLOBAL&#x27;</span></span><br><span class="line"><span class="keyword">new</span> obj.a()  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">new</span> obj.b()  <span class="comment">// Uncaught TypeError: obj.b is not a constructor</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号<code>&#123;&#125;</code>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p><p><strong>（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;Global&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> fun1 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id)</span><br><span class="line">&#125;;</span><br><span class="line">fun1();                     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.call(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.apply(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);    <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun1.bind(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;)();   <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>（5）箭头函数不能作为构造函数使用</strong></p><p>构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</p><p><strong>（6）箭头函数没有自己的arguments</strong></p><p>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</p><p><strong>（7）箭头函数没有prototype</strong></p><p><strong>（8）箭头函数不能用作Generator函数，不能使用yeild关键字</strong></p><h3 id="5-箭头函数的this指向哪⾥？"><a href="#5-箭头函数的this指向哪⾥？" class="headerlink" title="5. 箭头函数的this指向哪⾥？"></a>5. 箭头函数的<strong>this</strong>指向哪⾥？</h3><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p><p>可以⽤Babel理解⼀下箭头函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 </span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; </span><br><span class="line">  <span class="function"><span class="title">getArrow</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span> === obj); </span><br><span class="line">    &#125;; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>转化后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5，由 Babel 转译</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">   <span class="attr">getArrow</span>: <span class="function"><span class="keyword">function</span> <span class="title">getArrow</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">     <span class="keyword">var</span> _this = <span class="built_in">this</span>; </span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(_this === obj); </span><br><span class="line">     &#125;; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="6-扩展运算符的作用及使用场景"><a href="#6-扩展运算符的作用及使用场景" class="headerlink" title="6. 扩展运算符的作用及使用场景"></a>6. 扩展运算符的作用及使用场景</h3><p><strong>（1）对象扩展运算符</strong></p><p>对象的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> baz = &#123; ...bar &#125;; <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>上述方法实际上等价于:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> baz = <span class="built_in">Object</span>.assign(&#123;&#125;, bar); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>Object.assign</code>方法用于对象的合并，将源对象<code>（source）</code>的所有可枚举属性，复制到目标对象<code>（target）</code>。<code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。(<strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</strong>)。</p><p>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> baz = &#123;...bar, ...&#123;<span class="attr">a</span>:<span class="number">2</span>, <span class="attr">b</span>: <span class="number">4</span>&#125;&#125;;  <span class="comment">// &#123;a: 2, b: 4&#125;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>利用上述特性就可以很方便的修改对象的部分属性。在<code>redux</code>中的<code>reducer</code>函数规定必须是<strong>一个纯函数</strong>，<code>reducer</code>中的<code>state</code>对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。</p><p>需要注意：<strong>扩展运算符对对象实例的拷贝属于浅拷贝</strong>。</p><p><strong>（2）数组扩展运算符</strong></p><p>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>])</span><br><span class="line"><span class="comment">// 1 [2, 3, 4] 5</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>下面是数组的扩展运算符的应用：</p><ul><li><strong>将数组转换为参数序列</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">add(...numbers) <span class="comment">// 3</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>复制数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [...arr1];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>要记住：<strong>扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</strong>，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。</p><ul><li><strong>合并数组</strong></li></ul><p>如果想在数组内合并数组，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>];<span class="keyword">const</span> arr2 = [<span class="string">&#x27;one&#x27;</span>, ...arr1, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>];<span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>扩展运算符与解构赋值结合起来，用于生成数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];first <span class="comment">// 1rest  // [2, 3, 4, 5]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>需要注意：<strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [...rest, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];         <span class="comment">// 报错const [first, ...rest, last] = [1, 2, 3, 4, 5];  // 报错</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>将字符串转为真正的数组</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]    <span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组</strong></li></ul><p>比较常见的应用是可以将某些数据结构转为数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> args = [...arguments];</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>用于替换<code>es5</code>中的<code>Array.prototype.slice.call(arguments)</code>写法。</p><ul><li><strong>使用</strong><code>Math</code><strong>函数获取数组中特定的值</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>];</span><br><span class="line"><span class="built_in">Math</span>.min(...numbers); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.max(...numbers); <span class="comment">// 9</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="7-Proxy-可以实现什么功能？"><a href="#7-Proxy-可以实现什么功能？" class="headerlink" title="7. Proxy 可以实现什么功能？"></a>7. Proxy 可以实现什么功能？</h3><p>在 Vue3.0 中通过 <code>Proxy</code> 来替换原本的 <code>Object.defineProperty</code> 来实现数据响应式。</p><p>Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>target</code> 代表需要添加代理的对象，<code>handler</code> 用来自定义对象中的操作，比如可以用来自定义 <code>set</code> 或者 <code>get</code> 函数。</p><p>下面来通过 <code>Proxy</code> 来实现一个数据响应式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> onWatch = <span class="function">(<span class="params">obj, setBind, getLogger</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">target, property, receiver</span>)</span> &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, property, value, receiver</span>)</span> &#123;</span><br><span class="line">      setBind(value, property)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, property, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> p = onWatch(</span><br><span class="line">  obj,</span><br><span class="line">  <span class="function">(<span class="params">v, property</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`监听到属性<span class="subst">$&#123;property&#125;</span>改变为<span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">target, property</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`&#x27;<span class="subst">$&#123;property&#125;</span>&#x27; = <span class="subst">$&#123;target[property]&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">p.a = <span class="number">2</span> <span class="comment">// 监听到属性a改变</span></span><br><span class="line">p.a <span class="comment">// &#x27;a&#x27; = 2</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在上述代码中，通过自定义 <code>set</code> 和 <code>get</code> 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。</p><p>当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要在 <code>get</code> 中收集依赖，在 <code>set</code> 派发更新，之所以 Vue3.0 要使用 <code>Proxy</code> 替换原本的 API 原因在于 <code>Proxy</code> 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 <code>Proxy</code> 可以完美监听到任何方式的数据改变，唯一缺陷就是浏览器的兼容性不好。</p><h3 id="8-对对象与数组的解构的理解"><a href="#8-对对象与数组的解构的理解" class="headerlink" title="8. 对对象与数组的解构的理解"></a>8. 对对象与数组的解构的理解</h3><p>解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。 <strong>1）数组的解构</strong> 在解构数组时，以元素的位置为匹配条件来提取想要的数据的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>最终，a、b、c分别被赋予了数组第0、1、2个索引位的值： <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221929067.webp" alt="img"> 数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a,,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量： <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221929660.webp" alt="img"></p><p><strong>2）对象的解构</strong> 对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stu = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">24</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>假如想要解构它的两个自有属性，可以这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = stu</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样就得到了 name 和 age 两个和 stu 平级的变量： <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221929625.webp" alt="img"></p><p>注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; age, name &#125; = stu</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="9-如何提取高度嵌套的对象里的指定属性？"><a href="#9-如何提取高度嵌套的对象里的指定属性？" class="headerlink" title="9. 如何提取高度嵌套的对象里的指定属性？"></a>9. <strong>如何提取高度嵌套的对象里的指定属性？</strong></h3><p>有时会遇到一些嵌套程度非常深的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">   <span class="attr">classes</span>: &#123;</span><br><span class="line">      <span class="attr">stu</span>: &#123;</span><br><span class="line">         <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">         <span class="attr">age</span>: <span class="number">24</span>,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; name &#125; = school</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; classes &#125; = school</span><br><span class="line"><span class="keyword">const</span> &#123; stu &#125; = classes</span><br><span class="line"><span class="keyword">const</span> &#123; name &#125; = stu</span><br><span class="line">name <span class="comment">// &#x27;Bob&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>但是还有一种更标准的做法，可以用一行代码来解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">classes</span>: &#123; <span class="attr">stu</span>: &#123; name &#125; &#125;&#125; = school</span><br><span class="line">       </span><br><span class="line"><span class="built_in">console</span>.log(name)  <span class="comment">// &#x27;Bob&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。</p><h3 id="10-对-rest-参数的理解"><a href="#10-对-rest-参数的理解" class="headerlink" title="10. 对 rest 参数的理解"></a>10. 对 rest 参数的理解</h3><p>扩展运算符被用在函数形参上时，<strong>它还可以把一个分离的参数序列整合成一个数组</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mutiple</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> args) &#123;</span><br><span class="line">    result *= val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">mutiple(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 24</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mutiple</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args)</span><br><span class="line">&#125;</span><br><span class="line">mutiple(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点<strong>经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</strong></p><h3 id="11-ES6中模板语法与字符串处理"><a href="#11-ES6中模板语法与字符串处理" class="headerlink" title="11. ES6中模板语法与字符串处理"></a>11. ES6中模板语法与字符串处理</h3><p>ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;css&#x27;</span>   </span><br><span class="line"><span class="keyword">var</span> career = <span class="string">&#x27;coder&#x27;</span> </span><br><span class="line"><span class="keyword">var</span> hobby = [<span class="string">&#x27;coding&#x27;</span>, <span class="string">&#x27;writing&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> finalString = <span class="string">&#x27;my name is &#x27;</span> + name + <span class="string">&#x27;, I work as a &#x27;</span> + career + <span class="string">&#x27;, I love &#x27;</span> + hobby[<span class="number">0</span>] + <span class="string">&#x27; and &#x27;</span> + hobby[<span class="number">1</span>]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;css&#x27;</span>   </span><br><span class="line"><span class="keyword">var</span> career = <span class="string">&#x27;coder&#x27;</span> </span><br><span class="line"><span class="keyword">var</span> hobby = [<span class="string">&#x27;coding&#x27;</span>, <span class="string">&#x27;writing&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> finalString = <span class="string">`my name is <span class="subst">$&#123;name&#125;</span>, I work as a <span class="subst">$&#123;career&#125;</span> I love <span class="subst">$&#123;hobby[<span class="number">0</span>]&#125;</span> and <span class="subst">$&#123;hobby[<span class="number">1</span>]&#125;</span>`</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：</p><ul><li>在模板字符串中，空格、缩进、换行都会被保留</li><li>模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算</li></ul><p>基于第一点，可以在模板字符串里无障碍地直接写 html 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;列表项1&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;li&gt;列表项2&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 正确输出，不存在报错</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> finalString = <span class="string">`<span class="subst">$&#123;a&#125;</span> + <span class="subst">$&#123;b&#125;</span> = <span class="subst">$&#123;a+b&#125;</span>`</span></span><br><span class="line">  <span class="built_in">console</span>.log(finalString)</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 输出 &#x27;1 + 2 = 3&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：</p><p>（1）<strong>存在性判定</strong>：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf &gt; -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。</p><ul><li><strong>includes</strong>：判断字符串与子串的包含关系：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> son = <span class="string">&#x27;haha&#x27;</span> </span><br><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span></span><br><span class="line">father.includes(son) <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>startsWith</strong>：判断字符串是否以某个/某串字符开头：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span></span><br><span class="line">father.startsWith(<span class="string">&#x27;haha&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">father.startsWith(<span class="string">&#x27;xixi&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>endsWith</strong>：判断字符串是否以某个/某串字符结尾：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> father = <span class="string">&#x27;xixi haha hehe&#x27;</span></span><br><span class="line">  father.endsWith(<span class="string">&#x27;hehe&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（2）<strong>自动重复</strong>：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sourceCode = <span class="string">&#x27;repeat for 3 times;&#x27;</span></span><br><span class="line"><span class="keyword">const</span> repeated = sourceCode.repeat(<span class="number">3</span>) </span><br><span class="line"><span class="built_in">console</span>.log(repeated) <span class="comment">// repeat for 3 times;repeat for 3 times;repeat for 3 times;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="三、JavaScript基础"><a href="#三、JavaScript基础" class="headerlink" title="三、JavaScript基础"></a>三、JavaScript基础</h2><h3 id="1-new操作符的实现原理"><a href="#1-new操作符的实现原理" class="headerlink" title="1. new操作符的实现原理"></a>1. new操作符的实现原理</h3><p><strong>new操作符的执行过程：</strong></p><p>（1）首先创建了一个新的空对象</p><p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p><p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p><p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p><p>具体实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="title">constructor</span> = <span class="title">Array</span>.<span class="title">prototype</span>.<span class="title">shift</span>.<span class="title">call</span>(<span class="params"><span class="built_in">arguments</span></span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断参数是否是一个函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title">constructor</span> !== &quot;<span class="title">function</span>&quot;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="built_in">Object</span>.create(<span class="title">constructor</span>.<span class="title">prototype</span>);</span><br><span class="line">  <span class="comment">// 将 this 指向新建对象，并执行函数</span></span><br><span class="line">  result = <span class="title">constructor</span>.<span class="title">apply</span>(<span class="params">newObject, <span class="built_in">arguments</span></span>);</span><br><span class="line">  <span class="comment">// 判断返回对象</span></span><br><span class="line">  <span class="keyword">let</span> flag = result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line">  <span class="comment">// 判断返回结果</span></span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">objectFactory(构造函数, 初始化参数);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="2-map和Object的区别"><a href="#2-map和Object的区别" class="headerlink" title="2. map和Object的区别"></a>2. map和Object的区别</h3><table><thead><tr><th></th><th>Map</th><th>Object</th></tr></thead><tbody><tr><td>意外的键</td><td>Map默认情况不包含任何键，只包含显式插入的键。</td><td>Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。</td></tr><tr><td>键的类型</td><td>Map的键可以是任意值，包括函数、对象或任意基本类型。</td><td>Object 的键必须是 String 或是Symbol。</td></tr><tr><td>键的顺序</td><td>Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。</td><td>Object 的键是无序的</td></tr><tr><td>Size</td><td>Map 的键值对个数可以轻易地通过size 属性获取</td><td>Object 的键值对个数只能手动计算</td></tr><tr><td>迭代</td><td>Map 是 iterable 的，所以可以直接被迭代。</td><td>迭代Object需要以某种方式获取它的键然后才能迭代。</td></tr><tr><td>性能</td><td>在频繁增删键值对的场景下表现更好。</td><td>在频繁添加和删除键值对的场景下未作出优化。</td></tr></tbody></table><h3 id="3-map和weakMap的区别"><a href="#3-map和weakMap的区别" class="headerlink" title="3. map和weakMap的区别"></a>3. map和weakMap的区别</h3><p><strong>（1）Map</strong> map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。</p><p>实际上Map是一个数组，它的每一个数据也都是一个数组，其形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = [</span><br><span class="line">     [<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>],</span><br><span class="line">     [<span class="string">&quot;age&quot;</span>,<span class="number">18</span>],</span><br><span class="line">]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Map数据结构有以下操作方法：</p><ul><li><strong>size</strong>： <code>map.size</code> 返回Map结构的成员总数。</li><li>**set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li><li>**get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined。</li><li>**has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li><li>**delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false。</li><li>**clear()**：map.clear()清除所有成员，没有返回值。</li></ul><p>Map结构原生提供是三个遍历器生成函数和一个遍历方法</p><ul><li>keys()：返回键名的遍历器。</li><li>values()：返回键值的遍历器。</li><li>entries()：返回所有成员的遍历器。</li><li>forEach()：遍历Map的所有成员。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">     [<span class="string">&quot;foo&quot;</span>,<span class="number">1</span>],</span><br><span class="line">     [<span class="string">&quot;bar&quot;</span>,<span class="number">2</span>],</span><br><span class="line">])</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> map.keys())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);  <span class="comment">// foo bar</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> map.values())&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(value); <span class="comment">// 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> items <span class="keyword">of</span> map.entries())&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(items);  <span class="comment">// [&quot;foo&quot;,1]  [&quot;bar&quot;,2]</span></span><br><span class="line">&#125;</span><br><span class="line">map.forEach( <span class="function">(<span class="params">value,key,map</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(key,value); <span class="comment">// foo 1    bar 2</span></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>（2）WeakMap</strong> WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。<strong>其键必须是对象</strong>，原始数据类型不能作为key值，而值可以是任意的。</p><p>该对象也有以下几种方法：</p><ul><li>**set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li><li>**get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined。</li><li>**has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li><li>**delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false。</li></ul><p>其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。</p><p>WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。</p><p>而WeakMap的<strong>键名所引用的对象都是弱引用</strong>，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的<strong>键名对象和所对应的键值对会自动消失，不用手动删除引用</strong>。</p><p><strong>总结：</strong></p><ul><li>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li><li>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li></ul><h3 id="4-JavaScript有哪些内置对象"><a href="#4-JavaScript有哪些内置对象" class="headerlink" title="4. JavaScript有哪些内置对象"></a>4. JavaScript有哪些内置对象</h3><p>全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在 全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p><p><strong>标准内置对象的分类：</strong></p><p>（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量</p><p>（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等</p><p>（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等</p><p>（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date</p><p>（5）字符串，用来表示和操作字符串的对象。例如 String、RegExp</p><p>（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</p><p>（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。 例如 Map、Set、WeakMap、WeakSet</p><p>（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。 例如 SIMD 等</p><p>（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等</p><p>（10）控制抽象对象 例如 Promise、Generator 等</p><p>（11）反射。例如 Reflect、Proxy</p><p>（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等</p><p>（13）WebAssembly</p><p>（14）其他。例如 arguments</p><p><strong>总结：</strong> js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。</p><h3 id="5-常用的正则表达式有哪些？"><a href="#5-常用的正则表达式有哪些？" class="headerlink" title="5. 常用的正则表达式有哪些？"></a>5. 常用的正则表达式有哪些？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）匹配 16 进制颜色值</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）匹配 qq 号</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）手机号码正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^1[34578]\d&#123;9&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （5）用户名正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="6-对JSON的理解"><a href="#6-对JSON的理解" class="headerlink" title="6. 对JSON的理解"></a>6. 对JSON的理解</h3><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p><p>在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p><p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p><p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，</p><ul><li>JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</li><li>JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</li></ul><h3 id="7-JavaScript脚本延迟加载的方式有哪些？"><a href="#7-JavaScript脚本延迟加载的方式有哪些？" class="headerlink" title="7. JavaScript脚本延迟加载的方式有哪些？"></a>7. JavaScript脚本延迟加载的方式有哪些？</h3><p>延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</p><p>一般有以下几种方式：</p><ul><li><strong>defer 属性：</strong> 给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</li><li><strong>async 属性：</strong> 给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</li><li><strong>动态创建 DOM 方式：</strong> 动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</li><li><strong>使用 setTimeout 延迟方法：</strong> 设置一个定时器来延迟加载js脚本文件</li><li><strong>让 JS 最后加载：</strong> 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</li></ul><h3 id="8-JavaScript-类数组对象的定义？"><a href="#8-JavaScript-类数组对象的定义？" class="headerlink" title="8. JavaScript 类数组对象的定义？"></a>8. JavaScript 类数组对象的定义？</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。</p><p>常见的类数组转换为数组的方法有这样几种：</p><p>（1）通过 call 调用数组的 slice 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（2）通过 call 调用数组的 splice 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（3）通过 apply 调用数组的 concat 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（4）通过 Array.from 方法来实现转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="9-数组有哪些原生方法？"><a href="#9-数组有哪些原生方法？" class="headerlink" title="9. 数组有哪些原生方法？"></a>9. 数组有哪些原生方法？</h3><ul><li>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li><li>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li><li>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li><li>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li><li>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li><li>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li><li>数组归并方法 reduce() 和 reduceRight() 方法</li></ul><h3 id="10-Unicode、UTF-8、UTF-16、UTF-32的区别？"><a href="#10-Unicode、UTF-8、UTF-16、UTF-32的区别？" class="headerlink" title="10. Unicode、UTF-8、UTF-16、UTF-32的区别？"></a>10. <strong>Unicode、UTF-8、UTF-16、UTF-32的区别？</strong></h3><h4 id="（1）Unicode"><a href="#（1）Unicode" class="headerlink" title="（1）Unicode"></a>（1）Unicode</h4><p>在说<code>Unicode</code>之前需要先了解一下<code>ASCII</code>码：ASCII 码（<code>American Standard Code for Information Interchange</code>）称为美国标准信息交换码。</p><ul><li>它是基于拉丁字母的一套电脑编码系统。</li><li>它定义了一个用于代表常见字符的字典。</li><li>它包含了”A-Z”(包含大小写)，数据”0-9” 以及一些常见的符号。</li><li>它是专门为英语而设计的，有128个编码，对其他语言无能为力</li></ul><p><code>ASCII</code>码可以表示的编码有限，要想表示其他语言的编码，还是要使用<code>Unicode</code>来表示，可以说<code>Unicode</code>是<code>ASCII</code> 的超集。</p><p><code>Unicode</code>全称 <code>Unicode Translation Format</code>，又叫做统一码、万国码、单一码。<code>Unicode</code> 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</p><p><code>Unicode</code>的实现方式（也就是编码方式）有很多种，常见的是<strong>UTF-8</strong>、<strong>UTF-16</strong>、<strong>UTF-32</strong>和<strong>USC-2</strong>。</p><h4 id="（2）UTF-8"><a href="#（2）UTF-8" class="headerlink" title="（2）UTF-8"></a>（2）UTF-8</h4><p><code>UTF-8</code>是使用最广泛的<code>Unicode</code>编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容<code>ASCII</code>码的128个字符。</p><p><strong>注意：</strong> <code>UTF-8</code> 是一种编码方式，<code>Unicode</code>是一个字符集合。</p><p><code>UTF-8</code>的编码规则：</p><ul><li>对于<strong>单字节</strong>的符号，字节的第一位为0，后面的7位为这个字符的<code>Unicode</code>编码，因此对于英文字母，它的<code>Unicode</code>编码和<code>ACSII</code>编码一样。</li><li>对于<strong>n字节</strong>的符号，第一个字节的前n位都是1，第n+1位设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制位，全部为这个符号的<code>Unicode</code>码 。</li></ul><p>来看一下具体的<code>Unicode</code>编号范围与对应的<code>UTF-8</code>二进制格式 ：</p><table><thead><tr><th>编码范围（编号对应的十进制数）</th><th>二进制格式</th></tr></thead><tbody><tr><td>0x00—0x7F （0-127）</td><td>0xxxxxxx</td></tr><tr><td>0x80—0x7FF （128-2047）</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>0x800—0xFFFF  （2048-65535）</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>0x10000—0x10FFFF  （65536以上）</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p>那该如何通过具体的<code>Unicode</code>编码，进行具体的<code>UTF-8</code>编码呢？<strong>步骤如下：</strong></p><ul><li>找到该<code>Unicode</code>编码的所在的编号范围，进而找到与之对应的二进制格式</li><li>将<code>Unicode</code>编码转换为二进制数（去掉最高位的0）</li><li>将二进制数从右往左一次填入二进制格式的<code>X</code>中，如果有<code>X</code>未填，就设为0</li></ul><p>来看一个实际的例子： “<strong>马</strong>” 字的<code>Unicode</code>编码是：<code>0x9A6C</code>，整数编号是<code>39532</code> （1）首选确定了该字符在第三个范围内，它的格式是 <code>1110xxxx 10xxxxxx 10xxxxxx</code> （2）39532对应的二进制数为<code>1001 1010 0110 1100</code> （3）将二进制数填入X中，结果是：<code>11101001 10101001 10101100</code></p><h4 id="（3）UTF-16"><a href="#（3）UTF-16" class="headerlink" title="（3）UTF-16"></a>（3）UTF-16</h4><p><strong>1. 平面的概念</strong></p><p>在了解<code>UTF-16</code>之前，先看一下<strong>平面</strong>的概念： <code>Unicode</code>编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放<strong>65536</strong>（216）个字符，这称为一个<strong>平面</strong>，目前总共有17 个平面。</p><p>最前面的一个平面称为<strong>基本平面</strong>，它的码点从<strong>0 — 216-1</strong>，写成16进制就是<code>U+0000 — U+FFFF</code>，那剩下的16个平面就是<strong>辅助平面</strong>，码点范围是 <code>U+10000—U+10FFFF</code>。</p><p><strong>2. UTF-16 概念：</strong></p><p><code>UTF-16</code>也是<code>Unicode</code>编码集的一种编码形式，把<code>Unicode</code>字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。<code>Unicode</code>字符的码位需要1个或者2个16位长的码元来表示，因此<code>UTF-16</code>也是用变长字节表示的。</p><p><strong>3. UTF-16 编码规则：</strong></p><ul><li>编号在 <code>U+0000—U+FFFF</code> 的字符（常用字符集），直接用两个字节表示。</li><li>编号在 <code>U+10000—U+10FFFF</code> 之间的字符，需要用四个字节表示。</li></ul><p><strong>4. 编码识别</strong></p><p>那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？</p><p><code>UTF-16</code> 编码肯定也考虑到了这个问题，在基本平面内，从 <code>U+D800 — U+DFFF</code> 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。</p><p>辅助平面共有 <strong>220</strong> 个字符位，因此表示这些字符至少需要 20 个二进制位。<code>UTF-16</code> 将这 20 个二进制位分成两半，前 10 位映射在 <code>U+D800 — U+DBFF</code>，称为<strong>高位</strong>（H），后 10 位映射在 <code>U+DC00 — U+DFFF</code>，称为<strong>低位</strong>（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。</p><p>因此，当遇到两个字节时，发现它的码点在 <code>U+D800 —U+DBFF</code>之间，就可以知道，它后面的两个字节的码点应该在 <code>U+DC00 — U+DFFF</code> 之间，这四个字节必须放在一起进行解读。</p><p><strong>5. 举例说明</strong></p><p>以 “<strong>𡠀</strong>“ 字为例，它的 <code>Unicode</code> 码点为 <code>0x21800</code>，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：</p><ul><li>首先计算超出部分的结果：<code>0x21800 - 0x10000</code></li><li>将上面的计算结果转为20位的二进制数，不足20位就在前面补0，结果为：<code>0001000110 0000000000</code></li><li>将得到的两个10位二进制数分别对应到两个区间中</li><li><code>U+D800</code> 对应的二进制数为 <code>1101100000000000</code>， 将<code>0001000110</code>填充在它的后10 个二进制位，得到 <code>1101100001000110</code>，转成 16 进制数为 <code>0xD846</code>。同理，低位为 <code>0xDC00</code>，所以这个字的<code>UTF-16</code> 编码为 <code>0xD846 0xDC00</code></li></ul><h4 id="（4）-UTF-32"><a href="#（4）-UTF-32" class="headerlink" title="（4） UTF-32"></a>（4） UTF-32</h4><p><code>UTF-32</code> 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。</p><p>比如“<strong>马</strong>” 字的Unicode编号是：<code>U+9A6C</code>，整数编号是<code>39532</code>，直接转化为二进制：<code>1001 1010 0110 1100</code>，这就是它的UTF-32编码。</p><h4 id="（5）总结"><a href="#（5）总结" class="headerlink" title="（5）总结"></a>（5）总结</h4><p><strong>Unicode、UTF-8、UTF-16、UTF-32有什么区别？</strong></p><ul><li><code>Unicode</code> 是编码字符集（字符集），而<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>是字符集编码（编码规则）；</li><li><code>UTF-16</code> 使用变长码元序列的编码方式，相较于定长码元序列的<code>UTF-32</code>算法更复杂，甚至比同样是变长码元序列的<code>UTF-8</code>也更为复杂，因为其引入了独特的<strong>代理对</strong>这样的代理机制；</li><li><code>UTF-8</code>需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而<code>UTF-16</code>不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；</li><li>如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用<code>UTF-8</code>就比<code>UTF-16</code>节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么<code>UTF-16</code>就占优势了，可以节省很多空间；</li></ul><h3 id="11-常见的位运算符有哪些？其计算规则是什么？"><a href="#11-常见的位运算符有哪些？其计算规则是什么？" class="headerlink" title="11. 常见的位运算符有哪些？其计算规则是什么？"></a>11. 常见的位运算符有哪些？其计算规则是什么？</h3><p>现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。</p><p>常见的位运算有以下几种：</p><table><thead><tr><th>运算符</th><th>描述</th><th>运算规则</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>与</td><td>两个位都为1时，结果才为1</td></tr><tr><td>`</td><td>`</td><td>或</td></tr><tr><td><code>^</code></td><td>异或</td><td>两个位相同为0，相异为1</td></tr><tr><td><code>~</code></td><td>取反</td><td>0变1，1变0</td></tr><tr><td><code>&lt;&lt;</code></td><td>左移</td><td>各二进制位全部左移若干位，高位丢弃，低位补0</td></tr><tr><td><code>&gt;&gt;</code></td><td>右移</td><td>各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃</td></tr></tbody></table><h4 id="1-按位与运算符（-amp-）"><a href="#1-按位与运算符（-amp-）" class="headerlink" title="1. 按位与运算符（&amp;）"></a>1. 按位与运算符（&amp;）</h4><p><strong>定义：</strong> 参加运算的两个数据<strong>按二进制位</strong>进行“与”运算。 <strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> &amp; <span class="number">0</span> = <span class="number">0</span>  </span><br><span class="line"><span class="number">0</span> &amp; <span class="number">1</span> = <span class="number">0</span>  </span><br><span class="line"><span class="number">1</span> &amp; <span class="number">0</span> = <span class="number">0</span>  </span><br><span class="line"><span class="number">1</span> &amp; <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>总结：两位同时为1，结果才为1，否则结果为0。 例如：3&amp;5 即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span> </span><br><span class="line">   <span class="number">0000</span> <span class="number">0101</span> </span><br><span class="line"> = <span class="number">0000</span> <span class="number">0001</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>因此 3&amp;5 的值为1。 注意：负数按补码形式参加按位与运算。</p><p><strong>用途：</strong></p><p><strong>（1）判断奇偶</strong></p><p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用<code>if ((i &amp; 1) == 0)</code>代替<code>if (i % 2 == 0)</code>来判断a是不是偶数。</p><p><strong>（2）清零</strong></p><p>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</p><h4 id="2-按位或运算符（-）"><a href="#2-按位或运算符（-）" class="headerlink" title="2. 按位或运算符（|）"></a>2. 按位或运算符（|）</h4><p><strong>定义：</strong> 参加运算的两个对象按二进制位进行“或”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> | <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> | <span class="number">1</span> = <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> | <span class="number">0</span> = <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> | <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象只要有一个为1，其值为1。 例如：3|5即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">  <span class="number">0000</span> <span class="number">0101</span> </span><br><span class="line">= <span class="number">0000</span> <span class="number">0111</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>因此，3|5的值为7。 注意：负数按补码形式参加按位或运算。</p><h4 id="3-异或运算符（-）"><a href="#3-异或运算符（-）" class="headerlink" title="3. 异或运算符（^）"></a>3. 异或运算符（^）</h4><p><strong>定义：</strong> 参加运算的两个数据按二进制位进行“异或”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ^ <span class="number">0</span> = <span class="number">0</span>  </span><br><span class="line"><span class="number">0</span> ^ <span class="number">1</span> = <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> ^ <span class="number">0</span> = <span class="number">1</span>  </span><br><span class="line"><span class="number">1</span> ^ <span class="number">1</span> = <span class="number">0</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。 例如：3|5即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">  <span class="number">0000</span> <span class="number">0101</span> </span><br><span class="line">= <span class="number">0000</span> <span class="number">0110</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>因此，3^5的值为6。 异或运算的性质:</p><ul><li>交换律：<code>(a^b)^c == a^(b^c)</code></li><li>结合律：<code>(a + b)^c == a^b + b^c</code></li><li>对于任何数x，都有 <code>x^x=0，x^0=x</code></li><li>自反性: <code>a^b^b=a^0=a</code>;</li></ul><h4 id="4-取反运算符"><a href="#4-取反运算符" class="headerlink" title="4. 取反运算符 (~)"></a>4. 取反运算符 (~)</h4><p><strong>定义：</strong> 参加运算的一个数据按二进制进行“取反”运算。</p><p><strong>运算规则：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="number">1</span> = <span class="number">0</span>~ <span class="number">0</span> = <span class="number">1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>总结：对一个二进制数按位取反，即将0变1，1变0。 例如：~6 即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0110</span>= <span class="number">1111</span> <span class="number">1001</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。 当发现按位取反为负数时，就<strong>直接取其补码</strong>，变为十进制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0110</span>   = <span class="number">1111</span> <span class="number">1001</span>反码：<span class="number">1000</span> <span class="number">0110</span>补码：<span class="number">1000</span> <span class="number">0111</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>因此，~6的值为-7。</p><h4 id="5-左移运算符（-lt-lt-）"><a href="#5-左移运算符（-lt-lt-）" class="headerlink" title="5. 左移运算符（&lt;&lt;）"></a>5. 左移运算符（&lt;&lt;）</h4><p><strong>定义：</strong> 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。 设 a=1010 1110，a = a&lt;&lt; 2 将a的二进制位左移2位、右补0，即得a=1011 1000。 若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</p><h4 id="6-右移运算符（-gt-gt-）"><a href="#6-右移运算符（-gt-gt-）" class="headerlink" title="6. 右移运算符（&gt;&gt;）"></a>6. 右移运算符（&gt;&gt;）</h4><p><strong>定义：</strong> 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 例如：a=a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。 操作数每右移一位，相当于该数除以2。</p><h4 id="7-原码、补码、反码"><a href="#7-原码、补码、反码" class="headerlink" title="7. 原码、补码、反码"></a>7. 原码、补码、反码</h4><p>上面提到了补码、反码等知识，这里就补充一下。 计算机中的<strong>有符号数</strong>有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。</p><p><strong>（1）原码</strong></p><p>原码就是一个数的二进制数。例如：10的原码为0000 1010</p><p><strong>（2）反码</strong></p><ul><li>正数的反码与原码相同，如：10 反码为 0000 1010</li><li>负数的反码为除符号位，按位取反，即0变1，1变0。</li></ul><p>例如：-10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原码：<span class="number">1000</span> <span class="number">1010</span></span><br><span class="line">反码：<span class="number">1111</span> <span class="number">0101</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>（3）补码</strong></p><ul><li>正数的补码与原码相同，如：10 补码为 0000 1010</li><li>负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。</li></ul><p>例如：-10</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原码：<span class="number">1000</span> <span class="number">1010</span></span><br><span class="line">反码：<span class="number">1111</span> <span class="number">0101</span></span><br><span class="line">补码：<span class="number">1111</span> <span class="number">0110</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?"></a>12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</h3><p><code>arguments</code>是一个对象，它的属性是从 0 开始依次递增的数字，还有<code>callee</code>和<code>length</code>等属性，与数组相似；但是它却没有数组常见的方法属性，如<code>forEach</code>, <code>reduce</code>等，所以叫它们类数组。</p><p>要遍历类数组，有三个方法：</p><p>（1）将数组的方法应用到类数组上，这时候就可以使用<code>call</code>和<code>apply</code>方法，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>, <span class="function"><span class="params">a</span> =&gt;</span> <span class="built_in">console</span>.log(a))</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（2）使用Array.from方法将类数组转化成数组：‌</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">const</span> arrArgs = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>) </span><br><span class="line">  arrArgs.forEach(<span class="function"><span class="params">a</span> =&gt;</span> <span class="built_in">console</span>.log(a))</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（3）使用展开运算符将类数组转化成数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">const</span> arrArgs = [...arguments] </span><br><span class="line">    arrArgs.forEach(<span class="function"><span class="params">a</span> =&gt;</span> <span class="built_in">console</span>.log(a)) </span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="13-什么是-DOM-和-BOM？"><a href="#13-什么是-DOM-和-BOM？" class="headerlink" title="13. 什么是 DOM 和 BOM？"></a>13. 什么是 DOM 和 BOM？</h3><ul><li>DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</li><li>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</li></ul><h3 id="14-对类数组对象的理解，如何转化为数组"><a href="#14-对类数组对象的理解，如何转化为数组" class="headerlink" title="14. 对类数组对象的理解，如何转化为数组"></a>14. 对类数组对象的理解，如何转化为数组</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。</p><p>常见的类数组转换为数组的方法有这样几种：</p><ul><li>通过 call 调用数组的 slice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>通过 call 调用数组的 splice 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.splice.call(arrayLike, <span class="number">0</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>通过 apply 调用数组的 concat 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], arrayLike);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>通过 Array.from 方法来实现转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="15-escape、encodeURI、encodeURIComponent-的区别"><a href="#15-escape、encodeURI、encodeURIComponent-的区别" class="headerlink" title="15. escape、encodeURI、encodeURIComponent 的区别"></a>15. escape、encodeURI、encodeURIComponent 的区别</h3><ul><li>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</li><li>encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</li><li>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</li></ul><h3 id="16-对AJAX的理解，实现一个AJAX请求"><a href="#16-对AJAX的理解，实现一个AJAX请求" class="headerlink" title="16. 对AJAX的理解，实现一个AJAX请求"></a>16. 对AJAX的理解，实现一个AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>创建AJAX请求的步骤：</p><ul><li><strong>创建一个 XMLHttpRequest 对象。</strong></li><li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li><li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li><li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SERVER_URL = <span class="string">&quot;/server&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 创建 Http 请求</span></span><br><span class="line">xhr.open(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置状态监听函数</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 当请求成功时</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">    handle(<span class="built_in">this</span>.response);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="built_in">this</span>.statusText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="built_in">this</span>.statusText);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">xhr.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"><span class="comment">// 发送 Http 请求</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>使用Promise封装AJAX：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise 封装实现：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 promise 对象</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="comment">// 新建一个 http 请求</span></span><br><span class="line">    xhr.open(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 设置状态的监听函数</span></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 当请求成功或失败时，改变 promise 的状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="built_in">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置错误监听函数</span></span><br><span class="line">    xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置响应的数据类型</span></span><br><span class="line">    xhr.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    <span class="comment">// 设置请求头信息</span></span><br><span class="line">    xhr.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    <span class="comment">// 发送 http 请求</span></span><br><span class="line">    xhr.send(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="17-JavaScript为什么要进行变量提升，它导致了什么问题？"><a href="#17-JavaScript为什么要进行变量提升，它导致了什么问题？" class="headerlink" title="17. JavaScript为什么要进行变量提升，它导致了什么问题？"></a>17. JavaScript为什么要进行变量提升，它导致了什么问题？</h3><p>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。</p><p>造成变量声明提升的<strong>本质原因</strong>是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。</p><p>首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。</p><ul><li><p>在解析阶段</p><p>，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p><ul><li>全局上下文：变量定义，函数声明</li><li>函数上下文：变量定义，函数声明，this，arguments</li></ul></li><li><p><strong>在执行阶段</strong>，就是按照代码的顺序依次执行。</p></li></ul><p>那为什么会进行变量提升呢？主要有以下两个原因：</p><ul><li>提高性能</li><li>容错性更好</li></ul><p><strong>（1）提高性能</strong> 在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。</p><p>在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。</p><p><strong>（2）容错性更好</strong></p><p>变量提升可以在一定程度上提高JS的容错性，看下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;<span class="keyword">var</span> a;<span class="built_in">console</span>.log(a);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。</p><p>虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。</p><p><strong>总结：</strong></p><ul><li>解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间</li><li>声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</li></ul><p>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(tmp);</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line"><span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();  <span class="comment">// undefined</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tmp.length; i++) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(tmp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 11</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。</p><h3 id="18-什么是尾调用，使用尾调用有什么好处？"><a href="#18-什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="18. 什么是尾调用，使用尾调用有什么好处？"></a>18. 什么是尾调用，使用尾调用有什么好处？</h3><p>尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p><h3 id="19-ES6模块与CommonJS模块有什么异同？"><a href="#19-ES6模块与CommonJS模块有什么异同？" class="headerlink" title="19.  ES6模块与CommonJS模块有什么异同？"></a>19.  <strong>ES6</strong>模块与<strong>CommonJS</strong>模块有什么异同？</h3><p>ES6 Module和CommonJS模块的区别：</p><ul><li>CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；</li><li>import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。</li></ul><p>ES6 Module和CommonJS模块的共同点：</p><ul><li>CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。</li></ul><h3 id="20-常见的DOM操作有哪些"><a href="#20-常见的DOM操作有哪些" class="headerlink" title="20. 常见的DOM操作有哪些"></a>20. 常见的DOM操作有哪些</h3><h4 id="1）DOM-节点的获取"><a href="#1）DOM-节点的获取" class="headerlink" title="1）DOM 节点的获取"></a>1）DOM 节点的获取</h4><p>DOM 节点的获取的API及使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">getElementById <span class="comment">// 按照 id 查询</span></span><br><span class="line">getElementsByTagName <span class="comment">// 按照标签名查询</span></span><br><span class="line">getElementsByClassName <span class="comment">// 按照类名查询</span></span><br><span class="line">querySelectorAll <span class="comment">// 按照 css 选择器查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照 id 查询</span></span><br><span class="line"><span class="keyword">var</span> imooc = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;imooc&#x27;</span>) <span class="comment">// 查询到 id 为 imooc 的元素</span></span><br><span class="line"><span class="comment">// 按照标签名查询</span></span><br><span class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>)  <span class="comment">// 查询到标签为 p 的集合</span></span><br><span class="line"><span class="built_in">console</span>.log(divList.length)</span><br><span class="line"><span class="built_in">console</span>.log(divList[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// 按照类名查询</span></span><br><span class="line"><span class="keyword">var</span> moocList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;mooc&#x27;</span>) <span class="comment">// 查询到类名为 mooc 的集合</span></span><br><span class="line"><span class="comment">// 按照 css 选择器查询</span></span><br><span class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.mooc&#x27;</span>) <span class="comment">// 查询到类名为 mooc 的集合</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="2）DOM-节点的创建"><a href="#2）DOM-节点的创建" class="headerlink" title="2）DOM 节点的创建"></a>2）DOM 节点的创建</h4><p><strong>创建一个新节点，并把它添加到指定节点的后面。</strong> 已知的 HTML 结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DEMO<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先获取父节点</span></span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建新节点</span></span><br><span class="line"><span class="keyword">var</span> targetSpan = <span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>)</span><br><span class="line"><span class="comment">// 设置 span 节点的内容</span></span><br><span class="line">targetSpan.innerHTML = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="comment">// 把新创建的元素塞进父节点里去</span></span><br><span class="line">container.appendChild(targetSpan)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="3）DOM-节点的删除"><a href="#3）DOM-节点的删除" class="headerlink" title="3）DOM 节点的删除"></a>3）DOM 节点的删除</h4><p><strong>删除指定的 DOM 节点，</strong> 已知的 HTML 结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DEMO<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>需要删除 id 为 title 的元素，做法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取目标元素的父元素</span></span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取目标元素</span></span><br><span class="line"><span class="keyword">var</span> targetNode = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"><span class="comment">// 删除目标元素</span></span><br><span class="line">container.removeChild(targetNode)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>或者通过子节点数组来完成删除：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取目标元素的父元素var container = document.getElementById(&#x27;container&#x27;)// 获取目标元素var targetNode = container.childNodes[1]// 删除目标元素container.removeChild(targetNode)</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="4）修改-DOM-元素"><a href="#4）修改-DOM-元素" class="headerlink" title="4）修改 DOM 元素"></a>4）修改 DOM 元素</h4><p>修改 DOM 元素这个动作可以分很多维度，比如说移动 DOM 元素的位置，修改 DOM 元素的属性等。</p><p><strong>将指定的两个 DOM 元素交换位置，</strong> 已知的 HTML 结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DEMO<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span> </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span>我是内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>现在需要调换 title 和 content 的位置，可以考虑 insertBefore 或者 appendChild：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取父元素</span></span><br><span class="line"><span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>)   </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取两个需要被交换的元素</span></span><br><span class="line"><span class="keyword">var</span> title = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> content = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;content&#x27;</span>)</span><br><span class="line"><span class="comment">// 交换两个元素，把 content 置于 title 前面</span></span><br><span class="line">container.insertBefore(content, title)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="21-use-strict是什么意思-使用它区别是什么？"><a href="#21-use-strict是什么意思-使用它区别是什么？" class="headerlink" title="21. use strict是什么意思 ? 使用它区别是什么？"></a>21. use strict是什么意思 ? 使用它区别是什么？</h3><p>use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：</p><ul><li>消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;</li><li>消除代码运行的不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的 Javascript 做好铺垫。</li></ul><p>区别：</p><ul><li>禁止使用 with 语句。</li><li>禁止 this 关键字指向全局对象。</li><li>对象不能有重名的属性。</li></ul><h3 id="22-如何判断一个对象是否属于某个类？"><a href="#22-如何判断一个对象是否属于某个类？" class="headerlink" title="22. 如何判断一个对象是否属于某个类？"></a>22. 如何判断一个对象是否属于某个类？</h3><ul><li>第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</li><li>第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</li><li>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</li></ul><h3 id="23-强类型语言和弱类型语言的区别"><a href="#23-强类型语言和弱类型语言的区别" class="headerlink" title="23. 强类型语言和弱类型语言的区别"></a>23. 强类型语言和弱类型语言的区别</h3><ul><li><strong>强类型语言</strong>：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。</li><li><strong>弱类型语言</strong>：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串’12’和整数3进行连接得到字符串’123’，在相加的时候会进行强制类型转换。</li></ul><p>两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。</p><h3 id="24-解释性语言和编译型语言的区别"><a href="#24-解释性语言和编译型语言的区别" class="headerlink" title="24. 解释性语言和编译型语言的区别"></a>24. 解释性语言和编译型语言的区别</h3><p>（1）解释型语言 使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下</p><ul><li>解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；</li><li>只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；</li><li>JavaScript、Python等属于解释型语言。</li></ul><p>（2）编译型语言 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：</p><ul><li>一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；</li><li>与特定平台相关，一般无法移植到其他平台；</li><li>C、C++等属于编译型语言。</li></ul><p><strong>两者主要区别在于：</strong> 前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。</p><h3 id="25-for…in和for…of的区别"><a href="#25-for…in和for…of的区别" class="headerlink" title="25. for…in和for…of的区别"></a>25. for…in和for…of的区别</h3><p>for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下</p><ul><li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li><li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li><li>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</li></ul><p><strong>总结：</strong> for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p><h3 id="26-如何使用for…of遍历对象"><a href="#26-如何使用for…of遍历对象" class="headerlink" title="26. 如何使用for…of遍历对象"></a>26. 如何使用for…of遍历对象</h3><p>for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。</p><p>如果需要遍历的对象是类数组对象，用Array.from转成数组即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="number">0</span>:<span class="string">&#x27;one&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>:<span class="string">&#x27;two&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">obj = <span class="built_in">Array</span>.from(obj);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>);</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="function"><span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(count&lt;keys.length)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">value</span>: obj[keys[count++]],<span class="attr">done</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">of</span> obj)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>:<span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">of</span> keys)&#123;</span><br><span class="line">        <span class="keyword">yield</span> [k,obj[k]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> [k,v] <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k,v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="27-ajax、axios、fetch的区别"><a href="#27-ajax、axios、fetch的区别" class="headerlink" title="27. ajax、axios、fetch的区别"></a>27. ajax、axios、fetch的区别</h3><p><strong>（1）AJAX</strong> Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式网页应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：</p><ul><li>本身是针对MVC编程，不符合前端MVVM的浪潮</li><li>基于原生XHR开发，XHR本身的架构不清晰</li><li>不符合关注分离（Separation of Concerns）的原则</li><li>配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li></ul><p><strong>（2）Fetch</strong> fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。<strong>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象</strong>。</p><p>fetch的优点：</p><ul><li>语法简洁，更加语义化</li><li>基于标准 Promise 实现，支持 async/await</li><li>更加底层，提供的API丰富（request, response）</li><li>脱离了XHR，是ES规范里新的实现方式</li></ul><p>fetch的缺点：</p><ul><li>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li><li>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})</li><li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li><li>fetch没有办法原生监测请求的进度，而XHR可以</li></ul><p><strong>（3）Axios</strong> Axios 是一种基于Promise封装的HTTP客户端，其特点如下：</p><ul><li>浏览器端发起XMLHttpRequests请求</li><li>node端发起http请求</li><li>支持Promise API</li><li>监听请求和返回</li><li>对请求和返回进行转化</li><li>取消请求</li><li>自动转换json数据</li><li>客户端支持抵御XSRF攻击</li></ul><h3 id="28-数组的遍历方法有哪些"><a href="#28-数组的遍历方法有哪些" class="headerlink" title="28. 数组的遍历方法有哪些"></a>28. 数组的遍历方法有哪些</h3><table><thead><tr><th><strong>方法</strong></th><th><strong>是否改变原数组</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>forEach()</td><td>否</td><td>数组方法，不改变原数组，没有返回值</td></tr><tr><td>map()</td><td>否</td><td>数组方法，不改变原数组，有返回值，可链式调用</td></tr><tr><td>filter()</td><td>否</td><td>数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</td></tr><tr><td>for…of</td><td>否</td><td>for…of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环</td></tr><tr><td>every() 和 some()</td><td>否</td><td>数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.</td></tr><tr><td>find() 和 findIndex()</td><td>否</td><td>数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td></tr><tr><td>reduce() 和 reduceRight()</td><td>否</td><td>数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作</td></tr></tbody></table><p>遍历方法的详细解释：<a href="https://link.juejin.cn/?target=https://cuggz.blog.csdn.net/article/details/107649549">《细数JavaScript中那些遍历和循环》</a></p><h3 id="29-forEach和map方法有什么区别"><a href="#29-forEach和map方法有什么区别" class="headerlink" title="29. forEach和map方法有什么区别"></a>29. forEach和map方法有什么区别</h3><p>这方法都是用来遍历数组的，两者区别如下：</p><ul><li>forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</li><li>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</li></ul><h2 id="四、原型与原型链"><a href="#四、原型与原型链" class="headerlink" title="四、原型与原型链"></a>四、原型与原型链</h2><h3 id="1-对原型、原型链的理解"><a href="#1-对原型、原型链的理解" class="headerlink" title="1. 对原型、原型链的理解"></a>1. 对原型、原型链的理解</h3><p>在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。</p><p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。</p><p><strong>特点：</strong> JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c68fcad75ea54d62a9404aa02cafc65c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><h3 id="2-原型修改、重写"><a href="#2-原型修改、重写" class="headerlink" title="2. 原型修改、重写"></a>2. 原型修改、重写</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改原型</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 重写原型</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype)        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="comment">// false</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候<code>p.constructor === Object</code> ，而不是<code>p.constructor === Person</code>。要想成立，就要用constructor指回来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">p.constructor = Person</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype)        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="3-原型链指向"><a href="#3-原型链指向" class="headerlink" title="3. 原型链指向"></a>3. 原型链指向</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p.__proto__  <span class="comment">// Person.prototype</span></span><br><span class="line">Person.prototype.__proto__  <span class="comment">// Object.prototype</span></span><br><span class="line">p.__proto__.__proto__ <span class="comment">//Object.prototype</span></span><br><span class="line">p.__proto__.constructor.prototype.__proto__ <span class="comment">// Object.prototype</span></span><br><span class="line">Person.prototype.constructor.prototype.__proto__ <span class="comment">// Object.prototype</span></span><br><span class="line">p1.__proto__.constructor <span class="comment">// Person</span></span><br><span class="line">Person.prototype.constructor  <span class="comment">// Person</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="4-原型链的终点是什么？如何打印出原型链的终点？"><a href="#4-原型链的终点是什么？如何打印出原型链的终点？" class="headerlink" title="4. 原型链的终点是什么？如何打印出原型链的终点？"></a>4. 原型链的终点是什么？如何打印出原型链的终点？</h3><p>由于<code>Object</code>是构造函数，原型链终点是<code>Object.prototype.__proto__</code>，而<code>Object.prototype.__proto__=== null // true</code>，所以，原型链的终点是<code>null</code>。原型链上的所有原型都是对象，所有的对象最终都是由<code>Object</code>构造的，而<code>Object.prototype</code>的下一级是<code>Object.prototype.__proto__</code>。 <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221928408.webp" alt="img"></p><h3 id="5-如何获得对象非原型链上的属性？"><a href="#5-如何获得对象非原型链上的属性？" class="headerlink" title="5. 如何获得对象非原型链上的属性？"></a>5. 如何获得对象非原型链上的属性？</h3><p>使用后<code>hasOwnProperty()</code>方法来判断属性是否属于原型链的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterate</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> res=[];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj.hasOwnProperty(key))</span><br><span class="line">           res.push(key+<span class="string">&#x27;: &#x27;</span>+obj[key]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="五、执行上下文-作用域链-闭包"><a href="#五、执行上下文-作用域链-闭包" class="headerlink" title="五、执行上下文/作用域链/闭包"></a>五、执行上下文/作用域链/闭包</h2><h3 id="1-对闭包的理解"><a href="#1-对闭包的理解" class="headerlink" title="1. 对闭包的理解"></a>1. 对闭包的理解</h3><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><p>闭包有两个常用的用途；</p><ul><li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li><li>闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li></ul><p>比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="built_in">window</span>.B = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br><span class="line">B() <span class="comment">// 1</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。解决办法有三种：</p><ul><li>第一种是使用闭包的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;  ;(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;      <span class="built_in">console</span>.log(j)    &#125;, j * <span class="number">1000</span>)  &#125;)(i)&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在上述代码中，首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的。</p><ul><li>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;,</span><br><span class="line">    i * <span class="number">1000</span>,</span><br><span class="line">    i</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="2-对作用域、作用域链的理解"><a href="#2-对作用域、作用域链的理解" class="headerlink" title="2. 对作用域、作用域链的理解"></a>2. 对作用域、作用域链的理解</h3><h5 id="1）全局作用域和函数作用域"><a href="#1）全局作用域和函数作用域" class="headerlink" title="1）全局作用域和函数作用域"></a>1）全局作用域和函数作用域</h5><p>（1）全局作用域</p><ul><li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li><li>所有未定义直接赋值的变量自动声明为全局作用域</li><li>所有window对象的属性拥有全局作用域</li><li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li></ul><p>（2）函数作用域</p><ul><li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li><li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li></ul><h5 id="2）块级作用域"><a href="#2）块级作用域" class="headerlink" title="2）块级作用域"></a>2）块级作用域</h5><ul><li>使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li><li>let和const声明的变量不会有变量提升，也不可以重复声明</li><li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li></ul><p><strong>作用域链：</strong> 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。</p><p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p><p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p><p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p><h3 id="3-对执行上下文的理解"><a href="#3-对执行上下文的理解" class="headerlink" title="3. 对执行上下文的理解"></a>3. 对执行上下文的理解</h3><h5 id="1-执行上下文类型"><a href="#1-执行上下文类型" class="headerlink" title="1. 执行上下文类型"></a>1. 执行上下文类型</h5><p><strong>（1）全局执行上下文</strong></p><p>任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。</p><p><strong>（2）函数执行上下文</strong></p><p>当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。</p><p><strong>（3）</strong><code>eval</code><strong>函数执行上下文</strong></p><p>执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。</p><h5 id="2-执行上下文栈"><a href="#2-执行上下文栈" class="headerlink" title="2. 执行上下文栈"></a>2. 执行上下文栈</h5><ul><li>JavaScript引擎使用执行上下文栈来管理执行上下文</li><li>当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Inside first function&#x27;</span>);</span><br><span class="line">  second();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Again inside first function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Inside second function&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br><span class="line"><span class="comment">//执行顺序</span></span><br><span class="line"><span class="comment">//先执行second(),在执行first()</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h5 id="3-创建执行上下文"><a href="#3-创建执行上下文" class="headerlink" title="3. 创建执行上下文"></a>3. 创建执行上下文</h5><p>创建执行上下文有两个阶段：<strong>创建阶段</strong>和<strong>执行阶段</strong></p><p><strong>1）创建阶段</strong></p><p>（1）this绑定</p><ul><li>在全局执行上下文中，this指向全局对象（window对象）</li><li>在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</li></ul><p>（2）创建词法环境组件</p><ul><li>词法环境是一种有<strong>标识符——变量映射</strong>的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。</li><li>词法环境的内部有两个组件：<strong>加粗样式</strong>：环境记录器:用来储存变量个函数声明的实际位置<strong>外部环境的引用</strong>：可以访问父级作用域</li></ul><p>（3）创建变量环境组件</p><ul><li>变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。</li></ul><p><strong>2）执行阶段</strong> 此阶段会完成对变量的分配，最后执行完代码。</p><p><strong>简单来说执行上下文就是指：</strong></p><p>在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。</p><p>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p><ul><li>全局上下文：变量定义，函数声明</li><li>函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li></ul><p><strong>注：</strong> 由于字数限制，剩余内容在下篇进行总结哦。</p><h2 id="六、this-call-apply-bind"><a href="#六、this-call-apply-bind" class="headerlink" title="六、this/call/apply/bind"></a>六、this/call/apply/bind</h2><h3 id="1-对this对象的理解"><a href="#1-对this对象的理解" class="headerlink" title="1. 对this对象的理解"></a>1. 对this对象的理解</h3><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p><ul><li>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li><li>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li><li>第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li><li>第四种是 <strong>apply 、 call 和 bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li></ul><p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p><h3 id="2-call-和-apply-的区别？"><a href="#2-call-和-apply-的区别？" class="headerlink" title="2. call() 和 apply() 的区别？"></a>2. call() 和 apply() 的区别？</h3><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p><ul><li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li><li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li></ul><h3 id="3-实现call、apply-及-bind-函数"><a href="#3-实现call、apply-及-bind-函数" class="headerlink" title="3. 实现call、apply 及 bind 函数"></a>3. 实现call、apply 及 bind 函数</h3><p><strong>（1）call 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>处理传入的参数，截取第一个参数后的所有参数。</li><li>将函数作为上下文对象的一个属性。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;  <span class="comment">// 判断调用对象  if (typeof this !== &quot;function&quot;) &#123;    console.error(&quot;type error&quot;);  &#125;  // 获取参数  let args = [...arguments].slice(1),    result = null;  // 判断 context 是否传入，如果未传入则设置为 window  context = context || window;  // 将调用函数设为对象的方法  context.fn = this;  // 调用函数  result = context.fn(...args);  // 将属性删除  delete context.fn;  return result;&#125;;复制代码</span></span><br></pre></td></tr></table></figure><p><strong>（2）apply 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>将函数作为上下文对象的一个属性。</li><li>判断参数值是否传入</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性</li><li>返回结果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;  <span class="comment">// 判断调用对象是否为函数  if (typeof this !== &quot;function&quot;) &#123;    throw new TypeError(&quot;Error&quot;);  &#125;  let result = null;  // 判断 context 是否存在，如果未传入则为 window  context = context || window;  // 将函数设为对象的方法  context.fn = this;  // 调用方法  if (arguments[1]) &#123;    result = context.fn(...arguments[1]);  &#125; else &#123;    result = context.fn();  &#125;  // 将属性删除  delete context.fn;  return result;&#125;;复制代码</span></span><br></pre></td></tr></table></figure><p><strong>（3）bind 函数的实现步骤：</strong></p><ul><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回</li><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;  <span class="comment">// 判断调用对象是否为函数  if (typeof this !== &quot;function&quot;) &#123;    throw new TypeError(&quot;Error&quot;);  &#125;  // 获取参数  var args = [...arguments].slice(1),    fn = this;  return function Fn() &#123;    // 根据调用方式，传入不同绑定值    return fn.apply(      this instanceof Fn ? this : context,      args.concat(...arguments)    );  &#125;;&#125;;复制代码</span></span><br></pre></td></tr></table></figure><h2 id="七、异步编程"><a href="#七、异步编程" class="headerlink" title="七、异步编程"></a>七、异步编程</h2><h3 id="1-异步编程的实现方式？"><a href="#1-异步编程的实现方式？" class="headerlink" title="1. 异步编程的实现方式？"></a>1. 异步编程的实现方式？</h3><p>JavaScript中的异步机制可以分为以下几种：</p><ul><li><strong>回调函数</strong> 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</li><li><strong>Promise</strong> 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</li><li><strong>generator</strong> 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</li><li><strong>async 函数</strong> 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li></ul><h3 id="2-setTimeout、Promise、Async-Await-的区别"><a href="#2-setTimeout、Promise、Async-Await-的区别" class="headerlink" title="2. setTimeout、Promise、Async/Await 的区别"></a>2. setTimeout、Promise、Async/Await 的区别</h3><h4 id="（1）setTimeout"><a href="#（1）setTimeout" class="headerlink" title="（1）setTimeout"></a>（1）setTimeout</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)<span class="comment">//1. 打印 script startsetTimeout(function()&#123;    console.log(&#x27;settimeout&#x27;)// 4. 打印 settimeout&#125;)// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数console.log(&#x27;script end&#x27;)//3. 打印 script start// 输出顺序：script start-&gt;script end-&gt;settimeout复制代码</span></span><br></pre></td></tr></table></figure><h4 id="（2）Promise"><a href="#（2）Promise" class="headerlink" title="（2）Promise"></a>（2）Promise</h4><p>Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)<span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)    resolve()    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1 end&#x27;</span>)&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)&#125;)<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;settimeout&#x27;</span>)&#125;)<span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)<span class="comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout复制代码</span></span><br></pre></td></tr></table></figure><p>当JS主线程执行到Promise对象时：</p><ul><li>promise1.then() 的回调就是一个 task</li><li>promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li><li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li><li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li></ul><h4 id="（3）async-await"><a href="#（3）async-await" class="headerlink" title="（3）async/await"></a>（3）async/await</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;   <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);    <span class="keyword">await</span> async2();    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)&#125;<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>)&#125;<span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);async1();<span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)<span class="comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end复制代码</span></span><br></pre></td></tr></table></figure><p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> <span class="number">1</span>&#125;<span class="built_in">console</span>.log(func1())复制代码</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40194bdc07024b78b6da8bb43d84a7d8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"> func1的运行结果其实就是一个Promise对象。因此也可以使用then来处理后续逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func1().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;    <span class="built_in">console</span>.log(res);  <span class="comment">// 30&#125;)复制代码</span></span><br></pre></td></tr></table></figure><p>await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p><h3 id="3-对Promise的理解"><a href="#3-对Promise的理解" class="headerlink" title="3. 对Promise的理解"></a>3. 对Promise的理解</h3><p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。</p><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>（1）Promise的实例有<strong>三个状态</strong>:</p><ul><li>Pending（进行中）</li><li>Resolved（已完成）</li><li>Rejected（已拒绝）</li></ul><p>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</p><p>（2）Promise的实例有<strong>两个过程</strong>：</p><ul><li>pending -&gt; fulfilled : Resolved（已完成）</li><li>pending -&gt; rejected：Rejected（已拒绝）</li></ul><p>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</p><p><strong>Promise的特点：</strong></p><ul><li>对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“<strong>承诺</strong>”；</li><li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>，从<code>pending</code>变为<code>rejected</code>。这时就称为<code>resolved</code>（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li></ul><p><strong>Promise的缺点：</strong></p><ul><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul><p><strong>总结：</strong> Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。</p><p>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p><p><strong>注意：</strong> 在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p><h3 id="4-Promise的基本用法"><a href="#4-Promise的基本用法" class="headerlink" title="4. Promise的基本用法"></a>4. Promise的基本用法</h3><h4 id="（1）创建Promise对象"><a href="#（1）创建Promise对象" class="headerlink" title="（1）创建Promise对象"></a>（1）创建Promise对象</h4><p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;  <span class="comment">// ... some code  if (/* 异步操作成功 */)&#123;    resolve(value);  &#125; else &#123;    reject(error);  &#125;&#125;);复制代码</span></span><br></pre></td></tr></table></figure><p><strong>一般情况下都会使用</strong><code>new Promise()</code><strong>来创建promise对象，但是也可以使用</strong><code>promise.resolve</code><strong>和</strong><code>promise.reject</code><strong>这两个方法：</strong></p><ul><li><strong>Promise.resolve</strong></li></ul><p><code>Promise.resolve(value)</code>的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">11</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;  <span class="built_in">console</span>.log(value); <span class="comment">// 打印出11&#125;);复制代码</span></span><br></pre></td></tr></table></figure><p><code>resolve(11)</code>代码中，会让promise对象进入确定(<code>resolve</code>状态)，并将参数<code>11</code>传递给后面的<code>then</code>所指定的<code>onFulfilled</code> 函数；</p><p>创建promise对象可以使用<code>new Promise</code>的形式创建对象，也可以使用<code>Promise.resolve(value)</code>的形式创建promise对象；</p><ul><li><strong>Promise.reject</strong></li></ul><p><code>Promise.reject</code> 也是<code>new Promise</code>的快捷形式，也创建一个promise对象。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(“我错了，请原谅俺！！”));复制代码</span><br></pre></td></tr></table></figure><p>就是下面的代码new Promise的简单形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;   reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;我错了！&quot;</span>));&#125;);复制代码</span><br></pre></td></tr></table></figure><p>下面是使用resolve方法和reject方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testPromise</span>(<span class="params">ready</span>) </span>&#123;  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;    <span class="keyword">if</span>(ready) &#123;      resolve(<span class="string">&quot;hello world&quot;</span>);    &#125;<span class="keyword">else</span> &#123;      reject(<span class="string">&quot;No thanks&quot;</span>);    &#125;  &#125;);&#125;;<span class="comment">// 方法调用testPromise(true).then(function(msg)&#123;  console.log(msg);&#125;,function(error)&#123;  console.log(error);&#125;);复制代码</span></span><br></pre></td></tr></table></figure><p>上面的代码的含义是给<code>testPromise</code>方法传递一个参数，返回一个promise对象，如果为<code>true</code>的话，那么调用promise对象中的<code>resolve()</code>方法，并且把其中的参数传递给后面的<code>then</code>第一个函数内，因此打印出 “<code>hello world</code>”, 如果为<code>false</code>的话，会调用promise对象中的<code>reject()</code>方法，则会进入<code>then</code>的第二个函数内，会打印<code>No thanks</code>；</p><h4 id="（2）Promise方法"><a href="#（2）Promise方法" class="headerlink" title="（2）Promise方法"></a>（2）Promise方法</h4><p>Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。</p><ol><li><strong>then()</strong></li></ol><p>当Promise执行的内容符合成功条件时，调用<code>resolve</code>函数，失败就调用<code>reject</code>函数。Promise创建完了，那该如何调用呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(function(value) &#123;  // success&#125;, function(error) &#123;  // failure&#125;);复制代码</span><br></pre></td></tr></table></figure><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为<code>resolved</code>时调用，第二个回调函数是Promise对象的状态变为<code>rejected</code>时调用。其中第二个参数可以省略。 <code>then</code>方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个then方法。</p><p>当要写有顺序的异步事件时，需要串行时，可以这样写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;    ajax(<span class="string">&#x27;first&#x27;</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;        resolve(res);    &#125;)&#125;)promise.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle,reject</span>)=&gt;</span>&#123;        ajax(<span class="string">&#x27;second&#x27;</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;            resolve(res)        &#125;)    &#125;)&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resovle,reject</span>)=&gt;</span>&#123;        ajax(<span class="string">&#x27;second&#x27;</span>).success(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;            resolve(res)        &#125;)    &#125;)&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;    &#125;)复制代码</span><br></pre></td></tr></table></figure><p>那当要写的事件没有顺序或者关系时，还如何写呢？可以使用<code>all</code> 方法来解决。</p><p><strong>2. catch()</strong></p><p>Promise对象除了有then方法，还有一个catch方法，该方法相当于<code>then</code>方法的第二个参数，指向<code>reject</code>的回调函数。不过<code>catch</code>方法还有一个作用，就是在执行<code>resolve</code>回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入<code>catch</code>方法中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;     <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>,data);&#125;,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;     <span class="built_in">console</span>.log(<span class="string">&#x27;rejected&#x27;</span>,err);     &#125;); p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>,data);&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;rejected&#x27;</span>,err);&#125;);复制代码</span><br></pre></td></tr></table></figure><p><strong>3. all()</strong></p><p><code>all</code>方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个<code>promise</code>对象。当数组中所有的<code>promise</code>的状态都达到<code>resolved</code>的时候，<code>all</code>方法的状态就会变成<code>resolved</code>，如果有一个状态变成了<code>rejected</code>，那么<code>all</code>方法的状态就会变成<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascriptlet promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;       resolve(<span class="number">1</span>);&#125;,<span class="number">2000</span>)&#125;);<span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;       resolve(<span class="number">2</span>);&#125;,<span class="number">1000</span>)&#125;);<span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;       resolve(<span class="number">3</span>);&#125;,<span class="number">3000</span>)&#125;);<span class="built_in">Promise</span>.all([promise1,promise2,promise3]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;    <span class="built_in">console</span>.log(res);    <span class="comment">//结果为：[1,2,3] &#125;)复制代码</span></span><br></pre></td></tr></table></figure><p>调用<code>all</code>方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象<code>resolve</code>执行时的值。</p><p><strong>（4）race()</strong></p><p><code>race</code>方法和<code>all</code>一样，接受的参数是一个每项都是<code>promise</code>的数组，但是与<code>all</code>不同的是，当最先执行完的事件执行完之后，就直接返回该<code>promise</code>对象的值。如果第一个<code>promise</code>对象状态变成<code>resolved</code>，那自身的状态变成了<code>resolved</code>；反之第一个<code>promise</code>变成<code>rejected</code>，那自身状态就会变成<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;       reject(<span class="number">1</span>);&#125;,<span class="number">2000</span>)&#125;);<span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;       resolve(<span class="number">2</span>);&#125;,<span class="number">1000</span>)&#125;);<span class="keyword">let</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;       resolve(<span class="number">3</span>);&#125;,<span class="number">3000</span>)&#125;);<span class="built_in">Promise</span>.race([promise1,promise2,promise3]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(res);<span class="comment">//结果：2&#125;,rej=&gt;&#123;    console.log(rej)&#125;;)复制代码</span></span><br></pre></td></tr></table></figure><p>那么<code>race</code>方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([promise1,timeOutPromise(<span class="number">5000</span>)]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)复制代码</span><br></pre></td></tr></table></figure><p><strong>5. finally()</strong></p><p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;).finally(<span class="function">() =&gt;</span> &#123;···&#125;);复制代码</span><br></pre></td></tr></table></figure><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.listen(port)  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="comment">// ...  &#125;)  .finally(server.stop);复制代码</span></span><br></pre></td></tr></table></figure><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。<code>finally</code>本质上是<code>then</code>方法的特例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.finally(<span class="function">() =&gt;</span> &#123;  <span class="comment">// 语句&#125;);// 等同于promise.then(  result =&gt; &#123;    // 语句    return result;  &#125;,  error =&gt; &#123;    // 语句    throw error;  &#125;);复制代码</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p><h3 id="5-Promise解决了什么问题"><a href="#5-Promise解决了什么问题" class="headerlink" title="5. Promise解决了什么问题"></a>5. Promise解决了什么问题</h3><p>在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)fs.readFile(<span class="string">&#x27;./a.txt&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;  fs.readFile(data,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;    fs.readFile(data,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;      <span class="built_in">console</span>.log(data)    &#125;)  &#125;)&#125;)复制代码</span><br></pre></td></tr></table></figure><p>上面的代码有如下缺点：</p><ul><li>后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。</li><li>如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。</li></ul><p><code>Promise</code>出现之后，代码变成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)<span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">url</span>)</span>&#123;  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;    fs.readFile(url,<span class="string">&#x27;utf8&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,data</span>)</span>&#123;      error &amp;&amp; reject(error)      resolve(data)    &#125;)  &#125;)&#125;read(<span class="string">&#x27;./a.txt&#x27;</span>).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;  <span class="keyword">return</span> read(data) &#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;  <span class="keyword">return</span> read(data)  &#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;  <span class="built_in">console</span>.log(data)&#125;)复制代码</span><br></pre></td></tr></table></figure><p>这样代码看起了就简洁了很多，解决了地狱回调的问题。</p><h3 id="6-Promise-all和Promise-race的区别的使用场景"><a href="#6-Promise-all和Promise-race的区别的使用场景" class="headerlink" title="6. Promise.all和Promise.race的区别的使用场景"></a>6. Promise.all和Promise.race的区别的使用场景</h3><p><strong>（1）Promise.all</strong> <code>Promise.all</code>可以将多个<code>Promise</code>实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是<strong>一个结果数组</strong>，而失败的时候则返回<strong>最先被reject失败状态的值</strong>。</p><p>Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。</p><p>需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。</p><p><strong>（2）Promise.race</strong></p><p>顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([promise1,timeOutPromise(<span class="number">5000</span>)]).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)复制代码</span><br></pre></td></tr></table></figure><h3 id="7-对async-await-的理解"><a href="#7-对async-await-的理解" class="headerlink" title="7.  对async/await 的理解"></a>7.  对async/await 的理解</h3><p>async/await其实是<code>Generator</code> 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsy</span>(<span class="params"></span>)</span>&#123;   <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;&#125;<span class="keyword">let</span> result = testAsy(); <span class="built_in">console</span>.log(result)复制代码</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221934780.webp" alt="img"></p><p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p><p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsy</span>(<span class="params"></span>)</span>&#123;   <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>&#125;<span class="keyword">let</span> result = testAsy() <span class="built_in">console</span>.log(result)result.then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;    <span class="built_in">console</span>.log(v)   <span class="comment">// hello world&#125;)复制代码</span></span><br></pre></td></tr></table></figure><p>那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p><p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p><p><strong>注意：</strong><code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p><h3 id="8-await-到底在等啥？"><a href="#8-await-到底在等啥？" class="headerlink" title="8. await 到底在等啥？"></a>8. await 到底在等啥？</h3><p><strong>await 在等待什么呢？</strong> 一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p><p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomething</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> <span class="string">&quot;something&quot;</span>;&#125;<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;hello async&quot;</span>);&#125;<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">const</span> v1 = <span class="keyword">await</span> getSomething();    <span class="keyword">const</span> v2 = <span class="keyword">await</span> testAsync();    <span class="built_in">console</span>.log(v1, v2);&#125;test();复制代码</span><br></pre></td></tr></table></figure><p>await 表达式的运算结果取决于它等的是什么。</p><ul><li>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li><li>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li></ul><p>来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAsy</span>(<span class="params">x</span>)</span>&#123;   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;       resolve(x);     &#125;, <span class="number">3000</span>)    &#125;   )&#125;<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAwt</span>(<span class="params"></span>)</span>&#123;      <span class="keyword">let</span> result =  <span class="keyword">await</span> testAsy(<span class="string">&#x27;hello world&#x27;</span>);  <span class="built_in">console</span>.log(result);    <span class="comment">// 3秒钟之后出现hello world  console.log(&#x27;cuger&#x27;)   // 3秒钟之后出现cug&#125;testAwt();console.log(&#x27;cug&#x27;)  //立即输出cug复制代码</span></span><br></pre></td></tr></table></figure><p>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以’cug’’最先输出，hello world’和‘cuger’是3秒钟后同时出现的。</p><h3 id="9-async-await的优势"><a href="#9-async-await的优势" class="headerlink" title="9.  async/await的优势"></a>9.  async/await的优势</h3><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。</p><p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 <code>setTimeout</code> 来模拟异步操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 传入参数 n，表示这个函数执行的时间（毫秒） * 执行的结果是 n + 200，这个值将用于下一步骤 */</span><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(n + <span class="number">200</span>), n);    &#125;);&#125;<span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);    <span class="keyword">return</span> takeLongTime(n);&#125;<span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">n</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);    <span class="keyword">return</span> takeLongTime(n);&#125;<span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">n</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);    <span class="keyword">return</span> takeLongTime(n);&#125;复制代码</span><br></pre></td></tr></table></figure><p>现在用 Promise 方式来实现这三个步骤的处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.time(<span class="string">&quot;doIt&quot;</span>);    <span class="keyword">const</span> time1 = <span class="number">300</span>;    step1(time1)        .then(<span class="function"><span class="params">time2</span> =&gt;</span> step2(time2))        .then(<span class="function"><span class="params">time3</span> =&gt;</span> step3(time3))        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;            <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);            <span class="built_in">console</span>.timeEnd(<span class="string">&quot;doIt&quot;</span>);        &#125;);&#125;doIt();<span class="comment">// c:\var\test&gt;node --harmony_async_await .// step1 with 300// step2 with 500// step3 with 700// result is 900// doIt: 1507.251ms复制代码</span></span><br></pre></td></tr></table></figure><p>输出结果 <code>result</code> 是 <code>step3()</code> 的参数 <code>700 + 200</code> = <code>900</code>。<code>doIt()</code> 顺序执行了三个步骤，一共用了 <code>300 + 500 + 700 = 1500</code> 毫秒，和 <code>console.time()/console.timeEnd()</code> 计算的结果一致。</p><p>如果用 async/await 来实现呢，会是这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.time(<span class="string">&quot;doIt&quot;</span>);    <span class="keyword">const</span> time1 = <span class="number">300</span>;    <span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1);    <span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time2);    <span class="keyword">const</span> result = <span class="keyword">await</span> step3(time3);    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);    <span class="built_in">console</span>.timeEnd(<span class="string">&quot;doIt&quot;</span>);&#125;doIt();复制代码</span><br></pre></td></tr></table></figure><p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p><h3 id="10-async-await对比Promise的优势"><a href="#10-async-await对比Promise的优势" class="headerlink" title="10. async/await对比Promise的优势"></a>10. async/await对比Promise的优势</h3><ul><li>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担</li><li>Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅</li><li>错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余</li><li>调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。</li></ul><h3 id="11-async-await-如何捕获异常"><a href="#11-async-await-如何捕获异常" class="headerlink" title="11. async/await 如何捕获异常"></a>11. async/await 如何捕获异常</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;    <span class="keyword">try</span>&#123;        <span class="keyword">let</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;error&#x27;</span>)    &#125;<span class="keyword">catch</span>(error)&#123;        <span class="built_in">console</span>.log(error)    &#125;&#125;复制代码</span><br></pre></td></tr></table></figure><h3 id="12-并发与并行的区别？"><a href="#12-并发与并行的区别？" class="headerlink" title="12. 并发与并行的区别？"></a>12. 并发与并行的区别？</h3><ul><li>并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。</li><li>并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</li></ul><h3 id="13-什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？"><a href="#13-什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？" class="headerlink" title="13. 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？"></a>13. 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？</h3><p>以下代码就是一个回调函数的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, <span class="function">() =&gt;</span> &#123;    <span class="comment">// 处理逻辑&#125;)复制代码</span></span><br></pre></td></tr></table></figure><p>回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，可能会有如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, <span class="function">() =&gt;</span> &#123;    <span class="comment">// 处理逻辑    ajax(url1, () =&gt; &#123;        // 处理逻辑        ajax(url2, () =&gt; &#123;            // 处理逻辑        &#125;)    &#125;)&#125;)复制代码</span></span><br></pre></td></tr></table></figure><p>以上代码看起来不利于阅读和维护，当然，也可以把函数分开来写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">firstAjax</span>(<span class="params"></span>) </span>&#123;  ajax(url1, <span class="function">() =&gt;</span> &#123;    <span class="comment">// 处理逻辑    secondAjax()  &#125;)&#125;function secondAjax() &#123;  ajax(url2, () =&gt; &#123;    // 处理逻辑  &#125;)&#125;ajax(url, () =&gt; &#123;  // 处理逻辑  firstAjax()&#125;)复制代码</span></span><br></pre></td></tr></table></figure><p>以上的代码虽然看上去利于阅读了，但是还是没有解决根本问题。回调地狱的根本问题就是：</p><ol><li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li><li>嵌套函数一多，就很难处理错误</li></ol><p>当然，回调函数还存在着别的几个缺点，比如不能使用 <code>try catch</code> 捕获错误，不能直接 <code>return</code>。</p><h3 id="14-setTimeout、setInterval、requestAnimationFrame-各有什么特点？"><a href="#14-setTimeout、setInterval、requestAnimationFrame-各有什么特点？" class="headerlink" title="14. setTimeout、setInterval、requestAnimationFrame 各有什么特点？"></a>14. setTimeout、setInterval、requestAnimationFrame 各有什么特点？</h3><p>异步编程当然少不了定时器了，常见的定时器函数有 <code>setTimeout</code>、<code>setInterval</code>、<code>requestAnimationFrame</code>。最常用的是<code>setTimeout</code>，很多人认为 <code>setTimeout</code> 是延时多久，那就应该是多久后执行。</p><p>其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 <code>setTimeout</code> 不会按期执行。当然了，可以通过代码去修正 <code>setTimeout</code>，从而使定时器相对准确：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> period = <span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span> * 2<span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()<span class="keyword">let</span> count = 0<span class="keyword">let</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + periodlet interval = 1000<span class="keyword">let</span> currentInterval = intervalfunction <span class="function"><span class="title">loop</span>(<span class="params"></span>)</span> &#123;  count++  <span class="comment">// 代码执行所消耗的时间  let offset = new Date().getTime() - (startTime + count * interval);  let diff = end - new Date().getTime()  let h = Math.floor(diff / (60 * 1000 * 60))  let hdiff = diff % (60 * 1000 * 60)  let m = Math.floor(hdiff / (60 * 1000))  let mdiff = hdiff % (60 * 1000)  let s = mdiff / (1000)  let sCeil = Math.ceil(s)  let sFloor = Math.floor(s)  // 得到下一次循环所消耗的时间  currentInterval = interval - offset   console.log(&#x27;时：&#x27;+h, &#x27;分：&#x27;+m, &#x27;毫秒：&#x27;+s, &#x27;秒向上取整：&#x27;+sCeil, &#x27;代码执行时间：&#x27;+offset, &#x27;下次循环间隔&#x27;+currentInterval)   setTimeout(loop, currentInterval)&#125;setTimeout(loop, currentInterval)复制代码</span></span><br></pre></td></tr></table></figure><p>接下来看 <code>setInterval</code>，其实这个函数作用和 <code>setTimeout</code> 基本一致，只是该函数是每隔一段时间执行一次回调函数。</p><p>通常来说不建议使用 <code>setInterval</code>。第一，它和 <code>setTimeout</code> 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="number">2</span>)  &#125;,<span class="number">1000</span>)  sleep(<span class="number">2000</span>)&#125;demo()复制代码</span><br></pre></td></tr></table></figure><p>以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。</p><p>如果有循环定时器的需求，其实完全可以通过 <code>requestAnimationFrame</code> 来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInterval</span>(<span class="params">callback, interval</span>) </span>&#123;  <span class="keyword">let</span> timer  <span class="keyword">const</span> now = <span class="built_in">Date</span>.now  <span class="keyword">let</span> startTime = now()  <span class="keyword">let</span> endTime = startTime  <span class="keyword">const</span> loop = <span class="function">() =&gt;</span> &#123;    timer = <span class="built_in">window</span>.requestAnimationFrame(loop)    endTime = now()    <span class="keyword">if</span> (endTime - startTime &gt;= interval) &#123;      startTime = endTime = now()      callback(timer)    &#125;  &#125;  timer = <span class="built_in">window</span>.requestAnimationFrame(loop)  <span class="keyword">return</span> timer&#125;<span class="keyword">let</span> a = 0<span class="built_in">setInterval</span>(<span class="function"><span class="params">timer</span> =&gt;</span> &#123;  <span class="built_in">console</span>.log(<span class="number">1</span>)  a++  <span class="keyword">if</span> (a === <span class="number">3</span>) cancelAnimationFrame(timer)&#125;, <span class="number">1000</span>)复制代码</span><br></pre></td></tr></table></figure><p>首先 <code>requestAnimationFrame</code> 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 <code>setTimeout</code>。</p><h2 id="八、面向对象"><a href="#八、面向对象" class="headerlink" title="八、面向对象"></a>八、面向对象</h2><h3 id="1-对象创建的方式有哪些？"><a href="#1-对象创建的方式有哪些？" class="headerlink" title="1. 对象创建的方式有哪些？"></a>1. 对象创建的方式有哪些？</h3><p>一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：</p><p>（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</p><p>（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</p><p>（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</p><p>（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</p><p>（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</p><p>（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</p><h3 id="2-对象继承的方式有哪些？"><a href="#2-对象继承的方式有哪些？" class="headerlink" title="2. 对象继承的方式有哪些？"></a>2. 对象继承的方式有哪些？</h3><p>（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p><p>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p><p>（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p><p>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p><p>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。</p><p>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p><h2 id="九、垃圾回收与内存泄漏"><a href="#九、垃圾回收与内存泄漏" class="headerlink" title="九、垃圾回收与内存泄漏"></a>九、垃圾回收与内存泄漏</h2><h3 id="1-浏览器的垃圾回收机制"><a href="#1-浏览器的垃圾回收机制" class="headerlink" title="1. 浏览器的垃圾回收机制"></a>1. 浏览器的垃圾回收机制</h3><h4 id="（1）垃圾回收的概念"><a href="#（1）垃圾回收的概念" class="headerlink" title="（1）垃圾回收的概念"></a>（1）垃圾回收的概念</h4><p><strong>垃圾回收</strong>：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。</p><p><strong>回收机制</strong>：</p><ul><li>Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li><li>JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。</li><li>不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</li></ul><h4 id="（2）垃圾回收的方式"><a href="#（2）垃圾回收的方式" class="headerlink" title="（2）垃圾回收的方式"></a>（2）垃圾回收的方式</h4><p>浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。 <strong>1）标记清除</strong></p><ul><li>标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</li></ul><p><strong>2）引用计数</strong></p><ul><li>另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。</li><li>这种方法会引起<strong>循环引用</strong>的问题：例如：<code> obj1</code>和<code>obj2</code>通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，<code>obj1</code>和<code>obj2</code>还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line">    obj1.a = obj2; <span class="comment">// obj1 引用 obj2</span></span><br><span class="line">    obj2.a = obj1; <span class="comment">// obj2 引用 obj1</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这种情况下，就要手动释放变量占用的内存：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj1.a =  <span class="literal">null</span></span><br><span class="line"> obj2.a =  <span class="literal">null</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="（3）减少垃圾回收"><a href="#（3）减少垃圾回收" class="headerlink" title="（3）减少垃圾回收"></a>（3）减少垃圾回收</h4><p>虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。</p><ul><li><strong>对数组进行优化：</strong> 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。</li><li><strong>对</strong><code>object</code><strong>进行优化：</strong> 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。</li><li><strong>对函数进行优化：</strong> 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</li></ul><h3 id="2-哪些情况会导致内存泄漏"><a href="#2-哪些情况会导致内存泄漏" class="headerlink" title="2. 哪些情况会导致内存泄漏"></a>2. 哪些情况会导致内存泄漏</h3><p>以下四种情况会造成内存的泄漏：</p><ul><li><strong>意外的全局变量：</strong> 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><li><strong>被遗忘的计时器或回调函数：</strong> 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li><strong>脱离 DOM 的引用：</strong> 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li><li><strong>闭包：</strong> 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css面试题整理</title>
      <link href="/2022/03/22/css%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2022/03/22/css%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一、CSS基础"><a href="#一、CSS基础" class="headerlink" title="一、CSS基础"></a>一、CSS基础</h2><h3 id="1-CSS选择器及其优先级"><a href="#1-CSS选择器及其优先级" class="headerlink" title="1. CSS选择器及其优先级"></a>1. CSS选择器及其优先级</h3><table><thead><tr><th><strong>选择器</strong></th><th><strong>格式</strong></th><th><strong>优先级权重</strong></th></tr></thead><tbody><tr><td>id选择器</td><td>#id</td><td>100</td></tr><tr><td>类选择器</td><td>#classname</td><td>10</td></tr><tr><td>属性选择器</td><td>a[ref=“eee”]</td><td>10</td></tr><tr><td>伪类选择器</td><td>li:last-child</td><td>10</td></tr><tr><td>标签选择器</td><td>div</td><td>1</td></tr><tr><td>伪元素选择器</td><td>li:after</td><td>1</td></tr><tr><td>相邻兄弟选择器</td><td>h1+p</td><td>0</td></tr><tr><td>子选择器</td><td>ul&gt;li</td><td>0</td></tr><tr><td>后代选择器</td><td>li a</td><td>0</td></tr><tr><td>通配符选择器</td><td>*</td><td>0</td></tr></tbody></table><p>对于选择器的<strong>优先级</strong>：</p><ul><li>标签选择器、伪元素选择器：1</li><li>类选择器、伪类选择器、属性选择器：10</li><li>id 选择器：100</li><li>内联样式：1000</li></ul><p><strong>注意事项：</strong></p><ul><li>!important声明的样式的优先级最高；</li><li>如果优先级相同，则最后出现的样式生效；</li><li>继承得到的样式的优先级最低；</li><li>通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；</li><li>样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。</li></ul><h3 id="2-CSS中可继承与不可继承属性有哪些"><a href="#2-CSS中可继承与不可继承属性有哪些" class="headerlink" title="2. CSS中可继承与不可继承属性有哪些"></a>2. CSS中可继承与不可继承属性有哪些</h3><p><strong>一、无继承性的属性</strong></p><ol><li><strong>display</strong>：规定元素应该生成的框的类型</li><li><strong>文本属性</strong>：</li></ol><ul><li>vertical-align：垂直文本对齐</li><li>text-decoration：规定添加到文本的装饰</li><li>text-shadow：文本阴影效果</li><li>white-space：空白符的处理</li><li>unicode-bidi：设置文本的方向</li></ul><ol><li><strong>盒子模型的属性</strong>：width、height、margin、border、padding</li><li><strong>背景属性</strong>：background、background-color、background-image、background-repeat、background-position、background-attachment</li><li><strong>定位属性</strong>：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li><li><strong>生成内容属性</strong>：content、counter-reset、counter-increment</li><li><strong>轮廓样式属性</strong>：outline-style、outline-width、outline-color、outline</li><li><strong>页面样式属性</strong>：size、page-break-before、page-break-after</li><li><strong>声音样式属性</strong>：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li></ol><p><strong>二、有继承性的属性</strong></p><ol><li><strong>字体系列属性</strong></li></ol><ul><li>font-family：字体系列</li><li>font-weight：字体的粗细</li><li>font-size：字体的大小</li><li>font-style：字体的风格</li></ul><ol><li><strong>文本系列属性</strong></li></ol><ul><li>text-indent：文本缩进</li><li>text-align：文本水平对齐</li><li>line-height：行高</li><li>word-spacing：单词之间的间距</li><li>letter-spacing：中文或者字母之间的间距</li><li>text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</li><li>color：文本颜色</li></ul><ol><li><strong>元素可见性</strong></li></ol><ul><li>visibility：控制元素显示隐藏</li></ul><ol><li><strong>列表布局属性</strong></li></ol><ul><li>list-style：列表风格，包括list-style-type、list-style-image等</li></ul><ol><li><strong>光标属性</strong></li></ol><ul><li>cursor：光标显示为何种形态</li></ul><h3 id="3-display的属性值及其作用"><a href="#3-display的属性值及其作用" class="headerlink" title="3. display的属性值及其作用"></a>3. display的属性值及其作用</h3><table><thead><tr><th><strong>属性值</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>none</td><td>元素不显示，并且会从文档流中移除。</td></tr><tr><td>block</td><td>块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</td></tr><tr><td>inline</td><td>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</td></tr><tr><td>inline-block</td><td>默认宽度为内容宽度，可以设置宽高，同行显示。</td></tr><tr><td>list-item</td><td>像块类型元素一样显示，并添加样式列表标记。</td></tr><tr><td>table</td><td>此元素会作为块级表格来显示。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承display属性的值。</td></tr></tbody></table><h3 id="4-display的block、inline和inline-block的区别"><a href="#4-display的block、inline和inline-block的区别" class="headerlink" title="4. display的block、inline和inline-block的区别"></a>4. display的block、inline和inline-block的区别</h3><p>（1）<strong>block：</strong> 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p><p>（2）<strong>inline：</strong> 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p><p>（3）<strong>inline-block：</strong> 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p><p>对于行内元素和块级元素，其特点如下：</p><p><strong>（1）行内元素</strong></p><ul><li>设置宽高无效；</li><li>可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li><li>不会自动换行；</li></ul><p><strong>（2）块级元素</strong></p><ul><li>可以设置宽高；</li><li>设置margin和padding都有效；</li><li>可以自动换行；</li><li>多个块状，默认排列从上到下。</li></ul><h3 id="5-隐藏元素的方法有哪些"><a href="#5-隐藏元素的方法有哪些" class="headerlink" title="5. 隐藏元素的方法有哪些"></a>5. 隐藏元素的方法有哪些</h3><ul><li><strong>display: none</strong>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li><li><strong>visibility: hidden</strong>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li><li><strong>opacity: 0</strong>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li><li><strong>position: absolute</strong>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li><li><strong>z-index: 负值</strong>：来使其他元素遮盖住该元素，以此来实现隐藏。</li><li><strong>clip/clip-path</strong> ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li><li>**transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li></ul><h3 id="6-link和-import的区别"><a href="#6-link和-import的区别" class="headerlink" title="6. link和@import的区别"></a>6. link和@import的区别</h3><p>两者都是外部引用CSS的方式，它们的区别如下：</p><ul><li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li><li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li><li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li><li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li></ul><h3 id="7-transition和animation的区别"><a href="#7-transition和animation的区别" class="headerlink" title="7. transition和animation的区别"></a>7. transition和animation的区别</h3><ul><li><strong>transition是过度属性</strong>，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。</li><li><strong>animation是动画属性</strong>，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。</li></ul><h3 id="8-display-none与visibility-hidden的区别"><a href="#8-display-none与visibility-hidden的区别" class="headerlink" title="8. display:none与visibility:hidden的区别"></a>8. display:none与visibility:hidden的区别</h3><p>这两个属性都是让元素隐藏，不可见。<strong>两者区别如下：</strong></p><p>（1）<strong>在渲染树中</strong></p><ul><li><code>display:none</code>会让元素完全从渲染树中消失，渲染时不会占据任何空间；</li><li><code>visibility:hidden</code>不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li></ul><p>（2）<strong>是否是继承属性</strong></p><ul><li><code>display:none</code>是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li><li><code>visibility:hidden</code>是继承属性，子孙节点消失是由于继承了<code>hidden</code>，通过设置<code>visibility:visible</code>可以让子孙节点显示；</li></ul><p>（3）修改常规文档流中元素的 <code>display</code> 通常会造成文档的重排，但是修改<code>visibility</code>属性只会造成本元素的重绘；</p><p>（4）如果使用读屏器，设置为<code>display:none</code>的内容不会被读取，设置为<code>visibility:hidden</code>的内容会被读取。</p><h3 id="9-伪元素和伪类的区别和作用？"><a href="#9-伪元素和伪类的区别和作用？" class="headerlink" title="9. 伪元素和伪类的区别和作用？"></a>9. <strong>伪元素和伪类的区别和作用？</strong></h3><ul><li>伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::before</span> &#123;<span class="attribute">content</span>:<span class="string">&quot;第一章：&quot;</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::after</span> &#123;<span class="attribute">content</span>:<span class="string">&quot;Hot!&quot;</span>;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;<span class="attribute">background</span>:red;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-letter</span> &#123;<span class="attribute">font-size</span>:<span class="number">30px</span>;&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>: <span class="number">#FF00FF</span>&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child &#123;<span class="attribute">color</span>: red&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。</p><h3 id="10-对requestAnimationframe的理解"><a href="#10-对requestAnimationframe的理解" class="headerlink" title="10. 对requestAnimationframe的理解"></a>10. 对requestAnimationframe的理解</h3><p>实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是<strong>请求动画帧</strong>。</p><p>MDN对该方法的描述：</p><blockquote><p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p></blockquote><p><strong>语法：</strong> <code>window.requestAnimationFrame(callback);</code>  其中，callback是<strong>下一次重绘之前更新动画帧所调用的函数</strong>(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于<strong>宏任务</strong>，所以会在执行完微任务之后再去执行。</p><p><strong>取消动画：</strong> 使用cancelAnimationFrame()来取消执行动画，该方法接收一个参数——requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。</p><p><strong>优势：</strong></p><ul><li><strong>CPU节能</strong>：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</li><li><strong>函数节流</strong>：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</li><li><strong>减少DOM操作</strong>：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li></ul><p><strong>setTimeout执行动画的缺点</strong>：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：</p><ul><li>settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；</li><li>settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。</li></ul><h3 id="11-对盒模型的理解"><a href="#11-对盒模型的理解" class="headerlink" title="11. 对盒模型的理解"></a>11. 对盒模型的理解</h3><p>CSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型 <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221922521.webp" alt="img"> <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221922252.webp" alt="img"> 盒模型都是由四个部分组成的，分别是margin、border、padding和content。</p><p>标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：</p><ul><li>标准盒模型的width和height属性的范围只包含了content，</li><li>IE盒模型的width和height属性的范围包含了border、padding和content。</li></ul><p>可以通过修改元素的box-sizing属性来改变元素的盒模型：</p><ul><li><code>box-sizeing: content-box</code>表示标准盒模型（默认值）</li><li><code>box-sizeing: border-box</code>表示IE盒模型（怪异盒模型）</li></ul><h3 id="12-为什么有时候⽤translate来改变位置⽽不是定位？"><a href="#12-为什么有时候⽤translate来改变位置⽽不是定位？" class="headerlink" title="12. 为什么有时候⽤translate来改变位置⽽不是定位？"></a>12. 为什么有时候⽤<strong>translate</strong>来改变位置⽽不是定位？</h3><p>translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p><h3 id="13-li-与-li-之间有看不见的空白间隔是什么原因引起的？如何解决？"><a href="#13-li-与-li-之间有看不见的空白间隔是什么原因引起的？如何解决？" class="headerlink" title="13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？"></a>13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？</h3><p>浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个<code>&lt;li&gt;</code>放在一行，这导致<code>&lt;li&gt;</code>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</p><p><strong>解决办法：</strong></p><p>（1）为<code>&lt;li&gt;</code>设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</p><p>（2）将所有<code>&lt;li&gt;</code>写在同一行。不足：代码不美观。</p><p>（3）将<code>&lt;ul&gt;</code>内的字符尺寸直接设为0，即font-size:0。不足：<code>&lt;ul&gt;</code>中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。</p><p>（4）消除<code>&lt;ul&gt;</code>的字符间隔letter-spacing:-8px，不足：这也设置了<code>&lt;li&gt;</code>内的字符间隔，因此需要将<code>&lt;li&gt;</code>内的字符间隔设为默认letter-spacing:normal。</p><h3 id="14-CSS3中有哪些新特性"><a href="#14-CSS3中有哪些新特性" class="headerlink" title="14. CSS3中有哪些新特性"></a>14. CSS3中有哪些新特性</h3><ul><li>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</li><li>圆角 （border-radius:8px）</li><li>多列布局 （multi-column layout）</li><li>阴影和反射 （Shadoweflect）</li><li>文字特效 （text-shadow）</li><li>文字渲染 （Text-decoration）</li><li>线性渐变 （gradient）</li><li>旋转 （transform）</li><li>增加了旋转,缩放,定位,倾斜,动画,多背景</li></ul><h3 id="15-替换元素的概念及计算规则"><a href="#15-替换元素的概念及计算规则" class="headerlink" title="15. 替换元素的概念及计算规则"></a>15. 替换元素的概念及计算规则</h3><p>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。</p><p>替换元素除了内容可替换这一特性以外，还有以下特性：</p><ul><li><strong>内容的外观不受页面上的CSS的影响</strong>：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。</li><li><strong>有自己的尺寸</strong>：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如</li><li><strong>在很多CSS属性上有自己的一套表现规则</strong>：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</li><li><strong>所有的替换元素都是内联水平元素</strong>：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。</li></ul><p>替换元素的尺寸从内而外分为三类：</p><ul><li><strong>固有尺寸：</strong> 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</li><li><strong>HTML尺寸：</strong> 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、的size属性。</li><li><strong>CSS尺寸：</strong> 特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的尺寸，对应盒尺寸中的content box。</li></ul><p>这三层结构的计算规则具体如下： （1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。 （2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。 （3）如果有CSS尺寸，则最终尺寸由CSS属性决定。 （4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。 （5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。 （6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</p><h3 id="16-常见的图片格式及使用场景"><a href="#16-常见的图片格式及使用场景" class="headerlink" title="16. 常见的图片格式及使用场景"></a>16. 常见的图片格式及使用场景</h3><p>（1）<strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</p><p>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</p><p>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p><p>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</p><p>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</p><p>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。</p><p>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul><h3 id="17-对-CSSSprites-的理解"><a href="#17-对-CSSSprites-的理解" class="headerlink" title="17. 对 CSSSprites 的理解"></a>17. 对 CSSSprites 的理解</h3><p>CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p><p><strong>优点：</strong></p><ul><li>利用<code>CSS Sprites</code>能很好地减少网页的http请求，从而大大提高了页面的性能，这是<code>CSS Sprites</code>最大的优点；</li><li><code>CSS Sprites</code>能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li></ul><p><strong>缺点：</strong></p><ul><li>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li><li><code>CSSSprites</code>在开发的时候相对来说有点麻烦，需要借助<code>photoshop</code>或其他工具来对每个背景单元测量其准确的位置。</li><li>维护方面：<code>CSS Sprites</code>在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的<code>CSS</code>，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动<code>CSS</code>。</li></ul><h3 id="18-什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？"><a href="#18-什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？" class="headerlink" title="18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？"></a>18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？</h3><p>以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px &amp; 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；</p><p>而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242/414=3，也就是说，在单边上，一个逻辑像素=3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。</p><p>对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。 <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221922062.webp" alt="img"> 当然，也可以针对所有屏幕，都只提供最高清图片。虽然低密度屏幕用不到那么多图片像素，而且会因为下载多余的像素造成带宽浪费和下载延迟，但从结果上说能保证图片在所有屏幕上都不会失真。</p><p>还可以使用 CSS 媒体查询来判断不同的像素密度，从而选择不同的图片:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my-image &#123; <span class="attr">background</span>: (low.png); &#125;</span><br><span class="line">@media only screen and (min-device-pixel-ratio: <span class="number">1.5</span>) &#123;</span><br><span class="line">  #my-image &#123; <span class="attr">background</span>: (high.png); &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="19-margin-和-padding-的使用场景"><a href="#19-margin-和-padding-的使用场景" class="headerlink" title="19. margin 和 padding 的使用场景"></a>19. <strong>margin 和 padding 的使用场景</strong></h3><ul><li>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</li><li>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</li></ul><h3 id="20-对line-height-的理解及其赋值方式"><a href="#20-对line-height-的理解及其赋值方式" class="headerlink" title="20. 对line-height 的理解及其赋值方式"></a>20. 对<strong>line-height 的理解及其赋值方式</strong></h3><p><strong>（1）line-height的概念：</strong></p><ul><li>line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；</li><li>如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；</li><li>一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；</li><li>把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；</li><li>line-height 和 height 都能撑开一个高度；</li></ul><p><strong>（2）line-height 的赋值方式：</strong></p><ul><li>带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li><li>纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px</li><li>百分比：将计算后的值传递给后代</li></ul><h3 id="21-CSS-优化和提高性能的方法有哪些？"><a href="#21-CSS-优化和提高性能的方法有哪些？" class="headerlink" title="21. CSS 优化和提高性能的方法有哪些？"></a>21. CSS 优化和提高性能的方法有哪些？</h3><p><strong>加载性能：</strong></p><p>（1）css压缩：将写好的css进行打包压缩，可以减小文件体积。</p><p>（2）css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。</p><p>（3）减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</p><p><strong>选择器性能：</strong></p><p>（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</p><p>（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</p><p>（3）避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。</p><p>（4）尽量少的去对标签进行选择，而是用class。</p><p>（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</p><p>（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</p><p><strong>渲染性能：</strong></p><p>（1）慎重使用高性能属性：浮动、定位。</p><p>（2）尽量减少页面重排、重绘。</p><p>（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</p><p>（4）属性值为0时，不加单位。</p><p>（5）属性值为浮动小数0.**，可以省略小数点之前的0。</p><p>（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</p><p>（7）不使用@import前缀，它会影响css的加载速度。</p><p>（8）选择器优化嵌套，尽量避免层级过深。</p><p>（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</p><p>（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</p><p>（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</p><p><strong>可维护性、健壮性：</strong></p><p>（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</p><p>（2）样式与内容分离：将css代码定义到外部css中。</p><h3 id="22-CSS预处理器-后处理器是什么？为什么要使用它们？"><a href="#22-CSS预处理器-后处理器是什么？为什么要使用它们？" class="headerlink" title="22. CSS预处理器/后处理器是什么？为什么要使用它们？"></a>22. CSS预处理器/后处理器是什么？为什么要使用它们？</h3><p><strong>预处理器，</strong> 如：<code>less</code>，<code>sass</code>，<code>stylus</code>，用来预编译<code>sass</code>或者<code>less</code>，增加了<code>css</code>代码的复用性。层级，<code>mixin</code>， 变量，循环， 函数等对编写以及开发UI组件都极为方便。</p><p><strong>后处理器，</strong> 如： <code>postCss</code>，通常是在完成的样式表中根据<code>css</code>规范处理<code>css</code>，让其更加有效。目前最常做的是给<code>css</code>属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p><p><code>css</code>预处理器为<code>css</code>增加一些编程特性，无需考虑浏览器的兼容问题，可以在<code>CSS</code>中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让<code>css</code>更加的简洁，增加适应性以及可读性，可维护性等。</p><p>其它<code>css</code>预处理器语言：<code>Sass（Scss）</code>, <code>Less</code>, <code>Stylus</code>, <code>Turbine</code>, <code>Swithch css</code>, <code>CSS Cacheer</code>, <code>DT Css</code>。</p><p>使用原因：</p><ul><li>结构清晰， 便于扩展</li><li>可以很方便的屏蔽浏览器私有语法的差异</li><li>可以轻松实现多重继承</li><li>完美的兼容了<code>CSS</code>代码，可以应用到老项目中</li></ul><h3 id="23-before-和-after-的双冒号和单冒号有什么区别？"><a href="#23-before-和-after-的双冒号和单冒号有什么区别？" class="headerlink" title="23. ::before 和 :after 的双冒号和单冒号有什么区别？"></a>23. ::before 和 :after 的双冒号和单冒号有什么区别？</h3><p>（1）冒号(<code>:</code>)用于<code>CSS3</code>伪类，双冒号(<code>::</code>)用于<code>CSS3</code>伪元素。 （2）<code>::before</code>就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于<code>dom</code>之中，只存在在页面之中。</p><p><strong>注意：</strong> <code>:before </code>和 <code>:after</code> 这两个伪元素，是在<code>CSS2.1</code>里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着<code>Web</code>的进化，在<code>CSS3</code>的规范里，伪元素的语法被修改成使用双冒号，成为<code>::before</code>、<code>::after</code>。</p><h3 id="24-display-inline-block-什么时候会显示间隙？"><a href="#24-display-inline-block-什么时候会显示间隙？" class="headerlink" title="24. display:inline-block 什么时候会显示间隙？"></a>24. display:inline-block 什么时候会显示间隙？</h3><ul><li>有空格时会有间隙，可以删除空格解决；</li><li><code>margin</code>正值时，可以让<code>margin</code>使用负值解决；</li><li>使用<code>font-size</code>时，可通过设置<code>font-size:0</code>、<code>letter-spacing</code>、<code>word-spacing</code>解决；</li></ul><h3 id="25-单行、多行文本溢出隐藏"><a href="#25-单行、多行文本溢出隐藏" class="headerlink" title="25. 单行、多行文本溢出隐藏"></a>25. 单行、多行文本溢出隐藏</h3><ul><li>单行文本溢出</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;      // 溢出用省略号显示</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;         // 规定段落中的文本不进行换行</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>多行文本溢出</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;     // 溢出用省略号显示</span><br><span class="line"><span class="attribute">display</span>:-webkit-box;         // 作为弹性伸缩盒子模型显示。</span><br><span class="line">-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列</span><br><span class="line">-webkit-line-clamp:<span class="number">3</span>;        // 显示的行数</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个<code>-webkit-</code> 来兼容一部分浏览器。</p><h3 id="26-Sass、Less-是什么？为什么要使用他们？"><a href="#26-Sass、Less-是什么？为什么要使用他们？" class="headerlink" title="26. Sass、Less 是什么？为什么要使用他们？"></a>26. Sass、Less 是什么？为什么要使用他们？</h3><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法/语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。</p><p><strong>为什么要使用它们？</strong></p><ul><li>结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。</li><li>可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li></ul><h3 id="27-对媒体查询的理解？"><a href="#27-对媒体查询的理解？" class="headerlink" title="27. 对媒体查询的理解？"></a>27. 对媒体查询的理解？</h3><p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。</p><p>媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- link元素中的CSS媒体查询 --&gt; </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(max-width: 800px)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;example.css&quot;</span> /&gt;</span></span> </span><br><span class="line">&lt;!-- 样式表中的CSS媒体查询 --&gt; </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"> </span></span></span><br><span class="line"><span class="css"><span class="xml"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123; </span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="selector-class">.facet_sidebar</span> &#123; </span></span></span><br><span class="line"><span class="css"><span class="xml">    <span class="attribute">display</span>: none; </span></span></span><br><span class="line"><span class="css"><span class="xml">  &#125; </span></span></span><br><span class="line"><span class="css"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>简单来说，使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</p><h3 id="28-对-CSS-工程化的理解"><a href="#28-对-CSS-工程化的理解" class="headerlink" title="28. 对 CSS 工程化的理解"></a>28. 对 CSS 工程化的理解</h3><p>CSS 工程化是为了解决以下问题：</p><ol><li><strong>宏观设计</strong>：CSS 代码如何组织、如何拆分、模块结构怎样设计？</li><li><strong>编码优化</strong>：怎样写出更好的 CSS？</li><li><strong>构建</strong>：如何处理我的 CSS，才能让它的打包结果最优？</li><li><strong>可维护性</strong>：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？</li></ol><p>以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：</p><ul><li>预处理器：Less、 Sass 等；</li><li>重要的工程化插件： PostCss；</li><li>Webpack loader 等 。</li></ul><p>基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：</p><p><strong>（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？</strong></p><p>预处理器，其实就是 CSS 世界的“轮子”。预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码： <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221922321.webp" alt="img"> 那为什么写 CSS 代码写得好好的，偏偏要转去写“类 CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：</p><ol><li>宏观设计上：我们希望能优化 CSS 文件的目录结构，对现有的 CSS 文件实现复用；</li><li>编码优化上：我们希望能写出结构清晰、简明易懂的 CSS，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码；</li><li>可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。</li></ol><p>这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：</p><ul><li>嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；</li><li>支持定义 css 变量；</li><li>提供计算函数；</li><li>允许对代码片段进行 extend 和 mixin；</li><li>支持循环语句的使用；</li><li>支持将 CSS 文件模块化，实现复用。</li></ul><p><strong>（2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？</strong></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221921579.webp" alt="img"> 它和预处理器的不同就在于，预处理器处理的是 类CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。</p><p>PostCss 在业务中的使用场景非常多：</p><ul><li>提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；</li><li>当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 <a href="https://link.juejin.cn/?target=https://github.com/postcss/autoprefixer">Autoprefixer</a> 插件可以帮助我们自动增加浏览器前缀；</li><li>允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；</li></ul><p><strong>（3）Webpack 能处理 CSS 吗？如何实现？</strong> Webpack 能处理 CSS 吗：</p><ul><li><strong>Webpack 在裸奔的状态下，是不能处理 CSS 的</strong>，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；</li><li>Webpack 在 loader 的辅助下，是可以处理 CSS 的。</li></ul><p>如何用 Webpack 实现对 CSS 的处理：</p><ul><li>Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader</li><li>注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：<ul><li>css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；</li><li>style-loader：创建style标签，把 CSS 内容写入标签。</li></ul></li></ul><p>在实际使用中，<strong>css-loader 的执行顺序一定要安排在 style-loader 的前面</strong>。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。</p><h3 id="29-如何判断元素是否到达可视区域"><a href="#29-如何判断元素是否到达可视区域" class="headerlink" title="29. 如何判断元素是否到达可视区域"></a>29. 如何判断元素是否到达可视区域</h3><p>以图片显示为例：</p><ul><li><code>window.innerHeight</code> 是浏览器可视区的高度；</li><li><code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离；</li><li><code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）；</li><li>内容达到显示区域的：<code>img.offsetTop &lt; window.innerHeight + document.body.scrollTop;</code></li></ul><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221922007.webp" alt="img"></p><h3 id="30-z-index属性在什么情况下会失效"><a href="#30-z-index属性在什么情况下会失效" class="headerlink" title="30. z-index属性在什么情况下会失效"></a>30. z-index属性在什么情况下会失效</h3><p>通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。</p><p>z-index属性在下列情况下会失效：</p><ul><li>父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；</li><li>元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；</li><li>元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；</li></ul><h3 id="31-CSS3中的transform有哪些属性"><a href="#31-CSS3中的transform有哪些属性" class="headerlink" title="31. CSS3中的transform有哪些属性"></a>31. CSS3中的transform有哪些属性</h3><h2 id="二、页面布局"><a href="#二、页面布局" class="headerlink" title="二、页面布局"></a>二、页面布局</h2><h3 id="1-常见的CSS布局单位"><a href="#1-常见的CSS布局单位" class="headerlink" title="1. 常见的CSS布局单位"></a>1. 常见的CSS布局单位</h3><p>常用的布局单位包括像素（<code>px</code>），百分比（<code>%</code>），<code>em</code>，<code>rem</code>，<code>vw/vh</code>。</p><p><strong>（1）像素</strong>（<code>px</code>）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：</p><ul><li><strong>CSS像素</strong>：为web开发者提供，在CSS中使用的一个抽象单位；</li><li><strong>物理像素</strong>：只与设备的硬件密度有关，任何设备的物理像素都是固定的。</li></ul><p><strong>（2）百分比</strong>（<code>%</code>），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</p><p><strong>（3）em和rem</strong>相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：<strong>em相对于父元素，rem相对于根元素。</strong></p><ul><li><strong>em：</strong> 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。</li><li><strong>rem：</strong> rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。<strong>作用</strong>：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。</li></ul><p><strong>（4）vw/vh</strong>是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p><ul><li>vw：相对于视窗的宽度，视窗宽度是100vw；</li><li>vh：相对于视窗的高度，视窗高度是100vh；</li><li>vmin：vw和vh中的较小值；</li><li>vmax：vw和vh中的较大值；</li></ul><p><strong>vw/vh</strong> 和百分比很类似，两者的区别：</p><ul><li>百分比（<code>%</code>）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</li><li>vw/vm：相对于视窗的尺寸</li></ul><h3 id="2-px、em、rem的区别及使用场景"><a href="#2-px、em、rem的区别及使用场景" class="headerlink" title="2. px、em、rem的区别及使用场景"></a>2. px、em、rem的区别及使用场景</h3><p><strong>三者的区别：</strong></p><ul><li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li><li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li><li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li></ul><p><strong>使用场景：</strong></p><ul><li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li><li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li></ul><h3 id="3-两栏布局的实现"><a href="#3-两栏布局的实现" class="headerlink" title="3. 两栏布局的实现"></a>3. 两栏布局的实现</h3><p>一般两栏布局指的是<strong>左边一栏宽度固定，右边一栏宽度自适应</strong>，两栏布局的具体实现：</p><ul><li>利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">     <span class="attribute">background</span>: red;</span><br><span class="line">     <span class="attribute">float</span>: left;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.right</span>&#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">     <span class="attribute">background</span>: blue;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line"> &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="4-三栏布局的实现"><a href="#4-三栏布局的实现" class="headerlink" title="4. 三栏布局的实现"></a>4. 三栏布局的实现</h3><p>三栏布局一般指的是页面中一共有三栏，<strong>左右两栏宽度固定，中间自适应的布局</strong>，三栏布局的具体实现：</p><ul><li>利用<strong>绝对定位</strong>，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式<strong>，中间一栏必须放到最后：</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="5-水平垂直居中的实现"><a href="#5-水平垂直居中的实现" class="headerlink" title="5. 水平垂直居中的实现"></a>5. 水平垂直居中的实现</h3><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要<strong>考虑浏览器兼容问题。</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;    <span class="attribute">position</span>: relative;&#125; <span class="selector-class">.child</span> &#123;    <span class="attribute">position</span>: absolute;    <span class="attribute">left</span>: <span class="number">50%</span>;    <span class="attribute">top</span>: <span class="number">50%</span>;    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>,-<span class="number">50%</span>);&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于<strong>盒子有宽高</strong>的情况：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于<strong>盒子宽高已知</strong>的情况</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;     <span class="comment">/* 自身 height 的一半 */</span></span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;    <span class="comment">/* 自身 width 的一半 */</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要<strong>考虑兼容的问题</strong>，该方法在移动端用的较多：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>:center;</span><br><span class="line">    <span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="6-如何根据设计稿进行移动端适配？"><a href="#6-如何根据设计稿进行移动端适配？" class="headerlink" title="6. 如何根据设计稿进行移动端适配？"></a>6. 如何根据设计稿进行移动端适配？</h3><p>移动端适配主要有两个维度：</p><ul><li><strong>适配不同像素密度，</strong> 针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li><li><strong>适配不同屏幕大小，</strong> 由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li></ul><p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p><h3 id="7-对Flex布局的理解及其使用场景"><a href="#7-对Flex布局的理解及其使用场景" class="headerlink" title="7. 对Flex布局的理解及其使用场景"></a>7. 对Flex布局的理解及其使用场景</h3><p>Flex是FlexibleBox的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，<strong>子元素的float、clear和vertical-align属性将失效</strong>。采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。</p><p>以下6个属性设置在<strong>容器上</strong>：</p><ul><li>flex-direction属性决定主轴的方向（即项目的排列方向）。</li><li>flex-wrap属性定义，如果一条轴线排不下，如何换行。</li><li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</li><li>justify-content属性定义了项目在主轴上的对齐方式。</li><li>align-items属性定义项目在交叉轴上如何对齐。</li><li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li></ul><p>以下6个属性设置在<strong>项目上</strong>：</p><ul><li>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li><li>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li><li>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li><li>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li><li>flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li><li>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li></ul><p><strong>简单来说：</strong> flex布局是CSS3新增的一种布局方式，可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用flex-direction来指定主轴的方向。可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</p><h3 id="8-响应式设计的概念及基本原理"><a href="#8-响应式设计的概念及基本原理" class="headerlink" title="8. 响应式设计的概念及基本原理"></a>8. 响应式设计的概念及基本原理</h3><p>响应式网站设计<code>（Responsive Web design</code>）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p><p>关于原理： 基本原理是通过媒体查询<code>（@media）</code>查询检测不同的设备屏幕尺寸做处理。 关于兼容： 页面头部必须有mate声明的<code>viewport</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;’viewport’&quot;</span> <span class="attr">content</span>=<span class="string">&quot;”width=device-width,&quot;</span> <span class="attr">initial-scale</span>=<span class="string">&quot;1.&quot;</span> <span class="attr">maximum-scale</span>=<span class="string">&quot;1,user-scalable=no”&quot;</span>/&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="三、定位与浮动"><a href="#三、定位与浮动" class="headerlink" title="三、定位与浮动"></a>三、定位与浮动</h2><h3 id="1-为什么需要清除浮动？清除浮动的方式"><a href="#1-为什么需要清除浮动？清除浮动的方式" class="headerlink" title="1. 为什么需要清除浮动？清除浮动的方式"></a>1. 为什么需要清除浮动？清除浮动的方式</h3><p><strong>浮动的定义：</strong> 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</p><p><strong>浮动的工作原理：</strong></p><ul><li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li><li>浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li></ul><p>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。</p><p><strong>浮动元素引起的问题？</strong></p><ul><li>父元素的高度无法被撑开，影响与父元素同级的元素</li><li>与浮动元素同级的非浮动元素会跟随其后</li><li>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li></ul><p><strong>清除浮动的方式如下：</strong></p><ul><li>给父级div定义<code>height</code>属性</li><li>最后一个浮动元素之后添加一个空的div标签，并添加<code>clear:both</code>样式</li><li>包含浮动元素的父级标签添加<code>overflow:hidden</code>或者<code>overflow:auto</code></li><li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span>:after&#123;</span><br><span class="line">    content: <span class="string">&quot;\200B&quot;</span>;</span><br><span class="line">    <span class="attribute">display</span>: table; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    *zoom: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="2-使用-clear-属性清除浮动的原理？"><a href="#2-使用-clear-属性清除浮动的原理？" class="headerlink" title="2. 使用 clear 属性清除浮动的原理？"></a>2. 使用 clear 属性清除浮动的原理？</h3><p>使用clear属性清除浮动，其语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">clear</span>:none|left|right|both</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。</p><p>官方对clear属性解释：“<strong>元素盒子的边不能和前面的浮动元素相邻</strong>”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。</p><p>还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“<strong>前面的</strong>”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</p><p>一般使用伪元素的方式清除浮动：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">::after</span>&#123;  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;  <span class="attribute">display</span>: block;   <span class="attribute">clear</span>:both;&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。</p><h3 id="3-对BFC的理解，如何创建BFC"><a href="#3-对BFC的理解，如何创建BFC" class="headerlink" title="3. 对BFC的理解，如何创建BFC"></a>3. 对BFC的理解，如何创建BFC</h3><p>先来看两个相关的概念：</p><ul><li>Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。</li><li>Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。</li></ul><p>块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p><p>通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</p><p><strong>创建BFC的条件：</strong></p><ul><li>根元素：body；</li><li>元素设置浮动：float 除 none 以外的值；</li><li>元素设置绝对定位：position (absolute、fixed)；</li><li>display 值为：inline-block、table-cell、table-caption、flex等；</li><li>overflow 值为：hidden、auto、scroll；</li></ul><p><strong>BFC的特点：</strong></p><ul><li>垂直方向上，自上而下排列，和文档流的排列方式一致。</li><li>在BFC中上下相邻的两个容器的margin会重叠</li><li>计算BFC的高度时，需要计算浮动元素的高度</li><li>BFC区域不会与浮动的容器发生重叠</li><li>BFC是独立的容器，容器内部元素不会影响外部元素</li><li>每个元素的左margin值和容器的左border相接触</li></ul><p><strong>BFC的作用：</strong></p><ul><li><strong>解决margin的重叠问题</strong>：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。</li><li><strong>解决高度塌陷的问题</strong>：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置<code>overflow:hidden</code>。</li><li><strong>创建自适应两栏布局</strong>：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">     <span class="attribute">background</span>: red;</span><br><span class="line">     <span class="attribute">float</span>: left;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.right</span>&#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">     <span class="attribute">background</span>: blue;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">left</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">right</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>左侧设置<code>float:left</code>，右侧设置<code>overflow: hidden</code>。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</p><h3 id="4-什么是margin重叠问题？如何解决？"><a href="#4-什么是margin重叠问题？如何解决？" class="headerlink" title="4. 什么是margin重叠问题？如何解决？"></a>4. 什么是margin重叠问题？如何解决？</h3><p><strong>问题描述：</strong> 两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，<strong>浮动的元素和绝对定位</strong>这种脱离文档流的元素的外边距不会折叠。重叠只会出现在<strong>垂直方向</strong>。</p><p><strong>计算原则：</strong> 折叠合并后外边距的计算原则如下：</p><ul><li>如果两者都是正数，那么就去最大者</li><li>如果是一正一负，就会正值减去负值的绝对值</li><li>两个都是负值时，用0减去两个中绝对值大的那个</li></ul><p><strong>解决办法：</strong> 对于折叠的情况，主要有两种：<strong>兄弟之间重叠</strong>和<strong>父子之间重叠</strong> （1）兄弟之间重叠</p><ul><li>底部元素变为行内盒子：<code>display: inline-block</code></li><li>底部元素设置浮动：<code>float</code></li><li>底部元素的position的值为<code>absolute/fixed</code></li></ul><p>（2）父子之间重叠</p><ul><li>父元素加入：<code>overflow: hidden</code></li><li>父元素添加透明边框：<code>border:1px solid transparent</code></li><li>子元素变为行内盒子：<code>display: inline-block</code></li><li>子元素加入浮动属性或定位</li></ul><h3 id="5-元素的层叠顺序"><a href="#5-元素的层叠顺序" class="headerlink" title="5. 元素的层叠顺序"></a>5. 元素的层叠顺序</h3><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则： <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221922320.webp" alt="img"> 对于上图，由上到下分别是： （1）背景和边框：建立当前层叠上下文元素的背景和边框。 （2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。 （3）块级盒：文档流内非行内级非定位后代元素。 （4）浮动盒：非定位浮动元素。 （5）行内盒：文档流内行内级非定位后代元素。 （6）z-index:0：层叠级数为0的定位元素。 （7)正z-index：z-index属性值为正的定位元素。</p><p><strong>注意:</strong> 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。</p><h3 id="6-position的属性有哪些，区别是什么"><a href="#6-position的属性有哪些，区别是什么" class="headerlink" title="6. position的属性有哪些，区别是什么"></a>6. position的属性有哪些，区别是什么</h3><p>position有以下属性值：</p><table><thead><tr><th>属性值</th><th>概述</th></tr></thead><tbody><tr><td>absolute</td><td>生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>relative</td><td>生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>fixed</td><td>生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。</td></tr><tr><td>static</td><td>默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。</td></tr><tr><td>inherit</td><td>规定从父元素继承position属性的值</td></tr></tbody></table><p>前面三者的定位方式如下：</p><ul><li><strong>relative：</strong> 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</li></ul><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221921935.webp" alt="img"></p><ul><li><strong>fixed：</strong> 元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</li></ul><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221922602.webp" alt="img"></p><ul><li><strong>absolute：</strong> 元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：</li></ul><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221922208.webp" alt="img"> <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221922865.webp" alt="img"></p><h3 id="7-display、float、position的关系"><a href="#7-display、float、position的关系" class="headerlink" title="7. display、float、position的关系"></a>7. <strong>display、float、position的关系</strong></h3><p>（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</p><p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</p><p>（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</p><p>（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</p><p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p><h3 id="8-absolute与fixed共同点与不同点"><a href="#8-absolute与fixed共同点与不同点" class="headerlink" title="8. absolute与fixed共同点与不同点"></a>8. absolute与fixed共同点与不同点</h3><p><strong>共同点：</strong></p><ul><li>改变行内元素的呈现方式，将display置为inline-block </li><li>使元素脱离普通文档流，不再占据文档物理空间</li><li>覆盖非定位文档元素</li></ul><p><strong>不同点：</strong></p><ul><li>abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。</li><li>在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。</li></ul><h3 id="9-对-sticky-定位的理解"><a href="#9-对-sticky-定位的理解" class="headerlink" title="9. 对 sticky 定位的理解"></a>9. 对 sticky 定位的理解</h3><p>sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：<strong>position: sticky;</strong> 基于用户的滚动位置来定位。</p><p>粘性定位的元素是依赖于用户的滚动，在 <strong>position:relative</strong> 与 <strong>position:fixed</strong> 定位之间切换。它的行为就像 <strong>position:relative;</strong> 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p><h2 id="四、场景应用"><a href="#四、场景应用" class="headerlink" title="四、场景应用"></a>四、场景应用</h2><h3 id="1-实现一个三角形"><a href="#1-实现一个三角形" class="headerlink" title="1. 实现一个三角形"></a>1. 实现一个三角形</h3><p>CSS绘制三角形主要用到的是border属性，也就是边框。</p><p>平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是右三角形组成的，下面看一个例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">100px</span> solid;</span><br><span class="line">    <span class="attribute">border-color</span>: orange blue red green;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>将元素的长宽都设置为0，显示出来的效果是这样的： <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221921284.webp" alt="img"> 所以可以根据border这个特性来绘制三角形： <strong>（1)三角1</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;    <span class="attribute">width</span>: <span class="number">0</span>;    <span class="attribute">height</span>: <span class="number">0</span>;    <span class="attribute">border-top</span>: <span class="number">50px</span> solid red;    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221921643.webp" alt="img"> <strong>（2)三角2</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid red;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221921447.webp" alt="img"> <strong>（3)三角3</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid red;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221921993.webp" alt="img"> <strong>（4)三角4</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid red;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221921400.webp" alt="img"> <strong>（5)三角5</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">100px</span> solid red;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221921065.webp" alt="img"> 还有很多，就不一一实现了，总体的原则就是通过上下左右边框来控制三角形的方向，用边框的宽度比来控制三角形的角度。</p><h3 id="2-实现一个扇形"><a href="#2-实现一个扇形" class="headerlink" title="2. 实现一个扇形"></a>2. 实现一个扇形</h3><p>用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    heigt: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border-top-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221921625.webp" alt="img"></p><h3 id="3-实现一个宽高自适应的正方形"><a href="#3-实现一个宽高自适应的正方形" class="headerlink" title="3. 实现一个宽高自适应的正方形"></a>3. 实现一个宽高自适应的正方形</h3><ul><li>利用vw来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10vw</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>利用元素的margin/padding百分比是相对父元素width的性质来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>利用子元素的margin-top的值来实现：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.square</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="4-画一条0-5px的线"><a href="#4-画一条0-5px的线" class="headerlink" title="4. 画一条0.5px的线"></a>4. 画一条0.5px的线</h3><ul><li><strong>采用transform: scale()的方式</strong>，该方法用来定义元素的2D 缩放转换：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>采用meta viewport的方式</strong></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; <span class="attribute">content</span>=&quot;<span class="attribute">width</span>=device-<span class="attribute">width</span>, <span class="attribute">initial</span>-scale=<span class="number">0.5</span>, minimum-scale=<span class="number">0.5</span>, maximum-scale=<span class="number">0.5</span>&quot;/&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果</p><h3 id="5-设置小于12px的字体"><a href="#5-设置小于12px的字体" class="headerlink" title="5. 设置小于12px的字体"></a>5. 设置小于12px的字体</h3><p>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</p><p><strong>解决办法：</strong></p><ul><li>使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</li><li>使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/inline-block/…；</li><li>使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</li></ul><h3 id="6-如何解决-1px-问题？"><a href="#6-如何解决-1px-问题？" class="headerlink" title="6. 如何解决 1px 问题？"></a>6. 如何解决 1px 问题？</h3><p>1px 问题指的是：在一些 <code>Retina屏幕</code> 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.devicePixelRatio = 设备的物理像素 / CSS像素。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 <code>devicePixelRatio</code> 的值。这里选中 iPhone6/7/8 这系列的机型，输出的结果就是2： <img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203221921167.webp" alt="img"> 这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。 <strong>解决1px 问题的三种思路：</strong></p><h4 id="思路一：直接写-0-5px"><a href="#思路一：直接写-0-5px" class="headerlink" title="思路一：直接写 0.5px"></a>思路一：直接写 0.5px</h4><p>如果之前 1px 的样式这样写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#333</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;container&quot;</span> data-device=&#123;&#123;<span class="built_in">window</span>.devicePixelRatio&#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为2的情况：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">0.5px</span> solid <span class="number">#333</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>直接把 1px 改成 1/devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。</p><h4 id="思路二：伪元素先放大后缩小"><a href="#思路二：伪元素先放大后缩小" class="headerlink" title="思路二：伪元素先放大后缩小"></a>思路二：伪元素先放大后缩小</h4><p>这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。</p><p>思路是<strong>先放大、后缩小：在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的宽和高都设置为目标元素的两倍，border值设为 1px。接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一，间接地实现了 0.5px 的效果。</strong></p><p>代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#container</span><span class="selector-attr">[data-device=<span class="string">&quot;2&quot;</span>]</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">      <span class="attribute">position</span>:absolute;</span><br><span class="line">      <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">      <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">      <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);</span><br><span class="line">      <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">      <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="思路三：viewport-缩放来解决"><a href="#思路三：viewport-缩放来解决" class="headerlink" title="思路三：viewport 缩放来解决"></a>思路三：viewport 缩放来解决</h4><p>这个思路就是对 meta 标签里几个关键属性下手：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这里针对像素比为2的页面，把整个页面缩放为了原来的1/2大小。这样，本来占用2个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scale = <span class="number">1</span> / <span class="built_in">window</span>.devicePixelRatio;</span><br><span class="line"><span class="comment">// 这里 metaEl 指的是 meta 标签对应的 Dom</span></span><br><span class="line">metaEl.setAttribute(<span class="string">&#x27;content&#x27;</span>, <span class="string">`width=device-width,user-scalable=no,initial-scale=<span class="subst">$&#123;scale&#125;</span>,maximum-scale=<span class="subst">$&#123;scale&#125;</span>,minimum-scale=<span class="subst">$&#123;scale&#125;</span>`</span>);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue面试题整理</title>
      <link href="/2022/03/19/vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2022/03/19/vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1、说说你对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#1、说说你对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？"></a>1、说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h2><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><p><strong>优点：</strong></p><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul><p><strong>缺点：</strong></p><ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul><h2 id="2、v-show-与-v-if-有什么区别？"><a href="#2、v-show-与-v-if-有什么区别？" class="headerlink" title="2、v-show 与 v-if 有什么区别？"></a>2、v-show 与 v-if 有什么区别？</h2><p><strong>v-if</strong> 是<strong>真正</strong>的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p><strong>v-show</strong> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。</p><p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><h2 id="3、Class-与-Style-如何动态绑定？"><a href="#3、Class-与-Style-如何动态绑定？" class="headerlink" title="3、Class 与 Style 如何动态绑定？"></a>3、Class 与 Style 如何动态绑定？</h2><p>Class 可以通过对象语法和数组语法进行动态绑定：</p><ul><li>对象语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>数组语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: &#x27;active&#x27;,</span><br><span class="line">  errorClass: &#x27;text-danger&#x27;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>Style 也可以通过对象语法和数组语法进行动态绑定：</p><ul><li>对象语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: &#x27;red&#x27;,</span><br><span class="line">  fontSize: 30</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>数组语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;[styleColor, styleSize]&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  styleColor: &#123;</span><br><span class="line">     color: &#x27;red&#x27;</span><br><span class="line">   &#125;,</span><br><span class="line">  styleSize:&#123;</span><br><span class="line">     fontSize:&#x27;23px&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="4、怎样理解-Vue-的单向数据流？"><a href="#4、怎样理解-Vue-的单向数据流？" class="headerlink" title="4、怎样理解 Vue 的单向数据流？"></a>4、怎样理解 Vue 的单向数据流？</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p><p>有两种常见的试图改变一个 prop 的情形 :</p><ul><li><strong>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。</strong> 在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: [&#x27;initialCounter&#x27;],</span><br><span class="line">data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    counter: this.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li><strong>这个 prop 以一种原始的值传入且需要进行转换。</strong> 在这种情况下，最好使用这个 prop 的值来定义一个计算属性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: [&#x27;size&#x27;],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: function () &#123;</span><br><span class="line">    return this.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="5、computed-和-watch-的区别和运用的场景？"><a href="#5、computed-和-watch-的区别和运用的场景？" class="headerlink" title="5、computed 和 watch 的区别和运用的场景？"></a>5、computed 和 watch 的区别和运用的场景？</h2><p><strong>computed：</strong> 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；</p><p><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><p><strong>运用场景：</strong></p><ul><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li><li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul><h2 id="6、直接给一个数组项赋值，Vue-能检测到变化吗？"><a href="#6、直接给一个数组项赋值，Vue-能检测到变化吗？" class="headerlink" title="6、直接给一个数组项赋值，Vue 能检测到变化吗？"></a>6、直接给一个数组项赋值，Vue 能检测到变化吗？</h2><p>由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</p><ul><li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li></ul><p>为了解决第一个问题，Vue 提供了以下操作方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Vue.set</span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line">// vm.$set，Vue.set的一个别名</span><br><span class="line">vm.$set(vm.items, indexOfItem, newValue)</span><br><span class="line">// Array.prototype.splice</span><br><span class="line">vm.items.splice(indexOfItem, 1, newValue)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>为了解决第二个问题，Vue 提供了以下操作方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Array.prototype.splice</span><br><span class="line">vm.items.splice(newLength)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="7、谈谈你对-Vue-生命周期的理解？"><a href="#7、谈谈你对-Vue-生命周期的理解？" class="headerlink" title="7、谈谈你对 Vue 生命周期的理解？"></a>7、谈谈你对 Vue 生命周期的理解？</h2><p><strong>（1）生命周期是什么？</strong></p><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p><p><strong>（2）各个生命周期的作用</strong></p><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>组件实例被创建之初，组件的属性生效之前</td></tr><tr><td>created</td><td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td></tr><tr><td>beforeMount</td><td>在挂载开始之前被调用：相关的 render 函数首次被调用</td></tr><tr><td>mounted</td><td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td></tr><tr><td>beforeUpdate</td><td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td></tr><tr><td>update</td><td>组件数据更新之后</td></tr><tr><td>activited</td><td>keep-alive 专属，组件被激活时调用</td></tr><tr><td>deactivated</td><td>keep-alive 专属，组件被销毁时调用</td></tr><tr><td>beforeDestory</td><td>组件销毁前调用</td></tr><tr><td>destoryed</td><td>组件销毁后调用</td></tr></tbody></table><p><strong>（3）生命周期示意图</strong></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191016414.webp" alt="1.png"></p><h2 id="8、Vue-的父组件和子组件生命周期钩子函数执行顺序？"><a href="#8、Vue-的父组件和子组件生命周期钩子函数执行顺序？" class="headerlink" title="8、Vue 的父组件和子组件生命周期钩子函数执行顺序？"></a>8、Vue 的父组件和子组件生命周期钩子函数执行顺序？</h2><p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p><ul><li><p>加载渲染过程</p><p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p></li><li><p>子组件更新过程</p><p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p></li><li><p>父组件更新过程</p><p>父 beforeUpdate -&gt; 父 updated</p></li><li><p>销毁过程</p><p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p></li></ul><h2 id="9、在哪个生命周期内调用异步请求？"><a href="#9、在哪个生命周期内调用异步请求？" class="headerlink" title="9、在哪个生命周期内调用异步请求？"></a>9、在哪个生命周期内调用异步请求？</h2><p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p><ul><li>能更快获取到服务端数据，减少页面 loading 时间；</li><li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul><h2 id="10、在什么阶段才能访问操作DOM？"><a href="#10、在什么阶段才能访问操作DOM？" class="headerlink" title="10、在什么阶段才能访问操作DOM？"></a>10、在什么阶段才能访问操作DOM？</h2><p>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。vue 具体的生命周期示意图可以参见如下，理解了整个生命周期各个阶段的操作，关于生命周期相关的面试题就难不倒你了。</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191016875.webp" alt="1.png"></p><h2 id="11、父组件可以监听到子组件的生命周期吗？"><a href="#11、父组件可以监听到子组件的生命周期吗？" class="headerlink" title="11、父组件可以监听到子组件的生命周期吗？"></a>11、父组件可以监听到子组件的生命周期吗？</h2><p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Parent.vue</span><br><span class="line">&lt;Child @mounted=&quot;doSomething&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">// Child.vue</span><br><span class="line">mounted() &#123;</span><br><span class="line">  this.$emit(&quot;mounted&quot;);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//  Parent.vue</span><br><span class="line">&lt;Child @hook:mounted=&quot;doSomething&quot; &gt;&lt;/Child&gt;</span><br><span class="line"></span><br><span class="line">doSomething() &#123;</span><br><span class="line">   console.log(&#x27;父组件监听到 mounted 钩子函数 ...&#x27;);</span><br><span class="line">&#125;,</span><br><span class="line">    </span><br><span class="line">//  Child.vue</span><br><span class="line">mounted()&#123;</span><br><span class="line">   console.log(&#x27;子组件触发 mounted 钩子函数 ...&#x27;);</span><br><span class="line">&#125;,    </span><br><span class="line">    </span><br><span class="line">// 以上输出顺序为：</span><br><span class="line">// 子组件触发 mounted 钩子函数 ...</span><br><span class="line">// 父组件监听到 mounted 钩子函数 ...     </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p><h2 id="12、谈谈你对-keep-alive-的了解？"><a href="#12、谈谈你对-keep-alive-的了解？" class="headerlink" title="12、谈谈你对 keep-alive 的了解？"></a>12、谈谈你对 keep-alive 的了解？</h2><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p><ul><li>一般结合路由和动态组件一起使用，用于缓存组件；</li><li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li><li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li></ul><h2 id="13、组件中-data-为什么是一个函数？"><a href="#13、组件中-data-为什么是一个函数？" class="headerlink" title="13、组件中 data 为什么是一个函数？"></a>13、组件中 data 为什么是一个函数？</h2><blockquote><p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// data</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">message: &quot;子组件&quot;,</span><br><span class="line">childName:this.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// new Vue</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  router,</span><br><span class="line">  template: &#x27;&lt;App/&gt;&#x27;,</span><br><span class="line">  components: &#123;App&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p><h2 id="14、v-model-的原理？"><a href="#14、v-model-的原理？" class="headerlink" title="14、v-model 的原理？"></a>14、v-model 的原理？</h2><p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li><li>checkbox 和 radio 使用 checked 属性和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul><p>以 input  表单元素为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&#x27;something&#x27;&gt;</span><br><span class="line">    </span><br><span class="line">相当于</span><br><span class="line"></span><br><span class="line">&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">父组件：</span><br><span class="line">&lt;ModelChild v-model=&quot;message&quot;&gt;&lt;/ModelChild&gt;</span><br><span class="line"></span><br><span class="line">子组件：</span><br><span class="line">&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">props:&#123;</span><br><span class="line">    value: String</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  test1()&#123;</span><br><span class="line">     this.$emit(&#x27;input&#x27;, &#x27;小红&#x27;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="15、Vue-组件间通信有哪几种方式？"><a href="#15、Vue-组件间通信有哪几种方式？" class="headerlink" title="15、Vue 组件间通信有哪几种方式？"></a>15、Vue 组件间通信有哪几种方式？</h2><p>Vue 组件间通信是面试常考的知识点之一，这题有点类似于开放题，你回答出越多方法当然越加分，表明你对 Vue 掌握的越熟练。Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。</p><p><strong>（1）<code>props / $emit</code>  适用 父子组件通信</strong></p><p>这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。</p><p><strong>（2）<code>ref</code> 与 <code>$parent / $children</code> 适用 父子组件通信</strong></p><ul><li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li><li><code>$parent</code> / <code>$children</code>：访问父 / 子实例</li></ul><p><strong>（3）<code>EventBus （$emit / $on）</code>  适用于 父子、隔代、兄弟组件通信</strong></p><p>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</p><p><strong>（4）<code>$attrs</code>/<code>$listeners</code> 适用于 隔代组件通信</strong></p><ul><li><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li><li><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的)  v-on 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件</li></ul><p><strong>（5）<code>provide / inject</code> 适用于 隔代组件通信</strong></p><p>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p><p><strong>（6）Vuex  适用于 父子、隔代、兄弟组件通信</strong></p><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>改变 store 中的状态的唯一途径就是显式地提交  (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li></ul><h2 id="16、你使用过-Vuex-吗？"><a href="#16、你使用过-Vuex-吗？" class="headerlink" title="16、你使用过 Vuex 吗？"></a>16、你使用过 Vuex 吗？</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p><p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p><p>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p><p>主要包括以下几个模块：</p><ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul><h2 id="17、使用过-Vue-SSR-吗？说说-SSR？"><a href="#17、使用过-Vue-SSR-吗？说说-SSR？" class="headerlink" title="17、使用过 Vue SSR 吗？说说 SSR？"></a>17、使用过 Vue SSR 吗？说说 SSR？</h2><blockquote><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p><p>即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p></blockquote><p><strong>服务端渲染 SSR 的优缺点如下：</strong></p><p><strong>（1）服务端渲染的优点：</strong></p><ul><li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li><li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li></ul><p><strong>（2) 服务端渲染的缺点：</strong></p><ul><li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li><li>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li></ul><p>如果没有 SSR 开发经验的同学，可以参考本文作者的另一篇 SSR 的实践文章<a href="https://juejin.cn/post/6844903824956588040">《Vue SSR 踩坑之旅》</a>，里面 SSR 项目搭建以及附有项目源码。</p><h2 id="18、vue-router-路由模式有几种？"><a href="#18、vue-router-路由模式有几种？" class="headerlink" title="18、vue-router 路由模式有几种？"></a>18、vue-router 路由模式有几种？</h2><p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">switch (mode) &#123;</span><br><span class="line">  case &#x27;history&#x27;:</span><br><span class="line">this.history = new HTML5History(this, options.base)</span><br><span class="line">break</span><br><span class="line">  case &#x27;hash&#x27;:</span><br><span class="line">this.history = new HashHistory(this, options.base, this.fallback)</span><br><span class="line">break</span><br><span class="line">  case &#x27;abstract&#x27;:</span><br><span class="line">this.history = new AbstractHistory(this, options.base)</span><br><span class="line">break</span><br><span class="line">  default:</span><br><span class="line">if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123;</span><br><span class="line">  assert(false, `invalid mode: $&#123;mode&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>其中，3 种路由模式的说明如下：</p><ul><li>hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li><li>history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li><li>abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li></ul><h2 id="19、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？"><a href="#19、能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗？" class="headerlink" title="19、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？"></a>19、能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h2><p><strong>（1）hash 模式的实现原理</strong></p><p>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.word.com#search</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>hash  路由模式的实现主要是基于下面几个特性：</p><ul><li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li><li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li><li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li><li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li></ul><p><strong>（2）history 模式的实现原理</strong></p><p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.history.pushState(null, null, path);</span><br><span class="line">window.history.replaceState(null, null, path);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>history 路由模式的实现主要基于存在下面几个特性：</p><ul><li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li><li>我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li><li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li></ul><h2 id="20、什么是-MVVM？"><a href="#20、什么是-MVVM？" class="headerlink" title="20、什么是 MVVM？"></a>20、什么是 MVVM？</h2><p>Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表</p><p>MVVM 源自于经典的 Model–View–Controller（MVC）模式  ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示：</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191015349.webp" alt="1.png"></p><p>（1）View 层</p><p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。</p><p>（2）Model 层</p><p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</p><p>（3）ViewModel 层</p><p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。</p><p>MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p><p>我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然：</p><p>（1）View 层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;showMessage()&quot;&gt;Click me&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（2）ViewModel 层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    data: &#123;  // 用于描述视图状态   </span><br><span class="line">        message: &#x27;Hello Vue!&#x27;, </span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;  // 用于描述视图行为  </span><br><span class="line">        showMessage()&#123;</span><br><span class="line">            let vm = this;</span><br><span class="line">            alert(vm.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        let vm = this;</span><br><span class="line">        // Ajax 获取 Model 层的数据</span><br><span class="line">        ajax(&#123;</span><br><span class="line">            url: &#x27;/your/server/data/api&#x27;,</span><br><span class="line">            success(res)&#123;</span><br><span class="line">                vm.message = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（3） Model 层</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;url&quot;: &quot;/your/server/data/api&quot;,</span><br><span class="line">    &quot;res&quot;: &#123;</span><br><span class="line">        &quot;success&quot;: true,</span><br><span class="line">        &quot;name&quot;: &quot;IoveC&quot;,</span><br><span class="line">        &quot;domain&quot;: &quot;www.cnblogs.com&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="21、Vue-是如何实现数据双向绑定的？"><a href="#21、Vue-是如何实现数据双向绑定的？" class="headerlink" title="21、Vue 是如何实现数据双向绑定的？"></a>21、Vue 是如何实现数据双向绑定的？</h2><p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191015839.webp" alt="1.png"></p><p>即：</p><ul><li>输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。</li><li>Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。</li></ul><p>其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。</p><p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p><p>实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</p><p>实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p><p>实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</p><p>实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p><p>以上四个步骤的流程图表示如下，如果有同学理解不大清晰的，可以查看作者专门介绍数据双向绑定的文章<a href="https://juejin.cn/post/6844903903822086151">《0 到 1 掌握：Vue 核心之数据双向绑定》</a>，有进行详细的讲解、以及代码 demo 示例。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/19/16ca75871f729d89~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="1.png"></p><h2 id="22、Vue-框架怎么实现对象和数组的监听？"><a href="#22、Vue-框架怎么实现对象和数组的监听？" class="headerlink" title="22、Vue 框架怎么实现对象和数组的监听？"></a>22、Vue 框架怎么实现对象和数组的监听？</h2><p>如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是  Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * Observe a list of Array items.</span><br><span class="line">   */</span><br><span class="line">  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line">    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])  // observe 功能为监测数据的变化</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 对属性进行递归遍历</span><br><span class="line">   */</span><br><span class="line">  let childOb = !shallow &amp;&amp; observe(val) // observe 功能为监测数据的变化</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用  Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p><h2 id="23、Proxy-与-Object-defineProperty-优劣对比"><a href="#23、Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="23、Proxy 与 Object.defineProperty 优劣对比"></a>23、Proxy 与 Object.defineProperty 优劣对比</h2><p><strong>Proxy 的优势如下:</strong></p><ul><li>Proxy 可以直接监听对象而非属性；</li><li>Proxy 可以直接监听数组的变化；</li><li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li><li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li><li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li></ul><p><strong>Object.defineProperty 的优势如下:</strong></p><ul><li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</li></ul><h2 id="24、Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？"><a href="#24、Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？" class="headerlink" title="24、Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？"></a>24、Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</h2><p>受现代 JavaScript 的限制 ，Vue <strong>无法检测到对象属性的添加或删除</strong>。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 <code>Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)</code>  来实现为对象添加响应式属性，那框架本身是如何实现的呢？</p><p>我们查看对应的 Vue 源码：<code>vue/src/core/instance/index.js</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any &#123;</span><br><span class="line">  // target 为数组  </span><br><span class="line">  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    // 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span><br><span class="line">    target.length = Math.max(target.length, key)</span><br><span class="line">    // 利用数组的splice变异方法触发响应式  </span><br><span class="line">    target.splice(key, 1, val)</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  // key 已经存在，直接修改属性值  </span><br><span class="line">  if (key in target &amp;&amp; !(key in Object.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  const ob = (target: any).__ob__</span><br><span class="line">  // target 本身就不是响应式数据, 直接赋值</span><br><span class="line">  if (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    return val</span><br><span class="line">  &#125;</span><br><span class="line">  // 对属性进行响应式处理</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  return val</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们阅读以上源码可知，vm.$set 的实现原理是：</p><ul><li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li><li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用   defineReactive 方法进行响应式处理（ defineReactive 方法就是  Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li></ul><h2 id="25、虚拟-DOM-的优缺点？"><a href="#25、虚拟-DOM-的优缺点？" class="headerlink" title="25、虚拟 DOM 的优缺点？"></a>25、虚拟 DOM 的优缺点？</h2><p><strong>优点：</strong></p><ul><li><strong>保证性能下限：</strong> 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li><li><strong>无需手动操作 DOM：</strong> 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li><li><strong>跨平台：</strong> 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ul><p><strong>缺点:</strong></p><ul><li><strong>无法进行极致优化：</strong> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li></ul><h2 id="26、虚拟-DOM-实现原理？"><a href="#26、虚拟-DOM-实现原理？" class="headerlink" title="26、虚拟 DOM 实现原理？"></a>26、虚拟 DOM 实现原理？</h2><p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p><ul><li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li><li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li><li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li></ul><p>如果对以上 3 个部分还不是很了解的同学，可以查看本文作者写的另一篇详解虚拟 DOM 的文章《<a href="https://juejin.cn/post/6844903895467032589#heading-14">深入剖析：Vue核心之虚拟DOM</a>》</p><h2 id="27、Vue-中的-key-有什么作用？"><a href="#27、Vue-中的-key-有什么作用？" class="headerlink" title="27、Vue 中的 key 有什么作用？"></a>27、Vue 中的 key 有什么作用？</h2><p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：newStartIndex 和oldStartIndex 、newEndIndex 和  oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。具体有无 key 的 diff 过程，可以查看作者写的另一篇详解虚拟 DOM 的文章《<a href="https://juejin.cn/post/6844903895467032589#heading-14">深入剖析：Vue核心之虚拟DOM</a>》</p><p>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速</p><p><strong>更准确</strong>：因为带 key 就不是就地复用了，在 sameNode 函数 <code>a.key === b.key</code> 对比中可以避免就地复用的情况。所以会更加准确。</p><p><strong>更快速</strong>：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createKeyToOldIdx (children, beginIdx, endIdx) &#123;</span><br><span class="line">  let i, key</span><br><span class="line">  const map = &#123;&#125;</span><br><span class="line">  for (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">    key = children[i].key</span><br><span class="line">    if (isDef(key)) map[key] = i</span><br><span class="line">  &#125;</span><br><span class="line">  return map</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="28、你有对-Vue-项目进行哪些优化？"><a href="#28、你有对-Vue-项目进行哪些优化？" class="headerlink" title="28、你有对 Vue 项目进行哪些优化？"></a>28、你有对 Vue 项目进行哪些优化？</h2><p>如果没有对 Vue 项目没有进行过优化总结的同学，可以参考本文作者的另一篇文章<a href="https://juejin.cn/post/6844903913410314247">《 Vue 项目性能优化 — 实践指南 》</a>，文章主要介绍从 3 个大方面，22 个小方面详细讲解如何进行 Vue 项目的优化。</p><p><strong>（1）代码层面的优化</strong></p><ul><li>v-if 和 v-show 区分使用场景</li><li>computed 和 watch  区分使用场景</li><li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li><li>长列表性能优化</li><li>事件的销毁</li><li>图片资源懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>优化无限列表性能</li><li>服务端渲染 SSR or 预渲染</li></ul><p><strong>（2）Webpack 层面的优化</strong></p><ul><li>Webpack 对图片进行压缩</li><li>减少 ES6 转为 ES5 的冗余代码</li><li>提取公共代码</li><li>模板预编译</li><li>提取组件的 CSS</li><li>优化 SourceMap</li><li>构建结果输出分析</li><li>Vue 项目的编译优化</li></ul><p><strong>（3）基础的 Web 技术的优化</strong></p><ul><li>开启 gzip 压缩</li><li>浏览器缓存</li><li>CDN 的使用</li><li>使用 Chrome Performance 查找性能瓶颈</li></ul><h2 id="29、对于即将到来的-vue3-0-特性你有什么了解的吗？"><a href="#29、对于即将到来的-vue3-0-特性你有什么了解的吗？" class="headerlink" title="29、对于即将到来的 vue3.0 特性你有什么了解的吗？"></a>29、对于即将到来的 vue3.0 特性你有什么了解的吗？</h2><p>Vue 3.0 正走在发布的路上，Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：</p><p><strong>（1）监测机制的改变</strong></p><p>3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p><ul><li>只能监测属性，不能监测对象</li><li>检测属性的添加和删除；</li><li>检测数组索引和长度的变更；</li><li>支持 Map、Set、WeakMap 和 WeakSet。</li></ul><p>新的 observer 还提供了以下特性：</p><ul><li>用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。</li><li>默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。</li><li>更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。</li><li>不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。</li><li>更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。</li></ul><p><strong>（2）模板</strong></p><p>模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</p><p>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</p><p><strong>（3）对象式的组件声明方式</strong></p><p>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。</p><p>此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。</p><p><strong>（4）其它方面的更改</strong></p><p>vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：</p><ul><li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li><li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li><li>基于 treeshaking 优化，提供了更多的内置功能。</li></ul><h2 id="30、说说你使用-Vue-框架踩过最大的坑是什么？怎么解决的？"><a href="#30、说说你使用-Vue-框架踩过最大的坑是什么？怎么解决的？" class="headerlink" title="30、说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？"></a>30、说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？</h2><p>本题为开放题目，欢迎大家在评论区畅所欲言，分享自己的踩坑、填坑经历，提供前车之鉴，避免大伙再次踩坑 ~~~</p><p>作者：我是你的超级英雄<br>链接：<a href="https://juejin.cn/post/6844903918753808398">https://juejin.cn/post/6844903918753808398</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试知识整理</title>
      <link href="/2022/03/13/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2022/03/13/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>面试复习</p><h2 id="1-JavaScript-基础"><a href="#1-JavaScript-基础" class="headerlink" title="1.JavaScript 基础"></a>1.JavaScript 基础</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132100087.png" alt="image-20220308142823940"></p><h3 id="1-执行上下文-作用域-闭包"><a href="#1-执行上下文-作用域-闭包" class="headerlink" title="1.执行上下文/作用域/闭包"></a>1.执行上下文/作用域/闭包</h3><h4 id="1-什么是执行上下文"><a href="#1-什么是执行上下文" class="headerlink" title="1.什么是执行上下文?"></a>1.什么是执行上下文?</h4><p>执行上下文是评估和执行JavaScript代码环境的抽象概念。每当JavaScript代码在运行时，他都是在执行上下文中运行。</p><hr><p><strong>执行上下文的类型</strong></p><p>JavaScript共有<strong>三种</strong>执行上下文类型</p><ul><li><strong>全局执行上下文</strong><ul><li>这是基础的上下文,任何不在函数内部的代码都在全局上下文中.他会执行两件事:创建一个全局的window对象(浏览器环境的情况下),并且设置this的值等于这个全局对象。一个程序中只会有一个全局执行上下文</li></ul></li><li><strong>函数执行上下文</strong><ul><li>每当函数被调用时，都会为该函数创建一个新的执行上下文。每个函数都有他自己的执行上下文，只不过是在函数被调用时才被创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，他会按定义的瞬狙执行一系列步骤</li></ul></li><li><strong>Eval函数执行上下文</strong><ul><li>执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文</li></ul></li></ul><hr><p><strong>执行上下文栈</strong></p><p>执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。</p><p>当JavaScript引擎第一次遇到你的脚本时，他会创建一个全局的执行上下文并且压入当前执行栈。<strong>每当引擎遇到一个函数调用，他会为该函数创建一个新的执行上下文并压入栈的顶部.</strong></p><p>引擎会执行那些执行上下文位于栈顶的函数.<strong>每当函数执行结束之后，最上层的执行上下文从栈中弹出</strong>，控制流程到达当前栈中的下一个上下文</p><p><strong>一旦所有代码执行完毕，JavaScript引擎从当前栈中移除全局执行上下文</strong></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132100915.png" alt="image-20220308144717269"></p><hr><p><strong>怎么创建执行上下文?</strong></p><p>创建执行上下文有两个阶段:</p><ol><li><strong>创建阶段</strong></li><li><strong>执行阶段</strong></li></ol><hr><p><strong>创建阶段</strong></p><p>在JavaScript代码执行前，执行上下文将经历创建阶段。在创建阶段将会发生三件事:</p><ol><li><strong>this</strong>值的绑定</li><li>创建<strong>词法环境</strong></li><li>创建<strong>变量环境</strong></li></ol><p>所以执行上下文在概念上表示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext = &#123;</span><br><span class="line">  ThisBinding = &lt;this value&gt;,</span><br><span class="line">  LexicalEnvironment = &#123; ... &#125;,</span><br><span class="line">  VariableEnvironment = &#123; ... &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>This绑定:</strong></p><p>在全局执行上下文中,<code>this</code>的值指向全局对象(在浏览器中,全局对象为<code>window</code>’)</p><p>在函数执行上下文中,this的值取决于该函数是如何被调用的.如果他被一个引用类型对象调用,那么this会被设置成那个对象,否则<code>this</code>的值被设置成全局对象或者<code>undefined</code>(严格模式)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let foo = &#123;</span><br><span class="line">  baz: function() &#123;</span><br><span class="line">  console.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.baz();   <span class="comment">// &#x27;this&#x27; 引用 &#x27;foo&#x27;, 因为 &#x27;baz&#x27; 被</span></span><br><span class="line">             <span class="comment">// 对象 &#x27;foo&#x27; 调用</span></span><br><span class="line"></span><br><span class="line">let bar = foo.baz;</span><br><span class="line"></span><br><span class="line">bar();       <span class="comment">// &#x27;this&#x27; 指向全局 window 对象，因为</span></span><br><span class="line">             <span class="comment">// 没有指定引用对象</span></span><br></pre></td></tr></table></figure><p><strong>词法环境</strong></p><p><a href="https://link.juejin.cn/?target=http://ecma-international.org/ecma-262/6.0/">官方的 ES6</a> 文档把词法环境定义为</p><blockquote><p><strong>词法环境</strong>是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义<strong>标识符</strong>和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用<strong>外部</strong>词法环境的空值组成。</p></blockquote><p>词法环境是一种持有<strong>变量符-变量映射</strong>的结构(标识符指的是变量/函数的名字,而变量是对实际对象或原始数据的引用)</p><p>在词法环境的内部有两个组件:1.<strong>环境记录器</strong>和2.一个<strong>外部环境的引用</strong></p><p>1.<strong>环境记录器</strong>是存储变量和函数声明的实际位置</p><p>2.<strong>外部环境的引用</strong>意味着它可以访问其父级词法环境(作用域)</p><p><strong>词法环境</strong>有两种类型: <strong>全局环境</strong>和<strong>函数环境</strong></p><ul><li><p><strong>全局环境</strong>(在全局执行上下文中)是没有外部环境引用的词法环境,全局环境的外部环境引用是<strong>null</strong>，</p><p>它拥有创建的Object/Array等,在环境记录器内的原型函数(关联全局对象,比如window对象)还有任何用户定义的全局变量,并且<code>this</code>的值指向全局对象</p></li><li><p>在<strong>函数环境</strong>中，函数内部用户定义的变量存储在<strong>环境记录器</strong>中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。</p></li></ul><p>环境记录器也有两种类型:</p><ol><li><strong>声明式环境记录器</strong>，用来存储变量、函数和参数</li><li><strong>对象环境记录器</strong>,用来定义出现在<strong>全局上下文</strong>中的变量和函数关系</li></ol><p>由上不难得知</p><ul><li>在<strong>全局环境</strong>中,环境记录器是对象环境记录器</li><li>在<strong>函数环境</strong>中,环境记录器是声明式环境记录器</li></ul><p><strong>注意 :</strong> 对于<strong>函数环境</strong>，<strong>声明式环境记录器</strong>还包含了一个传递给函数的 <code>arguments</code> 对象（此对象存储索引和参数的映射）和传递给函数的参数的 <strong>length</strong>。</p><p>抽象地讲，词法环境在伪代码中看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;Global or outer function environment reference&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>变量环境</strong></p><p>变量环境其实也是一个<strong>词法环境</strong>,其环境记录器中持有变量声明语句在执行上下文中创建的绑定关系</p><p>变量环境有着词法环境的所有属性</p><p>在ES6中,词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量(<code>let</code>和<code>const</code>)绑定,而后者只用来存储<code>var</code>变量绑定</p><p>我们看点样例代码来理解上面的概念：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">e, f</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> g = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">return</span> e * f * g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = multiply(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行上下文看起来像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">ThisBinding</span>: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      a: &lt; uninitialized &gt;,</span><br><span class="line">      b: &lt; uninitialized &gt;,</span><br><span class="line">      multiply: &lt; func &gt;</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      c: undefined,</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  ThisBinding: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      Arguments: &#123;0: 20, 1: 30, length: 2&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      g: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能你已经注意到 <code>let</code> 和 <code>const</code> 定义的变量并没有关联任何值，但 <code>var</code> 定义的变量被设成了 <code>undefined</code>。</p><p>这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 <code>undefined</code>（<code>var</code> 情况下），或者未初始化（<code>let</code> 和 <code>const</code> 情况下）。</p><p>这就是为什么你可以在声明之前访问 <code>var</code> 定义的变量（虽然是 <code>undefined</code>），但是在声明之前访问 <code>let</code> 和 <code>const</code> 的变量会得到一个引用错误。</p><p>这就是我们说的<strong>变量声明提升</strong>。</p><hr><p><strong>执行阶段</strong></p><p><strong>在此阶段完成对所有存储的变量的分配,最后执行代码.</strong></p><p><strong>注意:</strong> 在执行阶段,如果JavaScript引擎不能再源码中声明的实际位置找到<code>let</code>变量的值，那么他就会被赋值为<code>undefined</code></p><hr><hr><h4 id="2-作用域-Scope"><a href="#2-作用域-Scope" class="headerlink" title="2.作用域(Scope)"></a>2.作用域(Scope)</h4><p><strong>什么是作用域?</strong></p><p><strong>作用域是指程序源代码中定义变量的区域。</strong></p><p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p><p>JavaScript 采用<strong>词法作用域</strong>(lexical scoping)，也就是静态作用域。</p><p>我们可以这样理解：<strong>作用域就是一个独立的地盘，让变量不会外泄、暴露出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong></p><p>ES6之前,JavaScript只有<strong>全局作用域</strong>和<strong>函数作用域</strong>,ES6之后，新增了<strong>块级作用域</strong>，可以通过<code>let</code>和<code>const</code>来创建</p><hr><p><strong>全局作用域和函数作用域</strong></p><p>**在代码中任何地方都能访问到的对象拥有全局作用域,**以下几种情况拥有全局作用域:</p><ul><li>最外层函数和在最外层函数外定义的变量拥有全局作用域</li><li>所有未定义直接赋值的变量默认为全局变量，拥有全局作用域</li><li>所有window对象的属性拥有全局作用域</li></ul><p>全局作用域的<strong>弊端</strong>:容易引发命名冲突，污染全局命名空间</p><hr><p><strong>函数作用域</strong></p><p><strong>在函数内部声明的变量</strong>拥有函数作用域,一般只能在固定的代码片段内可以访问到.</p><hr><p>作用域是分层的,内层作用域可以访问外层作用域的变量,反之则不行</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132100037.png" alt="image-20220308172822751"></p><p>值得注意的是：<strong>块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// &#x27;if&#x27; 条件语句块不会创建一个新的作用域</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;Hammad&#x27;</span>; <span class="comment">// name 依然在全局作用域中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// logs &#x27;Hammad&#x27;</span></span><br></pre></td></tr></table></figure><hr><p><strong>块级作用域</strong></p><p>块级作用域可以通过<code>let</code>和<code>const</code>声明,所声明的变量在指定块作用域·之外无法被访问。</p><p>块级作用域在如下情况被创建:</p><ol><li>在一个函数内部</li><li>在一个代码块内部(‘**{}**’)</li></ol><p>块级作用域有以下几个特点:</p><ul><li>声明变量不会提升的代码块顶部</li><li>禁止重复声明</li></ul><hr><p><strong>作用域链</strong></p><p>在JavaScript中,函数、块、模块都可以形成作用域,他们之间可以相互嵌套、作用域之间会形成引用关系，这条链叫做作用域链</p><p><strong>作用域链的创建和变化</strong></p><p><strong>函数创建时:</strong></p><p>JavaScript中使用的是词法作用域,<strong>函数的作用域在函数定义的时候就已经决定了</strong></p><p>函数有一个内部属性[[scope]]，当函数创建的时候,就会保存所有父变量对象到其中,可以理解为[[scope]]就是所有父变量对象的层级链,但是注意:[[scope]]并不代表完整的作用域链</p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数创建时，各自的[[scope]]为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">    fooContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><strong>函数被激活时:</strong></p><p>当函数被激活时,进入函数上下文,创建VO/AO后就会将活动对象添加到作用域的前端</p><p>这时候执行上下文的作用域链,我们命名为Scope</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure><p>至此,<strong>作用域链创建完毕</strong></p><hr><h4 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3.闭包"></a>3.闭包</h4><p><strong>什么是闭包?</strong></p><p>闭包就是同时含有对函数对象以及作用域对象引用的对象,实际上所有JavaScript对象都是闭包.</p><p><strong>本质</strong>:在一个函数内部创建另一个函数</p><p><strong>只要存在函数嵌套,并且内部函数调用了外部函数的属性,就产生了闭包.</strong></p><p>闭包的特性:</p><ul><li>函数嵌套函数</li><li>函数内部引用函数外部的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ul><hr><p><strong>闭包是什么时候被创建的？</strong></p><p>因为所有JavaScript对象都是闭包,所以当你定义一个函数时.就产生了闭包</p><hr><p><strong>闭包是什么时候被销毁的?</strong></p><p>当他不被任何其他的对象引用的时候，闭包就被销毁</p><hr><p><strong>闭包的好处</strong>:</p><ul><li>保护函数内的变量安全,实现封装,防止变量流入其他环境发生命名冲突</li><li>在内存中维持一个变量，延长变量的生命周期</li><li>匿名自执行函数可以减少内存消耗</li></ul><hr><p><strong>闭包的缺点:</strong></p><ul><li>被引用的私有变量不能被销毁，增大了内存的消耗，造成内存泄露</li><li>闭包涉及跨域访问，会导致性能损失</li></ul><hr><p><strong>闭包的作用</strong></p><ul><li>使得函数内部的变量在函数执行完之后，仍然存活在内存中(延长了局部变量的生命周期)</li><li>让函数外部可以操作到函数内部的数据</li></ul><hr><p><strong>闭包的原理</strong></p><p>当一个函数返回后，没有其他对象会保存对其的引用。所以，它就可能被<code>垃圾回收器</code>回收。</p><p>函数对象中总是有一个<code>[[scope]]</code>属性，保存着该函数被定义的时候所能够直接访问的作用域对象。所以，当我们在定义嵌套的函数的时候，这个嵌套的函数的<code>[[scope]]</code>就会引用外围函数（Outer function）的当前作用域对象。</p><p>如果我们将这个嵌套函数返回,并被另一个标识符所引用的话,那么这个嵌套函数及其[[scope]]所引用的作用作用域对象就不会被垃圾回收器所销毁,这个对象就会一直存活在内存中,我们可以通过这个作用于对象获取到外部函数的属性和值。</p><p>这就是闭包的原理</p><hr><h3 id="2-this-call-apply-bind"><a href="#2-this-call-apply-bind" class="headerlink" title="2.this/call/apply/bind"></a>2.this/call/apply/bind</h3><h4 id="1-this的指向"><a href="#1-this的指向" class="headerlink" title="1.this的指向"></a>1.this的指向</h4><blockquote><p>函数的this是在函数调用时才绑定的,它的指向完全取决于函数的调用位置(也就是函数的调用方法),为了搞清楚<code>this</code>的指向是什么，必须知道相关函数是如何调用的</p></blockquote><p><strong>在全局上下文中:</strong></p><p>非严格模式和严格模式中this都指向顶层对象(在浏览器中是<code>window</code>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span> === <span class="built_in">window</span> <span class="comment">// true</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="built_in">this</span> === <span class="built_in">window</span>;</span><br><span class="line"><span class="built_in">this</span>.name = <span class="string">&#x27;若川&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// 若川</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>普通函数调用模式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 非严格模式</span><br><span class="line">var name = &#x27;window&#x27;;</span><br><span class="line">var doSth = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">doSth(); // &#x27;window&#x27;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>你可能会误以为<code>window.doSth()</code>是调用的，所以是指向<code>window</code>。虽然本例中<code>window.doSth</code>确实等于<code>doSth</code>。<code>name</code>等于<code>window.name</code>。上面代码中这是因为在<code>ES5</code>中，全局变量是挂载在顶层对象（浏览器是<code>window</code>）中。 事实上，并不是如此。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 非严格模式</span><br><span class="line">let name2 = &#x27;window2&#x27;;</span><br><span class="line">let doSth2 = function()&#123;</span><br><span class="line">    console.log(this === window);</span><br><span class="line">    console.log(this.name2);</span><br><span class="line">&#125;</span><br><span class="line">doSth2() // true, undefined</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个例子中<code>let</code>没有给顶层对象中（浏览器是window）添加属性，<code>window.name2和window.doSth</code>都是<code>undefined</code>。</p><p>严格模式中，普通函数中的<code>this</code>则表现不同，表现为<code>undefined</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 严格模式</span><br><span class="line">&#x27;use strict&#x27;</span><br><span class="line">var name = &#x27;window&#x27;;</span><br><span class="line">var doSth = function()&#123;</span><br><span class="line">    console.log(typeof this === &#x27;undefined&#x27;);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">doSth(); // true，// 报错，因为this是undefined</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>看过的《你不知道的<code>JavaScript</code>》上卷的读者，应该知道书上将这种叫做默认绑定。 对<code>call</code>，<code>apply</code>熟悉的读者会类比为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSth.call(undefined);</span><br><span class="line">doSth.apply(undefined);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果是一样的，<code>call</code>，<code>apply</code>作用之一就是用来修改函数中的<code>this</code>指向为第一个参数的。 第一个参数是<code>undefined</code>或者<code>null</code>，非严格模式下，是指向<code>window</code>。严格模式下，就是指向第一个参数。后文详细解释。<br> 经常有这类代码（回调函数），其实也是普通函数调用模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;若川&#x27;;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;, 0);</span><br><span class="line">// 语法</span><br><span class="line">setTimeout(fn | code, 0, arg1, arg2, ...)</span><br><span class="line">// 也可以是一串代码。也可以传递其他函数</span><br><span class="line">// 类比 setTimeout函数内部调用fn或者执行代码`code`。</span><br><span class="line">fn.call(undefined, arg1, arg2, ...);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>对象中的函数（方法）调用模式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;window&#x27;;</span><br><span class="line">var doSth = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var student = &#123;</span><br><span class="line">    name: &#x27;若川&#x27;,</span><br><span class="line">    doSth: doSth,</span><br><span class="line">    other: &#123;</span><br><span class="line">        name: &#x27;other&#x27;,</span><br><span class="line">        doSth: doSth,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">student.doSth(); // &#x27;若川&#x27;</span><br><span class="line">student.other.doSth(); // &#x27;other&#x27;</span><br><span class="line">// 用call类比则为：</span><br><span class="line">student.doSth.call(student);</span><br><span class="line">// 用call类比则为：</span><br><span class="line">student.other.doSth.call(student.other);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>但往往会有以下场景，把对象中的函数赋值成一个变量了。 这样其实又变成普通函数了，所以使用普通函数的规则（默认绑定）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var studentDoSth = student.doSth;</span><br><span class="line">studentDoSth(); // &#x27;window&#x27;</span><br><span class="line">// 用call类比则为：</span><br><span class="line">studentDoSth.call(undefined);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong><code>call、apply、bind</code> 调用模式</strong></p><p>上文提到<code>call</code>、<code>apply</code>，这里详细解读一下。先通过<code>MDN</code>认识下<code>call</code>和<code>apply</code> <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">MDN 文档：Function.prototype.call()</a><br> <strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>thisArg</strong><br> 在<code>fun</code>函数运行时指定的<code>this</code>值。需要注意的是，指定的<code>this</code>值并不一定是该函数执行时真正的<code>this</code>值，如果这个函数处于<strong>非严格模式</strong>下，则指定为<code>null</code>和<code>undefined</code>的<code>this</code>值会自动指向全局对象(浏览器中就是<code>window</code>对象)，同时值为原始值(数字，字符串，布尔值)的<code>this</code>会指向该原始值的自动包装对象。<br> <strong>arg1, arg2, …</strong><br> 指定的参数列表<br> <strong>返回值</strong><br> 返回值是你调用的方法的返回值，若该方法没有返回值，则返回<code>undefined</code>。<br> <code>apply</code>和<code>call</code>类似。只是参数不一样。它的参数是数组（或者类数组）。</p><p>根据参数<code>thisArg</code>的描述，可以知道，<code>call</code>就是改变函数中的<code>this</code>指向为<code>thisArg</code>，并且执行这个函数，这也就使<code>JS</code>灵活很多。严格模式下，<code>thisArg</code>是原始值是值类型，也就是原始值。不会被包装成对象。举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var doSth = function(name)&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(name);</span><br><span class="line">&#125;</span><br><span class="line">doSth.call(2, &#x27;若川&#x27;); // Number&#123;2&#125;, &#x27;若川&#x27;</span><br><span class="line">var doSth2 = function(name)&#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(name);</span><br><span class="line">&#125;</span><br><span class="line">doSth2.call(2, &#x27;若川&#x27;); // 2, &#x27;若川&#x27;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>虽然一般不会把<code>thisArg</code>参数写成值类型。但还是需要知道这个知识。 之前写过一篇文章：<a href="https://juejin.cn/post/6844903728147857415">面试官问：能否模拟实现<code>JS</code>的<code>call</code>和<code>apply</code>方法</a> 就是利用对象上的函数<code>this</code>指向这个对象，来模拟实现<code>call</code>和<code>apply</code>的。感兴趣的读者思考如何实现，再去看看笔者的实现。</p><p><code>bind</code>和<code>call</code>和<code>apply</code>类似，第一个参数也是修改<code>this</code>指向，只不过返回值是新函数，新函数也能当做构造函数（<code>new</code>）调用。 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">MDN Function.prototype.bind</a></p><blockquote><p><code>bind()</code>方法创建一个新的函数， 当这个新函数被调用时<code>this</code>键值为其提供的值，其参数列表前几项值为创建时指定的参数序列。</p></blockquote><p><strong>语法：</strong> fun.bind(thisArg[, arg1[, arg2[, …]]])<br> <strong>参数：</strong> <strong>thisArg</strong> 调用绑定函数时作为this参数传递给目标函数的值。 如果使用<code>new</code>运算符构造绑定函数，则忽略该值。当使用<code>bind</code>在<code>setTimeout</code>中创建一个函数（作为回调提供）时，作为<code>thisArg</code>传递的任何原始值都将转换为<code>object</code>。如果没有提供绑定的参数，则执行作用域的<code>this</code>被视为新函数的<code>thisArg</code>。 <strong>arg1, arg2, …</strong> 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 <strong>返回值</strong> 返回由指定的<code>this</code>值和初始化参数改造的原函数拷贝。</p><p><strong>构造函数调用模式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Student(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    console.log(this); // &#123;name: &#x27;若川&#x27;&#125;</span><br><span class="line">    // 相当于返回了</span><br><span class="line">    // return this;</span><br><span class="line">&#125;</span><br><span class="line">var result = new Student(&#x27;若川&#x27;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>使用<code>new</code>操作符调用函数，会自动执行以下步骤。</p><blockquote><ol><li>创建了一个全新的对象。</li><li>这个对象会被执行<code>[[Prototype]]</code>（也就是<code>__proto__</code>）链接。</li><li>生成的新对象会绑定到函数调用的<code>this</code>。</li><li>通过<code>new</code>创建的每个对象将最终被<code>[[Prototype]]</code>链接到这个函数的<code>prototype</code>对象上。</li><li>如果函数没有返回对象类型<code>Object</code>(包含<code>Functoin</code>, <code>Array</code>, <code>Date</code>, <code>RegExg</code>, <code>Error</code>)，那么<code>new</code>表达式中的函数调用会自动返回这个新的对象。</li></ol></blockquote><p>由此可以知道：<code>new</code>操作符调用时，<code>this</code>指向生成的新对象。 <strong>特别提醒一下，<code>new</code>调用时的返回值，如果没有显式返回对象或者函数，才是返回生成的新对象</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Student(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    // return function f()&#123;&#125;;</span><br><span class="line">    // return &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">var result = new Student(&#x27;若川&#x27;);</span><br><span class="line">console.log(result); &#123;name: &#x27;若川&#x27;&#125;</span><br><span class="line">// 如果返回函数f，则result是函数f，如果是对象&#123;&#125;，则result是对象&#123;&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>很多人或者文章都忽略了这一点，直接简单用<code>typeof</code>判断对象。虽然实际使用时不会显示返回，但面试官会问到。</p><hr><p><strong>总结</strong></p><p>如果要判断一个运行中的函数的this绑定，就需要找到这个函数的直接调用位置.找到之后就可以顺序应用下面这四条规则来判断this的指向</p><ol><li><strong>普通函数调用</strong>:在严格模式下绑定到<code>undefined</code>,否则绑定到全局对象</li><li><strong>构造函数形式调用</strong>:绑定到新创建的实例对象</li><li><strong>对象上的函数调用</strong>:帮到到那个对象</li><li><strong>call、apply、bind调用</strong>:在非严格模式下,this为函数传入的第一个参数,如果第一个参数为<code>null</code>或者<code>undefined</code>，<code>this</code>会指向全局对象(浏览器中就是window对象)</li></ol><p><strong>箭头函数的this</strong>:不会使用上文的四条标准的绑定规则,而是<strong>根据当前的词法作用域来决定this。</strong></p><p>箭头函数没有自己的this、super、argument和new.target绑定,所以<strong>必须通过查找作用域链来决定其值</strong>.<strong>如果箭头函数被非箭头函数包含,则this绑定的是最近一层非箭头函数的this,否则this的值会被设置位全局对象.</strong></p><hr><h4 id="2-call"><a href="#2-call" class="headerlink" title="2.call"></a>2.call</h4><blockquote><p>call()方法的作用是在使用<strong>一个指定的this值</strong>和<strong>若干个指定的参数值</strong>的前提下调用某个函数或方法</p></blockquote><p>举个栗子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>手写实现call方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.ts_call(obj,...args)&#123;</span><br><span class="line">    obj = obj || <span class="built_in">window</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(); <span class="comment">//创建一个唯一变量,防止属性名冲突</span></span><br><span class="line">    </span><br><span class="line">    obj[fn] = <span class="built_in">this</span>; <span class="comment">//将属性指定为目标函数</span></span><br><span class="line">    </span><br><span class="line">    obj[fn](...args);<span class="comment">//执行函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> obj[fn];<span class="comment">//执行后将这个属性删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我叫<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testobj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zzm&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">fn.cs_call(testobj2,<span class="number">18</span>)<span class="comment">//我叫zzm今年18岁了!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-apply"><a href="#3-apply" class="headerlink" title="3.apply"></a>3.apply</h4><blockquote><p>apply的方法与call类似,不同之处在于<strong>apply参数以数组的方式传递</strong>,所以call能实现的需求，用apply也同样可以</p></blockquote><p>手写实现apply方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.cs_apply(obj,arg)&#123;</span><br><span class="line">    obj = obj || <span class="built_in">window</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    </span><br><span class="line">    obj[fn] = <span class="built_in">this</span>;</span><br><span class="line">    </span><br><span class="line">    obj[fn](...args);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> obj[fn];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">age,hobby</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我叫<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>今年<span class="subst">$&#123;age&#125;</span>岁了我喜欢<span class="subst">$&#123;hobby&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testobj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zzm&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">fn.cs_apply(testobj2,[<span class="number">18</span>,<span class="string">&#x27;睡觉&#x27;</span>])<span class="comment">//我叫zzm今年18岁了我喜欢睡觉</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-bind"><a href="#4-bind" class="headerlink" title="4.bind"></a>4.bind</h4><blockquote><p>bind()函数会创建一个新函数(称之为绑定函数)</p></blockquote><ul><li>bind是ES5新增的一个方法</li><li>传参和call或apply类似</li><li>不会执行对应的函数，call或apply会自动执行对应的函数</li><li>返回对函数的引用</li></ul><p><strong>下面例子：</strong>当点击网页时，<code>EventClick</code>被触发执行，输出<code>JSLite.io p1 p2</code>, 说明<code>EventClick</code>中的<code>this</code>被<code>bind</code>改变成了<code>obj</code>对象。如果你将<code>EventClick.bind(obj,&#39;p1&#39;,&#39;p2&#39;)</code> 变成 <code>EventClick.call(obj,&#39;p1&#39;,&#39;p2&#39;)</code> 的话，页面会直接输出 <code>JSLite.io p1 p2</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;name:&#x27;JSLite.io&#x27;&#125;;</span><br><span class="line">/**</span><br><span class="line"> * 给document添加click事件监听，并绑定EventClick函数</span><br><span class="line"> * 通过bind方法设置EventClick的this为obj，并传递参数p1,p2</span><br><span class="line"> */</span><br><span class="line">document.addEventListener(&#x27;click&#x27;,EventClick.bind(obj,&#x27;p1&#x27;,&#x27;p2&#x27;),false);</span><br><span class="line">//当点击网页时触发并执行</span><br><span class="line">function EventClick(a,b)&#123;</span><br><span class="line">    console.log(</span><br><span class="line">            this.name, //JSLite.io</span><br><span class="line">            a, //p1</span><br><span class="line">            b  //p2</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">// JSLite.io p1 p2</span><br></pre></td></tr></table></figure><p>手写bind</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.cs_bind = <span class="function"><span class="keyword">function</span>(<span class="params">obj,...args</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    obj = obj || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    obj[fn] = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="function"><span class="keyword">function</span>(<span class="params">...innerArgs</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> <span class="keyword">instanceof</span> _this)&#123;<span class="comment">//当作构造函数使用</span></span><br><span class="line">            <span class="built_in">this</span>[fn] = _this;</span><br><span class="line">            <span class="built_in">this</span>[fn](...[...args,...innerArgs]);</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>[fn];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//没有当作构造函数使用</span></span><br><span class="line">            obj[fn](...[...args,...innerArgs])</span><br><span class="line">            <span class="keyword">delete</span> obj[fn];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.prototype = <span class="built_in">Object</span>.create(<span class="built_in">this</span>.prototype);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-原型-继承"><a href="#3-原型-继承" class="headerlink" title="3.原型/继承"></a>3.原型/继承</h3><h4 id="1-原型"><a href="#1-原型" class="headerlink" title="1.原型"></a>1.原型</h4><p><strong>原型链经典神图</strong></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131611904.png" alt="image-20220313161148825"></p><ul><li>function Foo 就是一个方法，比如JavaScript 中内置的 Array、String 等</li><li>function Object 就是一个 Object</li><li>function Function 就是 Function</li><li>以上都是 function，所以 <code>.__proto__</code>都是<code>Function.prototype</code></li><li>再次强调，String、Array、Number、Function、Object都是 function</li></ul><hr><p><strong>prototype的定义</strong></p><p>在规范里,prototype被定义为:<strong>给其他对象提供共享属性的对象</strong></p><p>也就是说prototype自己也是对象,只是被用来承担某个只能罢了</p><p><strong>prototype描述的是两个对象之间的某种关系(其中一个对象为另一个对象提供属性访问权限).所有对象都可以作为另一个对象的prototype来使用</strong></p><hr><p><strong>函数对象和普通对象</strong></p><p>在JavaScript中,<strong>万物皆对象</strong>,但是不同的对象是存在着差异性的.</p><p>在JavaScript中，我们将对象分为函数对象和普通对象,<strong>函数对象就是JavaScript用函数来模拟的类实现</strong>,<strong>Object</strong>和<strong>Function</strong>就是典型的函数对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> fun3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;console.log(name)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">const</span> obj3 = <span class="keyword">new</span> fun1();</span><br><span class="line"><span class="keyword">const</span> obj4 = <span class="keyword">new</span> <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fun1);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fun2);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fun3);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj1);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj2);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj3);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj4);<span class="comment">//object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码中，<code>obj1</code>，<code>obj2</code>，<code>obj3</code>，<code>obj4</code>都是普通对象，<code>fun1</code>，<code>fun2</code>，<code>fun3</code> 都是 <code>Function</code> 的实例，也就是函数对象。</p><p>总结:<strong>所有的Function的实例都是函数对象,其他的均为普通对象,包括Function实例的实例</strong></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131629020.webp" alt="img"></p><p><strong>JavaScript中万物皆对象,而对象皆出自构造函数</strong></p><p>对于<strong>Function</strong>对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">//true</span></span><br></pre></td></tr></table></figure><hr><p><strong>__ proto__</strong></p><p>首先我们需要明确:</p><ul><li><strong>__ proto__<strong>和</strong>constructor</strong>是<strong>对象</strong>独有的</li><li><strong>prototype</strong>属性是<strong>函数</strong>独有的</li></ul><p>但是在JavaScript中,函数也是一种特殊的对象,<strong>所以函数也拥有<code>__proto__</code>和 <code>constructor</code>属性</strong></p><p>结合上面我们介绍的 <code>Object</code> 和 <code>Function</code> 的关系，看一下代码和关系图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;…&#125;;</span><br><span class="line">let nealyang = new Person(); </span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131647800.webp" alt="__proto__"></p><p>再梳理上图关系之前，我们再来讲解下<code>__proto__</code>。</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131647353.webp" alt="img"></p><p>这里我们需要知道的是，<code>__proto__</code>是对象所独有的，并且<code>__proto__</code>是<strong>一个对象指向另一个对象</strong>，也就是他的原型对象。我们也可以理解为父类对象。它的作用就是当你在访问一个对象属性的时候，如果该对象内部不存在这个属性，那么就回去它的<code>__proto__</code>属性所指向的对象（父类对象）上查找，如果父类对象依旧不存在这个属性，那么就回去其父类的<code>__proto__</code>属性所指向的父类的父类上去查找。以此类推，知道找到 <code>null</code>。而这个查找的过程，也就构成了我们常说的<strong>原型链</strong>。</p><p><strong>原型链就是根据对象的__ proto __指向,一层一层连接起来的具有关联性的对象集合</strong></p><hr><p><strong>prototype</strong></p><p>prototype 被定义为：<strong>给其它对象提供共享属性的对象</strong>。<code>prototype</code> 自己也是对象，只是被用以承担某个职能罢了</p><p>所有对象都可以作为另一个对象的<strong>prototype</strong>使用</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131651653.webp" alt="img"></p><p><strong>任何函数在创建的时候，都会默认给该函数添加 <code>prototype</code> 属性.</strong></p><hr><p><strong>constructor</strong></p><p><strong>constructor</strong>属性也是对象所独有的,<strong>他是一个对象指向同一个函数，这个函数就是该对象的构造函数</strong></p><p>每个对象都有其对应的构造函数,它由本身或者继承而来.</p><p><strong>函数.prototype.constructor</strong>===<strong>该函数本身</strong></p><p><strong>constructor属性只有prototype对象才有</strong>,函数在创建的时候,JavaScript会同时创建一个该函数对应的prototype对象,<strong>而函数创建的对象.proto === 该函数.prototype</strong></p><p>通过函数创建的对象即使自己没有<code>constructor</code>属性，它也能通过<code>__proto__</code>找到对应的<code>constructor</code>，所以<strong>任何对象最终都可以找到其对应的构造函数。</strong></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131707239.webp" alt="img"></p><hr><p><strong>原型链</strong></p><p><strong>原型链就是根据对象的__ proto __指向,一层一层连接起来的具有关联性的对象集合</strong></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131709481.webp" alt="img"></p><hr><p><strong>typeof</strong>&amp;&amp;<strong>instanceof</strong>原理</p><p><strong>typeof</strong></p><p>用于判断变量的类型,可以判断的类型有:<strong>number</strong>、<strong>undefined</strong>、<strong>String</strong>、<strong>Boolean</strong>、<strong>function</strong>、<strong>object</strong>、<strong>symbol</strong>，但是<strong>typeof在判断object时不能明确的告诉你属于哪一类object</strong></p><p>所以<strong>一般不用typeof来判断object的类型</strong></p><p>为什么<strong>typeof null</strong> 返回’<strong>object</strong>’？</p><p><strong>因为null代表的是空指针对象,所以typeof null 为object</strong></p><p>具体原因:在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 <code>null</code> 代表的是空指针（大多数平台下值为 0x00），因此，<code>null</code> 的类型标签是 0，<code>typeof null</code> 也因此返回 <code>&quot;object&quot;</code></p><hr><p><strong>instanceof</strong></p><p><code>instanceof</code> 运算符用来检测 <code>constructor.prototype</code> 是否存在于参数 <code>object</code> 的原型链上。与 <code>typeof</code> 方法不同的是，<code>instanceof</code> 方法要求开发者明确地确认对象为某特定类型。</p><p><strong>instanceof</strong>可以判断<strong>一个实例是否是其父类型或者祖先类型的实例。</strong></p><p><strong>instanceof</strong>是如何进行判断的?</p><ul><li>表达式**:A instanceof B**:如果B的显式原型(prototype)对象在A的原型链上,返回true,否则返回false</li></ul><p><strong>手写instanceof</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_instanceof</span>(<span class="params">child,father</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fp =  father.prototype   </span><br><span class="line">    <span class="keyword">let</span> cp = child.__proto__</span><br><span class="line">    <span class="keyword">while</span>(cp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cp.__proto__ === father.protype)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cp = cp.__proto__;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);<span class="comment">//false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);<span class="comment">//false </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Foo <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(Foo <span class="keyword">instanceof</span> Foo);<span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>为什么 <code>Object</code> 和 <code>Function</code> <code>instanceof</code> 自己等于 <code>true</code>，而其他类 <code>instanceof</code> 自己却又不等于 <code>true</code> 呢？如何解释？</strong></p><ul><li><p><code>Object instanceof Object</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了方便表述，首先区分左侧表达式和右侧表达式</span></span><br><span class="line">ObjectL = <span class="built_in">Object</span>, ObjectR = <span class="built_in">Object</span>; </span><br><span class="line"><span class="comment">// 下面根据规范逐步推演</span></span><br><span class="line">O = ObjectR.prototype = <span class="built_in">Object</span>.prototype </span><br><span class="line">L = ObjectL.__proto__ = <span class="built_in">Function</span>.prototype </span><br><span class="line"><span class="comment">// 第一次判断</span></span><br><span class="line">O != L </span><br><span class="line"><span class="comment">// 循环查找 L 是否还有 __proto__ </span></span><br><span class="line">L = <span class="built_in">Function</span>.prototype.__proto__ = <span class="built_in">Object</span>.prototype </span><br><span class="line"><span class="comment">// 第二次判断</span></span><br><span class="line">O == L </span><br><span class="line"><span class="comment">// 返回 true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>Function instanceof Function</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了方便表述，首先区分左侧表达式和右侧表达式</span></span><br><span class="line">FunctionL = <span class="built_in">Function</span>, FunctionR = <span class="built_in">Function</span>; </span><br><span class="line"><span class="comment">// 下面根据规范逐步推演</span></span><br><span class="line">O = FunctionR.prototype = <span class="built_in">Function</span>.prototype </span><br><span class="line">L = FunctionL.__proto__ = <span class="built_in">Function</span>.prototype </span><br><span class="line"><span class="comment">// 第一次判断</span></span><br><span class="line">O == L </span><br><span class="line"><span class="comment">// 返回 true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>Foo instanceof Foo</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了方便表述，首先区分左侧表达式和右侧表达式</span></span><br><span class="line">FooL = Foo, FooR = Foo; </span><br><span class="line"><span class="comment">// 下面根据规范逐步推演</span></span><br><span class="line">O = FooR.prototype = Foo.prototype </span><br><span class="line">L = FooL.__proto__ = <span class="built_in">Function</span>.prototype </span><br><span class="line"><span class="comment">// 第一次判断</span></span><br><span class="line">O != L </span><br><span class="line"><span class="comment">// 循环再次查找 L 是否还有 __proto__ </span></span><br><span class="line">L = <span class="built_in">Function</span>.prototype.__proto__ = <span class="built_in">Object</span>.prototype </span><br><span class="line"><span class="comment">// 第二次判断</span></span><br><span class="line">O != L </span><br><span class="line"><span class="comment">// 再次循环查找 L 是否还有 __proto__ </span></span><br><span class="line">L = <span class="built_in">Object</span>.prototype.__proto__ = <span class="literal">null</span> </span><br><span class="line"><span class="comment">// 第三次判断</span></span><br><span class="line">L == <span class="literal">null</span> </span><br><span class="line"><span class="comment">// 返回 false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><hr><hr><h4 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h4><p>在JavaScript中,有两类原型继承的方式:<strong>显式继承</strong>和<strong>隐式继承</strong></p><hr><h5 id="new"><a href="#new" class="headerlink" title="new"></a><strong>new</strong></h5><p><strong>new用来创建构造函数的实例对象</strong></p><p><strong>手写new</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn,...args</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    obj.__proto__ = fn.prototype;<span class="comment">//将obj的__proto__赋值为fn的prototype</span></span><br><span class="line">    fn.apply(obj,args);<span class="comment">//将构造函数的this指向这个对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h5 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a><strong>类式继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.superValue = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.superValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line"></span><br><span class="line">SubClass.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> SubClass();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( instance  <span class="keyword">instanceof</span> SuperClass);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log( instance  <span class="keyword">instanceof</span> SubClass);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(SubClass <span class="keyword">instanceof</span> SuperClass);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>虽然实现起来清晰简洁，但是这种继承方式有两个缺点：</p><ul><li>由于子类通过其原型prototype对父类实例化，继承了父类，所以说父类中如果共有属性是引用类型，就会在子类中被所有的实例所共享，因此一个子类的实例更改子类原型从父类构造函数中继承的共有属性就会直接影响到其他的子类</li><li>由于子类实现的继承是靠其原型prototype对父类进行实例化实现的，因此在创建父类的时候，是无法向父类传递参数的。因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化</li></ul><hr><h5 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a><strong>构造函数继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.books = [<span class="string">&#x27;js&#x27;</span>,<span class="string">&#x27;css&#x27;</span>];</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.showBooks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.books);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    SuperClass.call(<span class="built_in">this</span>,id)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> SubClass(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="keyword">new</span> SubClass(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">instance1.books.push(<span class="string">&#x27;html&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1)</span><br><span class="line"><span class="built_in">console</span>.log(instance2)</span><br><span class="line">instance1.showBooks();<span class="comment">//TypeError</span></span><br></pre></td></tr></table></figure><p><code>SuperClass.call(this,id)</code>当然就是构造函数继承的核心语句了.由于父类中给this绑定属性，因此子类自然也就继承父类的共有属性。由于这种类型的继承没有涉及到原型<code>prototype</code>，所以父类的原型方法自然不会被子类继承，而如果想被子类继承，就必须放到构造函数中，这样创建出来的每一个实例都会单独的拥有一份而不能共用，这样就违背了代码复用的原则，所以综合上述两种，我们提出了组合式继承方法</p><hr><h5 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a><strong>组合式继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name; </span><br><span class="line">  <span class="built_in">this</span>.books = [<span class="string">&#x27;Js&#x27;</span>,<span class="string">&#x27;CSS&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.getBooks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.books);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name,time</span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="built_in">this</span>,name);</span><br><span class="line">  <span class="built_in">this</span>.time = time;</span><br><span class="line">&#125;</span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line"></span><br><span class="line">SubClass.prototype.getTime = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我们就解决了之前说到的一些问题，但是是不是从代码看，还是有些不爽呢？至少这个<code>SuperClass</code>的构造函数执行了两遍就感觉非常的不妥.</p><h5 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a><strong>原型式继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//声明一个过渡对象</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">  <span class="comment">//过渡对象的原型继承父对象</span></span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="comment">//返回过渡对象的实例，该对象的原型继承了父对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型式继承大致的实现方式如上，是不是想到了我们<code>new</code>关键字模拟的实现？</p><p>其实这种方式和类式继承非常的相似，他只是对类式继承的一个封装，其中的过渡对象就相当于类式继承的子类，只不过在原型继承中作为一个普通的过渡对象存在，目的是为了创建要返回的新的实例对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">    name:&#x27;js book&#x27;,</span><br><span class="line">    likeBook:[&#x27;css Book&#x27;,&#x27;html book&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">var newBook = inheritObject(book);</span><br><span class="line">newBook.name = &#x27;ajax book&#x27;;</span><br><span class="line">newBook.likeBook.push(&#x27;react book&#x27;);</span><br><span class="line">var otherBook = inheritObject(book);</span><br><span class="line">otherBook.name = &#x27;canvas book&#x27;;</span><br><span class="line">otherBook.likeBook.push(&#x27;node book&#x27;);</span><br><span class="line">console.log(newBook,otherBook);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如上代码我们可以看出，原型式继承和类式继承一个样子，对于引用类型的变量，还是存在子类实例共享的情况。</p><p>所以，我们还有下面的寄生式继承</p><hr><h5 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a><strong>寄生式继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;    <span class="attr">name</span>:<span class="string">&#x27;js book&#x27;</span>,    <span class="attr">likeBook</span>:[<span class="string">&#x27;html book&#x27;</span>,<span class="string">&#x27;css book&#x27;</span>]&#125;<span class="function"><span class="keyword">function</span> <span class="title">createBook</span>(<span class="params">obj</span>) </span>&#123;    <span class="comment">//通过原型方式创建新的对象  var o = new inheritObject(obj);  // 拓展新对象  o.getName = function(name) &#123;    console.log(name)  &#125;  // 返回拓展后的新对象  return o;&#125;</span></span><br></pre></td></tr></table></figure><p>其实寄生式继承就是对原型继承的拓展，一个二次封装的过程，这样新创建的对象不仅仅有父类的属性和方法，还新增了别的属性和方法。</p><h5 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a><strong>寄生组合式继承</strong></h5><p>回到之前的组合式继承，那时候我们将类式继承和构造函数继承组合使用，但是存在的问题就是子类不是父类的实例，而子类的原型是父类的实例，所以才有了寄生组合式继承</p><p>而寄生组合式继承是寄生式继承和构造函数继承的组合。但是这里寄生式继承有些特殊，这里他处理不是对象，而是类的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritObject</span>(<span class="params">o</span>) </span>&#123;  <span class="comment">//声明一个过渡对象  function F() &#123; &#125;  //过渡对象的原型继承父对象  F.prototype = o;  //返回过渡对象的实例，该对象的原型继承了父对象  return new F();&#125;function inheritPrototype(subClass,superClass) &#123;    // 复制一份父类的原型副本到变量中  var p = inheritObject(superClass.prototype);  // 修正因为重写子类的原型导致子类的constructor属性被修改  p.constructor = subClass;  // 设置子类原型  subClass.prototype = p;&#125;</span></span><br></pre></td></tr></table></figure><p>组合式继承中，通过构造函数继承的属性和方法都是没有问题的，所以这里我们主要探究通过寄生式继承重新继承父类的原型。</p><p>我们需要继承的仅仅是父类的原型，不用去调用父类的构造函数。换句话说，在构造函数继承中，我们已经调用了父类的构造函数。因此我们需要的就是父类的原型对象的一个副本，而这个副本我们可以通过原型继承拿到，但是这么直接赋值给子类会有问题，因为对父类原型对象复制得到的复制对象p中的<code>constructor</code>属性指向的不是<code>subClass</code>子类对象，因此在寄生式继承中要对复制对象p做一次增强，修复起<code>constructor</code>属性指向性不正确的问题，最后将得到的复制对象p赋值给子类原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;  <span class="built_in">this</span>.name = name;  <span class="built_in">this</span>.books=[<span class="string">&#x27;js book&#x27;</span>,<span class="string">&#x27;css book&#x27;</span>];&#125;SuperClass.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);&#125;<span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name,time</span>) </span>&#123;  SuperClass.call(<span class="built_in">this</span>,name);  <span class="built_in">this</span>.time = time;&#125;inheritPrototype(SubClass,SuperClass);SubClass.prototype.getTime = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="built_in">this</span>.time);&#125;<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubClass(<span class="string">&#x27;React&#x27;</span>,<span class="string">&#x27;2017/11/11&#x27;</span>)<span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubClass(<span class="string">&#x27;Js&#x27;</span>,<span class="string">&#x27;2018/22/33&#x27;</span>);instance1.books.push(<span class="string">&#x27;test book&#x27;</span>);<span class="built_in">console</span>.log(instance1.books,instance2.books);instance2.getName();instance2.getTime();</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131828871.webp" alt="img"></p><p>这种方式继承其实如上图所示，其中最大的改变就是子类原型中的处理，被赋予父类原型中的一个引用，这是一个对象，因此有一点你需要注意，就是子类在想添加原型方法必须通过prototype.来添加，否则直接赋予对象就会覆盖从父类原型继承的对象了.</p><h3 id="4-promise"><a href="#4-promise" class="headerlink" title="4.promise"></a>4.promise</h3><h4 id="1-什么是promise-它用来解决什么问题"><a href="#1-什么是promise-它用来解决什么问题" class="headerlink" title="1.什么是promise?它用来解决什么问题?"></a>1.<strong>什么是promise?它用来解决什么问题?</strong></h4><blockquote><p>Promise是异步编程的一种解决方案:从语法上讲，promise是一个对象,可以通过它获取异步操作的消息；从本意上讲，他是承诺，承诺他过一段时间会给你一个结果。promise有三种状态:<strong>pending</strong>(等待态)，<strong>fulfiled</strong>(成功态),<strong>rejected</strong>(失败态);<strong>状态一旦改变，就不会再改变</strong>(也就是说promise的操作是不可逆的)，<strong>创造promise实例后，他会立即执行</strong></p></blockquote><p>promise是用来解决两个问题:</p><ul><li><strong>回调地狱</strong>，减少多层回调嵌套</li><li><strong>异步执行</strong>(但是不能说promise是异步的)</li></ul><hr><h4 id="2-promise用法"><a href="#2-promise用法" class="headerlink" title="2.promise用法"></a>2.<strong>promise用法</strong></h4><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132032800.png" alt="image-20220313203224725"></p><h5 id="创建promise对象"><a href="#创建promise对象" class="headerlink" title="创建promise对象"></a><strong>创建promise对象</strong></h5><p>promise是一个<strong>构造函数</strong>，可以通过<strong>new</strong>来创建实例对象</p><p>Promise的构造函数接收<strong>一个参数</strong>:函数,并且这个函数需要传入<strong>两个参数</strong>:</p><ul><li><strong>resolve</strong>:异步操作执行成功后的回调函数</li><li><strong>reject</strong>:异步操作执行失败后的回调函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;    <span class="comment">//做一些异步操作    setTimeout(() =&gt; &#123;        console.log(&#x27;执行完成&#x27;);        resolve(&#x27;我是成功！！&#x27;);    &#125;, 2000);&#125;);</span></span><br></pre></td></tr></table></figure><hr><h5 id="then链式调用"><a href="#then链式调用" class="headerlink" title="then链式调用"></a><strong>then链式调用</strong></h5><p>promise可以通过链式调用来减少多层回调嵌套</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,rehect</span>) =&gt;</span>&#123;     resolve(<span class="string">&#x27;ok&#x27;</span>);          &#125;);p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(data);&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(data);&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(data);&#125;);</span><br></pre></td></tr></table></figure><hr><h5 id="reject的用法"><a href="#reject的用法" class="headerlink" title="reject的用法"></a><strong>reject的用法</strong></h5><p>把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;        <span class="comment">//做一些异步操作      setTimeout(function()&#123;            var num = Math.ceil(Math.random()*10); //生成1-10的随机数            if(num&lt;=5)&#123;                resolve(num);            &#125;            else&#123;                reject(&#x27;数字太大了&#x27;);            &#125;      &#125;, 2000);    &#125;);    p.then((data) =&gt; &#123;            console.log(&#x27;resolved&#x27;,data);        &#125;,(err) =&gt; &#123;            console.log(&#x27;rejected&#x27;,err);        &#125;    ); </span></span><br></pre></td></tr></table></figure><p>then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132043346.webp" alt="img">或者<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16377e4fd8619228~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><hr><h5 id="catch的用法"><a href="#catch的用法" class="headerlink" title="catch的用法"></a><strong>catch的用法</strong></h5><p>catch的作用与then的第二个参数类似,用于捕获失败的回调,不过与后者不同的是，在链式调用时，如果代码出错了，他不会报错使js执行停止，而是会进入到catch方法中,并捕获到异常</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>,data);    <span class="built_in">console</span>.log(somedata); <span class="comment">//此处的somedata未定义&#125;).catch((err) =&gt; &#123;    console.log(&#x27;rejected&#x27;,err);&#125;);</span></span><br></pre></td></tr></table></figure><p>在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132046474.webp" alt="img"></p><p>也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能</p><hr><h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a><strong>Promise.all()</strong></h5><p><strong>用法</strong>:接受一个<strong>数组</strong>参数，里面的值最终都返回Promise对象</p><p><strong>特点</strong>:谁执行<strong>慢</strong>,以谁为准执行回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;&#125;)<span class="keyword">let</span> Promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;&#125;)<span class="keyword">let</span> Promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;&#125;)<span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([Promise1, Promise2, Promise3])p.then(<span class="function"><span class="title">funciton</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 三个都成功则成功  &#125;, function()&#123;  // 只要有失败，则失败 &#125;)</span></span><br></pre></td></tr></table></figure><p>应用场景:<em>一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</em></p><hr><h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a><strong>Promise.race()</strong></h5><p><strong>用法</strong>:接受一个数组参数,里面的值最终都返回Promise对象</p><p><strong>特点</strong>:谁执行<strong>快</strong>，以谁为准执行回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;    <span class="comment">// resolve(1);    reject(1);&#125;)const promise2 = new Promise(function(resolve, reject) &#123;    resolve(2);&#125;)const promise3 = new Promise(function(resolve, reject) &#123;    resolve(3);&#125;)const p = Promise.race([promise1,promise2,promise3])p.then((data) =&gt; &#123;    console.log(&quot;data&quot;,data);&#125;).catch((err) =&gt; &#123;    console.log(&quot;err&quot;,err);&#125;)</span></span><br></pre></td></tr></table></figure><hr><h5 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a><strong>Promise.any()</strong></h5><p><strong>注意</strong>:<strong>Promise.any()尚未被所有浏览器所支持</strong>,node环境下不能使用这个API</p><p><strong>用法</strong>:接受一个数组参数,里面的值最终都返回Promise对象</p><p><strong>特点</strong>:只要有一个promise执行成功,那么就返回那个成功的promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;    <span class="comment">// resolve(1);    reject(1);&#125;)const promise2 = new Promise(function(resolve, reject) &#123;    resolve(2);&#125;)const promise3 = new Promise(function(resolve, reject) &#123;    resolve(3);&#125;)const p = Promise.any([promise1,promise2,promise3])p.then((data) =&gt; &#123;    console.log(&quot;data&quot;,data);&#125;).catch((err) =&gt; &#123;    console.log(&quot;err&quot;,err);&#125;)</span></span><br></pre></td></tr></table></figure><hr><h4 id="3-async-await"><a href="#3-async-await" class="headerlink" title="3.async/await"></a>3.<strong>async/await</strong></h4><h5 id="1-什么是async"><a href="#1-什么是async" class="headerlink" title="1.什么是async?"></a>1.什么是async?</h5><p><strong>介绍</strong>:async函数是使用<code>async</code>关键字声明的函数。 async函数是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction"><code>AsyncFunction</code></a>构造函数的实例， 并且其中允许使用<code>await</code>关键字。<code>async</code>和<code>await</code>关键字让我们可以用一种更简洁的方式写出基于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>的异步行为，而无需刻意地链式调用<code>promise</code>。</p><p><strong>特性</strong>:async函数可能包含0个或者多个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await"><code>await</code></a>表达式。await表达式会暂停整个async函数的执行进程并出让其控制权，只有当其等待的基于promise的异步操作被兑现或被拒绝之后才会恢复进程。promise的解决值会被当作该await表达式的返回值。使用<code>async</code> / <code>await</code>关键字就可以在异步代码中使用普通的<code>try</code> / <code>catch</code>代码块。</p><p><code>async</code> 函数是 <code>Generator</code> 函数的语法糖。使用 关键字 <code>async</code> 来表示，在函数内部使用 <code>await</code> 来表示异步。相较于 <code>Generator</code>，<code>async</code> 函数的改进在于下面四点：</p><ul><li><strong>内置执行器</strong>。<code>Generator</code> 函数的执行必须依靠执行器，而 <code>async</code> 函数自带执行器，调用方式跟普通函数的调用一样</li><li><strong>更好的语义</strong>。<code>async</code> 和 <code>await</code> 相较于 <code>*</code> 和 <code>yield</code> 更加语义化</li><li><strong>更广的适用性</strong>。<code>co</code> 模块约定，<code>yield</code> 命令后面只能是 Thunk 函数或 Promise对象。而 <code>async</code> 函数的 <code>await</code> 命令后面则可以是 Promise 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作）</li><li><strong>返回值是 Promise</strong>。<code>async</code> 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 <code>then()</code> 方法进行调用</li></ul><p><code>async</code>是ES7新出的特性，表明当前函数是异步函数，不会阻塞线程导致后续代码停止运行。</p><hr><h5 id="2-async函数怎么用"><a href="#2-async函数怎么用" class="headerlink" title="2.async函数怎么用?"></a>2.async函数怎么用?</h5><p><strong>async</strong>用来声明函数是一个异步函数</p><p><strong>await</strong>表示紧跟在后面的表达式需要等待结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span>(<span class="params"></span>)</span>&#123;    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;&#125;asuncFn();</span><br></pre></td></tr></table></figure><p><strong>async</strong>函数返回的是一个<strong>promise</strong>对象,状态为<strong>resolved</strong>,参数是<strong>return</strong>的值,所以async函数可以链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> <span class="string">&#x27;我后执行&#x27;</span>&#125;asyncFn().then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;    <span class="built_in">console</span>.log(result);<span class="comment">//我后执行&#125;)console.log(&#x27;我先执行&#x27;);</span></span><br></pre></td></tr></table></figure><p><strong>async</strong>函数返回的是一个promise对象，如果再执行过程中函数<strong>内部抛出异常</strong>或者返回<strong>reject</strong>，都会是的函数的promise状态变为失败<strong>rejected</strong>，函数抛出异常后，可以通过<strong>catch</strong>接收到返回的错误信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">return</span>  <span class="built_in">Promise</span>.reject(<span class="string">&#x27;reason&#x27;</span>)    <span class="comment">// throw new Error(&#x27;has error&#x27;)&#125;asyncFn().then(result =&gt; &#123;    console.log(result);&#125;,reason =&gt; &#123;    console.log(reason);&#125;).catch(err =&gt; &#123;    console.log(err);&#125;)console.log(&#x27;我先执行&#x27;);</span></span><br></pre></td></tr></table></figure><p>async函数接收到的返回值,如果不是<strong>异常</strong>或者<strong>reject</strong>，则判定成功,即<strong>resolve</strong></p><p>以下结果会使async函数判定<strong>失败</strong>:</p><ul><li>内部含有直接使用并且未声明的变量或者函数。</li><li>内部抛出一个错误<code>throw new Error</code>或者返回<code>reject</code>状态<code>return Promise.reject(&#39;执行失败&#39;)</code></li><li>函数方法执行出错（🌰：Object使用push()）等等…</li></ul><p>async函数如果需要返回结果,都必须使用<strong>return</strong>来返回,不论是<strong>reject</strong>还是<strong>resolve</strong>都需要使用return，不然就会返回一个值为<strong>undefined</strong> 的<strong>resolved</strong>(成功)状态</p><hr><h5 id="3-await是什么"><a href="#3-await是什么" class="headerlink" title="3.await是什么"></a>3.await是什么</h5><p><strong>await</strong>的意思是<strong>async wait</strong>(异步等待),<strong>await必须配合async使用</strong>，<strong>async函数必须等到内部所有的await命令的promise执行完,才会返回结果</strong></p><p><strong>打个比方，await是学生，async是校车，必须等人齐了再开车。</strong></p><p>就是说，必须等所有<code>await</code> 函数执行完毕后，才会告诉<code>promise</code>我成功了还是失败了，执行<code>then</code>或者<code>catch</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async function awaitReturn() &#123;         return await 1&#125;;awaitReturn().then(success =&gt; console.log(&#x27;成功&#x27;, success))             .catch(error =&gt; console.log(&#x27;失败&#x27;,error))</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203141014457.webp" alt="img"></p><p>async中的await会返回一个<strong>promise</strong>,<strong>下一个await必须等待上一个await返回promise结果状态才会开始执行</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> time1;<span class="keyword">let</span> time2;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;    time1 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();    <span class="built_in">console</span>.log(<span class="string">&quot;第一个函数执行完毕&quot;</span>);&#125;, <span class="number">1000</span>);<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;    time2 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();    <span class="built_in">console</span>.log(<span class="string">&quot;第二个函数执行完毕&quot;</span>,time2-time1);&#125;, <span class="number">2000</span>);<span class="keyword">const</span> timeoutFn = <span class="function"><span class="keyword">function</span>(<span class="params">timeout</span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">setTimeout</span>(resolve, timeout);    &#125;);&#125;<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeOut</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">await</span> timeoutFn(<span class="number">1000</span>);    <span class="keyword">await</span> timeoutFn(<span class="number">2000</span>);    <span class="built_in">console</span>.log(<span class="string">&quot;完成&quot;</span>);&#125;timeOut()</span><br></pre></td></tr></table></figure><p>不考虑<strong>event loop</strong>(事件循环)</p><p>上面的例子中 两个<strong>setTimeout</strong>函数会在<strong>2s</strong>左右(之所以说左右这个词,是因为函数执行会消耗几毫秒时间)，</p><p>而<strong>timeOut</strong>函数则需要<strong>3s</strong>左右的时间才会执行完成,这也说明了下一个<strong>await</strong>必须等待上一个<strong>await</strong>返回promise结果状态才会开始执行的结论是正确的</p><hr><p><strong>await后面的表达式应该返回一个promise，如果不是promise，js内部也会将其转换为一个resolved状态的 promise</strong></p><h3 id="5-深浅拷贝"><a href="#5-深浅拷贝" class="headerlink" title="5.深浅拷贝"></a>5.深浅拷贝</h3><p>JavaScript的数据类型分为<strong>基本数据类型</strong>和<strong>引用数据类型</strong>。</p><p>对于<strong>基本数据类型</strong>的拷贝，并没有深浅拷贝的区别，我们所说的<strong>深浅拷贝都是对于引用数据类型而言的</strong>。</p><h4 id="什么是浅拷贝"><a href="#什么是浅拷贝" class="headerlink" title="什么是浅拷贝?"></a>什么是浅拷贝?</h4><p>浅拷贝的意思就是只复制引用，而未复制真正的值。</p><p>当我们浅拷贝一个数组或者对象后，改变这个新的数组或对象,那么被我们拷贝的数组和对象也会改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];<span class="comment">//数组是引用类型const originObj = &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;//对象是引用类型let originType = [1,2,3];let originNumber = 1; //基本值类型,不存在深浅拷贝之分const clonedArray = originArray;const clonedObj = originObj;let cloneNumber = originNumber;let cloneType = originType;clonedArray.push(6);clonedObj.a = &#x27;aa&#x27;;cloneNumber = 2;cloneType = &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,b:&#x27;c&#x27;&#125;console.log(originArray);//[ 1, 2, 3, 4, 5, 6 ]console.log(originObj);//&#123; a: &#x27;aa&#x27;, b: &#x27;b&#x27;, c: [ 1, 2, 3 ], d: &#123; dd: &#x27;dd&#x27; &#125; &#125;console.log(originNumber);//1console.log(originType);//当我们改变了变量引用的类型时,这个新变量和被拷贝的变量就没有了任何联系(二者指向不同引用)</span></span><br></pre></td></tr></table></figure><hr><h4 id="什么是深拷贝？"><a href="#什么是深拷贝？" class="headerlink" title="什么是深拷贝？"></a>什么是深拷贝？</h4><p>深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。</p><p><strong>只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。</strong></p><p>目前实现深拷贝的方法不多，主要是两种：</p><ol><li>利用 <code>JSON</code> 对象中的 <code>parse</code> 和 <code>stringify</code></li><li>利用递归来实现每一层都重新创建对象并赋值</li></ol><hr><p><strong>利用JSON.stringify/parse的方法实现深拷贝</strong></p><p>JSON.stringify的作用是<strong>将一个javascript值转换成json字符串</strong></p><p>JSON.parse的作用是<strong>将一个JSON字符串转换成javascript值或对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];<span class="keyword">const</span> cloneArray = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(originArray));<span class="built_in">console</span>.log(cloneArray === originArray); <span class="comment">// falseconst originObj = &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;const cloneObj = JSON.parse(JSON.stringify(originObj));console.log(cloneObj === originObj); // falsecloneObj.a = &#x27;aa&#x27;;cloneObj.c = [1,1,1];cloneObj.d.dd = &#x27;doubled&#x27;;console.log(cloneObj); // &#123;a:&#x27;aa&#x27;,b:&#x27;b&#x27;,c:[1,1,1],d:&#123;dd:&#x27;doubled&#x27;&#125;&#125;;console.log(originObj); // &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;</span></span><br></pre></td></tr></table></figure><p>上面的例子可以实现深拷贝,但是这种方式只能适用于一些简单的情况，因为<strong>在使用HSON.stringify()时，<code>undefined</code>、<code>function</code>、<code>symbol</code> 会在转换过程中被忽略。。</strong></p><p>如果对象中含有以上几种类型时，就不能用这个方法进行深拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originObj = &#123;  <span class="attr">name</span>:<span class="string">&#x27;axuebin&#x27;</span>,  <span class="attr">sayHello</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);  &#125;&#125;<span class="built_in">console</span>.log(originObj); <span class="comment">// &#123;name: &quot;axuebin&quot;, sayHello: ƒ&#125;const cloneObj = JSON.parse(JSON.stringify(originObj));console.log(cloneObj); // &#123;name: &quot;axuebin&quot;&#125;</span></span><br></pre></td></tr></table></figure><hr><p><strong>使用递归的方法实现深拷贝</strong></p><p>递归的思想就很简单了，就是对每一层的数据都实现一次 <code>创建对象-&gt;对象赋值</code> 的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现深拷贝function  deepClone(source) &#123;    const targetObj = source.constructor === Array ? [] : &#123;&#125;; // 判断复制的目标是数组还是对象        for (const key in source) &#123;        if (source.hasOwnProperty(key)) &#123;                        if(source[key] &amp;&amp; typeof source[key] === &#x27;object&#x27;)&#123;//如果值是对象就递归                targetObj[key] = source[key].constructor === &#x27;Array&#x27; ? [] : &#123;&#125;;                deepClone(targetObj[key]);            &#125;else&#123;//如果不是就直接赋值                targetObj[key] = source[key];            &#125;                    &#125;    &#125;    return targetObj;&#125;const originObj = &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;const cloneObj = deepClone(originObj);console.log(cloneObj === originObj); // falsecloneObj.a = &#x27;aa&#x27;;cloneObj.c = [1,1,1];cloneObj.d.dd = &#x27;doubled&#x27;;console.log(cloneObj); // &#123;a:&#x27;aa&#x27;,b:&#x27;b&#x27;,c:[1,1,1],d:&#123;dd:&#x27;doubled&#x27;&#125;&#125;;console.log(originObj); // &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;const originObj2 = &#123;    name:&#x27;张振明&#x27;,    sayHello:function()&#123;      console.log(&#x27;Hello World&#x27;);    &#125;  &#125;  console.log(originObj2); // &#123;name: &quot;张振明&quot;, sayHello: ƒ&#125;  const cloneObj2 = deepClone(originObj2);  console.log(cloneObj2); // &#123;name: &quot;张振明&quot;, sayHello: ƒ&#125;</span></span><br></pre></td></tr></table></figure><hr><h4 id="JavaScript中的拷贝方法"><a href="#JavaScript中的拷贝方法" class="headerlink" title="JavaScript中的拷贝方法"></a>JavaScript中的拷贝方法</h4><p>JavaScript数组中有两个方法,<strong>concat</strong>和<strong>slice</strong>,他们都<strong>不会改变原数组</strong>，而是返回一个新数组</p><p>所以他们是可以实现对原数组的拷贝的,另外es6新增的<code>Object.assgn</code> 方法和 <code>...</code> 展开运算符也能实现对对象的拷贝</p><p>这里只说明结论,不解释详细过程</p><p><strong>concat</strong></p><p>该方法可以连接两个或者更多的数组，但是它不会修改已存在的数组，而是返回一个新数组。</p><p><strong>结论：<code>concat</code> 只是对数组的第一层进行深拷贝。</strong></p><hr><p><strong>slice</strong></p><p><strong>结论：<code>slice</code> 只是对数组的第一层进行深拷贝。</strong></p><hr><p><strong>Object.assign()</strong></p><p><strong>结论：<code>Object.assign()</code> 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值</strong></p><hr><p><strong>… 展开运算符</strong></p><p><strong>结论：<code>...</code> 实现的是对象第一层的深拷贝。后面的只是拷贝的引用值。</strong></p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>赋值运算符 <code>=</code> 实现的是浅拷贝，只拷贝对象的引用值；</li><li>JavaScript 中数组和对象自带的拷贝方法都是“首层浅拷贝”；</li><li><code>JSON.stringify</code> 实现的是深拷贝，但是对目标对象有要求；</li><li>若想真正意义上的深拷贝，请递归。</li></ol><hr><hr><h3 id="6-event-loop-事件循环"><a href="#6-event-loop-事件循环" class="headerlink" title="6.event loop(事件循环)"></a>6.event loop(事件循环)</h3><p>在学习事件循环之前,我们应该明白:<strong>JavaScript本质上就是一个单线程语言,一切JavaScript的所谓“多线程”都是用单线程模拟出来的</strong></p><h4 id="什么是事件循环"><a href="#什么是事件循环" class="headerlink" title="什么是事件循环?"></a><strong>什么是事件循环?</strong></h4><p>因为js是单线程的,js的任务是按顺序一个一个执行的。但一个任务耗时过长,后面的任务将被阻塞,这是我们不想看到的。所以程序员将任务分为两类:</p><ul><li><strong>同步任务</strong></li><li><strong>异步任务</strong></li></ul><p><strong>任务执行机制:</strong></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203141841788.webp" alt="img"></p><p>导图要表达的内容用文字来表述的话：</p><ul><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入<strong>Event Table</strong>并注册函数。</li><li>当指定的事情完成时，<strong>Event Table</strong>会将这个函数移入<strong>Event Queue</strong>。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的<strong>Event Loop</strong>(事件循环)。</li></ul><hr><h4 id="事件循环的一些举例"><a href="#事件循环的一些举例" class="headerlink" title="事件循环的一些举例"></a>事件循环的一些举例</h4><h5 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a><strong>setTimeout</strong></h5><p>setTimeout表示执行一个延时函数,他的特点是可以异步延时执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;延时3秒&#x27;</span>);&#125;,<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>但是在有些情况下,延时并不准确</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;    task()&#125;,<span class="number">3000</span>)sleep(<span class="number">10000000</span>)<span class="comment">//消耗很多的时间</span></span><br></pre></td></tr></table></figure><p>上例中,sleep()函数是一个<strong>同步任务</strong>,他直接在主线程中执行,而setTimeout是个<strong>异步任务</strong>,在任务执行过程中，task()执行的时间却远远大于3s,这时候延时并不准确,这是什么原因?</p><ul><li><code>task()</code>进入Event Table并注册,计时开始。</li><li>执行<code>sleep</code>函数，很慢，非常慢，计时仍在继续。</li><li>3秒到了，计时事件<code>timeout</code>完成，<code>task()</code>进入Event Queue，但是<code>sleep</code>也太慢了吧，还没执行完，只好等着。</li><li><code>sleep</code>终于执行完了，<code>task()</code>终于从Event Queue进入了主线程执行。</li></ul><hr><p><strong>setTimeout(fn,0)</strong></p><p>当setTimeout的延时为0时,是不是意味着他会立即执行呢?</p><p>答案是:<strong>NO!</strong></p><p><code>setTimeout(fn,0)</code>的含义是，<strong>指定某个任务在主线程最早可得的空闲时间执行</strong>，意思就是不用再等多少秒了，<strong>只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行</strong></p><p>关于<code>setTimeout</code>要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。</p><hr><h5 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h5><p><strong>setTimeout表示执行一个定时函数,每经过单位时间,就执行一次回调函数</strong></p><p>上面说完了<code>setTimeout</code>，当然不能错过它的孪生兄弟<code>setInterval</code>。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，<code>setInterval</code>会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p><p>唯一需要注意的一点是，对于<code>setInterval(fn,ms)</code>来说，我们已经知道不是每过<code>ms</code>秒会执行一次<code>fn</code>，而是每过<code>ms</code>秒，会有<code>fn</code>进入Event Queue。一旦**<code>setInterval</code>的回调函数<code>fn</code>执行时间超过了延迟时间<code>ms</code>，那么就完全看不出来有时间间隔了**。</p><hr><h4 id="宏任务-macro-task-和微任务-micro-task"><a href="#宏任务-macro-task-和微任务-micro-task" class="headerlink" title="宏任务(macro-task)和微任务(micro-task)"></a>宏任务(macro-task)和微任务(micro-task)</h4><p>除了广义上的同步任务和异步任务,我们对任务有更精细的定义:</p><ul><li><strong>macro-task(宏任务)</strong>:包括整体代码script,setTimeout\setInterval…</li><li><strong>micro-task(微任务)</strong>:Promise,Process.nextTick….</li></ul><p>核心知识点伪代码;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> macroTask <span class="keyword">of</span> macroTaskQueue) &#123;<span class="comment">//先执行宏任务  handleMacroTask();    for (const microTask of microTaskQueue) &#123;//再执行宏任务中的微任务    handleMicroTask(microTask);  &#125;&#125;</span></span><br></pre></td></tr></table></figure><p>事件循环,宏任务,微任务的关系图:</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151437172.webp" alt="img"></p><p>用一段代码来说明:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);    &#125;)    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);        resolve();    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)    &#125;)&#125;)process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);&#125;)<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>);    resolve();&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>)&#125;)<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>);    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>);    &#125;)    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);        resolve();    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span>)    &#125;)&#125;)</span><br></pre></td></tr></table></figure><p>第一轮事件循环流程分析如下：</p><ul><li>整体script作为第一个宏任务进入主线程，遇到<code>console.log</code>，输出1。</li><li>遇到<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中。我们暂且记为<code>setTimeout1</code>。</li><li>遇到<code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。我们记为<code>process1</code>。</li><li>遇到<code>Promise</code>，<code>new Promise</code>直接执行，输出7。<code>then</code>被分发到微任务Event Queue中。我们记为<code>then1</code>。</li><li>又遇到了<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中，我们记为<code>setTimeout2</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td>setTimeout1</td><td>process1</td></tr><tr><td>setTimeout2</td><td>then1</td></tr></tbody></table><ul><li>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。</li><li>我们发现了<code>process1</code>和<code>then1</code>两个微任务。</li><li>执行<code>process1</code>,输出6。</li><li>执行<code>then1</code>，输出8。</li></ul><p>好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从<code>setTimeout1</code>宏任务开始：</p><ul><li>首先输出2。接下来遇到了<code>process.nextTick()</code>，同样将其分发到微任务Event Queue中，记为<code>process2</code>。<code>new Promise</code>立即执行输出4，<code>then</code>也分发到微任务Event Queue中，记为<code>then2</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td>setTimeout2</td><td>process2</td></tr><tr><td></td><td>then2</td></tr></tbody></table><ul><li>第二轮事件循环宏任务结束，我们发现有<code>process2</code>和<code>then2</code>两个微任务可以执行。</li><li>输出3。</li><li>输出5。</li><li>第二轮事件循环结束，第二轮输出2，4，3，5。</li><li>第三轮事件循环开始，此时只剩setTimeout2了，执行。</li><li>直接输出9。</li><li>将<code>process.nextTick()</code>分发到微任务Event Queue中。记为<code>process3</code>。</li><li>直接执行<code>new Promise</code>，输出11。</li><li>将<code>then</code>分发到微任务Event Queue中，记为<code>then3</code>。</li></ul><table><thead><tr><th>宏任务Event Queue</th><th>微任务Event Queue</th></tr></thead><tbody><tr><td></td><td>process3</td></tr><tr><td></td><td>then3</td></tr></tbody></table><ul><li>第三轮事件循环宏任务执行结束，执行两个微任务<code>process3</code>和<code>then3</code>。</li><li>输出10。</li><li>输出12。</li><li>第三轮事件循环结束，第三轮输出9，11，10，12。</li></ul><p>整段代码，共进行了三次事件循环，完整的输出为<strong>1，7，6，8，2，4，3，5，9，11，10，12</strong>。 (请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</p><h4 id="如何实现一个事件的订阅与发布"><a href="#如何实现一个事件的订阅与发布" class="headerlink" title="?如何实现一个事件的订阅与发布"></a>?如何实现一个事件的订阅与发布</h4><h3 id="7-函数式编程"><a href="#7-函数式编程" class="headerlink" title="7.函数式编程"></a>7.函数式编程</h3><h4 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h4><p>函数式编程（Functional Programming，后面简称FP），维基百科的定义是：</p><blockquote><p>是一种编程范型，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。比起命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。</p></blockquote><p>我来尝试理解下这个定义，好像就是说，在敲代码的时候，我要<strong>把过程逻辑写成函数，定义好输入参数，只关心它的输出结果。而且可以把函数作为输入输出</strong>。感觉好像平常写js时，就是这样的嘛！</p><p><strong>特性:</strong></p><ol><li><strong>函数是一等公民</strong>。就是说函数可以跟其他变量一样，可以作为其他函数的输入输出。喔，回调函数就是典型应用。</li><li><strong>不可变量</strong>。就是说，不能用var跟let咯。按这要求，我似乎有点难写代码。</li><li><strong>纯函数</strong>。就是没有副作用的函数。这个好理解，就是不修改函数外部的变量。</li><li><strong>引用透明</strong>。这个也好理解，就是说同样的输入，必定是同样的输出。函数内部不依赖外部状态，如一些全局变量。</li><li><strong>惰性计算</strong>。大意就是：一个表达式绑定的变量，不是声明的时候就计算出来，而是真正用到它的时候才去计算。</li></ol><h4 id="函数式编程的优劣势"><a href="#函数式编程的优劣势" class="headerlink" title="函数式编程的优劣势"></a>函数式编程的优劣势</h4><p><strong>优势</strong></p><ol><li><strong>更好的管理状态</strong>。因为它的宗旨是无状态，或者说更少的状态。而平常DOM的开发中，因为DOM的视觉呈现依托于状态变化，所以不可避免的产生了非常多的状态，而且不同组件可能还相互依赖。以FP来编程，能最大化的减少这些未知、优化代码、减少出错情况。</li><li><strong>更简单的复用</strong>。极端的FP代码应该是每一行代码都是一个函数，当然我们不需要这么极端。我们尽量的把过程逻辑以更纯的函数来实现，固定输入-&gt;固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响。</li><li><strong>更优雅的组合</strong>。往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。参考上面第二点，更强的复用性，带来更强大的组合性。</li><li>隐性好处。减少代码量，提高维护性。</li></ol><p><strong>劣势</strong></p><ol><li>JavaScript不能算是严格意义上的函数式语言，很多函数式编程的特性并没有。比如上文说的数组的惰性链求值。为了实现它就得上工具库，或者自己封装实现，提高了代码编写成本。</li><li>跟过程式相比，它并没有提高性能。有些地方，如果强制用FP去写，由于没有中间变量，还可能会降低性能。</li><li>代码不易读。这个因人而异，因码而已。特别熟悉FP的人可能会觉得这段代码一目了然。而不熟悉的人，遇到写的晦涩的代码，看着一堆堆lambda演算跟匿名函数 <code>() =&gt; () =&gt; ()</code> 瞬间就懵逼了。看懂代码，得脑子里先演算半小时。</li><li>学习成本高。一方面继承于上一点。另一方面，很多前端coder，就是因为相对不喜欢一些底层的抽象的编程语言，才来踏入前端坑，你现在又让他们一头扎入FP，显得手足无措。</li></ol><h4 id="函数柯里化-curry"><a href="#函数柯里化-curry" class="headerlink" title="函数柯里化(curry)"></a>函数柯里化(curry)</h4><p>curry 的概念很简单：<strong>只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</strong></p><p> <strong>函数柯里化是指一个函数接收参数但不执行,知道所有参数都接到之后再执行</strong></p><p><strong>实现一个curry函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn,...args</span>)</span>&#123;    <span class="keyword">const</span> length = fn.length    <span class="keyword">let</span> argArray = [...args]    <span class="keyword">const</span> res = <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>)</span>&#123;        argArray = [...argArray,...args2]        <span class="comment">//长度相等或者大于fn所需参数就返回执行结果        if(argArray.length &gt;= length)&#123;            return fn(...argArray)        &#125;else&#123;            //长度不相等继续返回函数            return  res        &#125;    &#125;    return res  &#125;      const add = (a,b,c) =&gt;  a+b+c  const a = currying(add,1)  console.log(a(2,3));//output: 6</span></span><br></pre></td></tr></table></figure><h3 id="8-Service-Worker-PWA"><a href="#8-Service-Worker-PWA" class="headerlink" title="8.Service Worker/PWA"></a>8.Service Worker/PWA</h3><h3 id="9-Web-Worker"><a href="#9-Web-Worker" class="headerlink" title="9.Web Worker"></a>9.Web Worker</h3><h3 id="10-ES6知识"><a href="#10-ES6知识" class="headerlink" title="10.ES6知识"></a>10.ES6知识</h3><p>ES6所增加的知识太多了,给一个传送口</p><p><a href="https://juejin.cn/post/6844903959283367950">1.5万字概括ES6全部特性(已更新ES2020) - 掘金 (juejin.cn)</a></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151505211.webp" alt="ES6缩略"></p><h2 id="2-CSS基础"><a href="#2-CSS基础" class="headerlink" title="2.CSS基础"></a>2.CSS基础</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151559504.webp" alt="img"></p><h3 id="1-position"><a href="#1-position" class="headerlink" title="1.position"></a>1.position</h3><h4 id="什么是position"><a href="#什么是position" class="headerlink" title="什么是position?"></a>什么是position?</h4><p>CSS **<code>position</code>**属性用于指定一个元素在文档中的定位方式。<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/top"><code>top</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/right"><code>right</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/bottom"><code>bottom</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/left"><code>left</code></a> 属性则决定了该元素的最终位置。</p><iframe class="interactive is-default-height" height="200" src="https://interactive-examples.mdn.mozilla.net/pages/css/position.html" title="MDN Web Docs Interactive Example" loading="lazy" style="box-sizing: border-box; max-width: 100%; width: 637.156px; border: 1px solid var(--border-primary); background-color: var(--background-secondary); border-radius: var(--elem-radius); color: var(--text-primary); padding: 0px; height: 375px;"></iframe><p><strong>position的属性</strong></p><ul><li><strong>static</strong>:表示元素按文档流中本应该放置的位置来排版</li><li><strong>relative</strong>:表示相对定位</li><li><strong>absolute</strong>:表示绝对定位</li><li><strong>fixed</strong>：固定定位</li><li><strong>sticky</strong>:表示粘性定位</li></ul><p><strong>relative</strong></p><p><strong>特性</strong>:</p><ul><li><strong>不脱离文档流</strong></li><li>默认参照物为此元素<strong>原位置</strong></li></ul><hr><p><strong>absolute</strong></p><p>特性:</p><ul><li><strong>脱离文档流</strong></li><li>默认参照物为浏览器视窗的<strong>左上角</strong></li></ul><p>绝对定位元素相对于<em>最近的非 <code>static</code> 祖先元素</em>定位。当这样的祖先元素不存在时，则相对于ICB（inital container block, 初始包含块）。</p><p>可以查看示例</p><p><a href="https://codepen.io/zhangzhenming20020615/pen/mdpJeRe">A Pen by 张振明 (codepen.io)</a></p><hr><p><strong>fixed</strong></p><p><strong>特性</strong></p><ul><li><strong>脱离文档流</strong></li><li>默认参照物为浏览器<strong>视窗位置</strong></li></ul><hr><p><strong>sticky(粘性定位)</strong></p><p>单词sticky的中文意思是“粘性的”，<code>position:sticky</code>表现也符合这个粘性的表现。基本上，可以看出是<code>position:relative</code>和<code>position:fixed</code>的结合体——当元素在屏幕内，表现为relative，就要滚出显示器屏幕的时候，表现为fixed。</p><p><strong>特性</strong>:</p><ul><li><strong>当元素没有到达指定的位置时</strong>,position为<strong>relative</strong></li><li><strong>当元素到达指定的位置</strong>,position为<strong>fixed</strong>，也就是固定住</li><li>sticky元素的父级元素不能有任何<code>overflow:visible</code>以外的overflow设置,否则没有粘滞效果</li></ul><h3 id="2-行内元素-块级元素"><a href="#2-行内元素-块级元素" class="headerlink" title="2.行内元素/块级元素"></a>2.行内元素/块级元素</h3><h4 id="什么是行内元素？"><a href="#什么是行内元素？" class="headerlink" title="什么是行内元素？"></a>什么是行内元素？</h4><p><strong>行内元素只占据它对应标签的边框所包含的空间</strong></p><p><strong>一般情况下，行内元素只能包含数据和其他行内元素。</strong></p><p>行内元素列表:</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/b">b</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/big">big</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/i">i</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/small">small</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/tt">tt</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/abbr">abbr</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/acronym">acronym</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/cite">cite</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/code">code</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/dfn">dfn</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/em">em</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/kbd">kbd</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/strong">strong</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/samp">samp</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/var">var</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a">a</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/bdo">bdo</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/br">br</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img">img</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/map">map</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object">object</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/q">q</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script">script</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/span">span</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/sub">sub</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/sup">sup</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button">button</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input">input</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/label">label</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/select">select</a>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/textarea">textarea</a></li></ul><h4 id="什么是块级元素"><a href="#什么是块级元素" class="headerlink" title="什么是块级元素"></a>什么是块级元素</h4><p>块级元素占据其父元素（容器）的整个水平空间，垂直空间等于其内容高度，因此创建了一个“块”</p><p>通常浏览器会在块级元素前后另起一个新行</p><h4 id="行内元素与块级元素的区别"><a href="#行内元素与块级元素的区别" class="headerlink" title="行内元素与块级元素的区别"></a>行内元素与块级元素的区别</h4><p>块级元素与行内元素有几个关键区别：</p><ul><li><p>格式</p><p>默认情况下，块级元素会新起一行。</p></li><li><p>内容模型</p><p>一般块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。</p></li></ul><p>HTML 标准中块级元素和行内元素的区别至高出现在 4.01 标准中。在 HTML5，这种区别被一个更复杂的<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories">内容类别 (en-US)</a>代替。”块级“类别大致相当于 HTML5 中的<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#flow_content">流内容 (en-US)</a>类别，而”行内“类别相当于 HTML5 中的<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#phrasing_content">措辞内容 (en-US)</a>类别，不过除了这两个还有其他类别。</p><hr><h4 id="BFC-块格式化上下文"><a href="#BFC-块格式化上下文" class="headerlink" title="BFC(块格式化上下文)"></a>BFC(块格式化上下文)</h4><p><strong>块格式化上下文（Block Formatting Context，BFC）</strong> 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p><p>下列方式会创建<strong>块格式化上下文</strong>：</p><ul><li>根元素（<code>&lt;html&gt;）</code></li><li>浮动元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 不是 <code>none</code>）</li><li>绝对定位元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 为 <code>absolute</code> 或 <code>fixed</code>）</li><li>行内块元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>inline-block</code>）</li><li>表格单元格（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>table-cell</code>，HTML表格单元格默认为该值）</li><li>表格标题（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>table-caption</code>，HTML表格标题默认为该值）</li><li>匿名表格单元格元素（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>table、``table-row</code>、 <code>table-row-group、``table-header-group、``table-footer-group</code>（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 <code>inline-table</code>）</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow"><code>overflow</code></a> 计算值(Computed)不为 <code>visible</code> 的块元素</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>flow-root</code> 的元素</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain"><code>contain</code></a> 值为 <code>layout</code>、<code>content </code>或 paint 的元素</li><li>弹性元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>flex</code> 或 <code>inline-flex </code>元素的直接子元素）</li><li>网格元素（<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素）</li><li>多列容器（元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count"><code>column-count</code></a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/column-width"><code>column-width</code> (en-US)</a> 不为 <code>auto，包括 ``column-count</code> 为 <code>1</code>）</li><li><code>column-span</code> 为 <code>all</code> 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（<a href="https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51">标准变更</a>，<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=709362">Chrome bug</a>）。</li></ul><p>块格式化上下文包含创建它的元素内部的所有内容.</p><p>块格式化上下文对浮动定位（参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a>）与清除浮动（参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear"><code>clear</code></a>）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">Margin collapsing</a>）也只会发生在属于同一BFC的块级元素之间。</p><hr><h3 id="3-flex布局"><a href="#3-flex布局" class="headerlink" title="3.flex布局"></a>3.flex布局</h3><h4 id="什么是flex布局"><a href="#什么是flex布局" class="headerlink" title="什么是flex布局?"></a>什么是flex布局?</h4><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151551342.png" alt="img"></p><p>顾名思义,flex布局就是弹性布局,在flex容器中默认存在两条轴，<strong>水平主轴(main axis)<strong>和</strong>垂直的交叉轴(cross axis)</strong>,我们可以通过设置属性将垂直方向变为主轴,水平方向变为交叉轴</p><p>在容器内的每个单元块被称为<strong>flex item</strong>,每个项目占据的主轴空间为(main size)，占据的交叉轴的空间为(cross size)</p><h5 id="flex容器"><a href="#flex容器" class="headerlink" title="flex容器"></a>flex容器</h5><p>实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    <span class="attribute">display</span>: flex | inline-flex;       //可以有两种取值&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。</strong></p><p>有下面六种属性可以设置在容器上，它们分别是：</p><ol><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ol><hr><p><strong>flex-direction</strong>:决定主轴的方向</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;&#125;</span><br></pre></td></tr></table></figure><p><strong>row</strong>：默认值,主轴为水平方向,起点在左端</p><p><strong>row-reverse</strong>:主轴为水平方向,起点在右端</p><p><strong>column</strong>:主轴为垂直方向,起点在上沿</p><p><strong>column-reverse</strong>：主轴为垂直方向,起点在下端</p><hr><p><strong>flex-wrap</strong>：决定容器内项目是否可以换行</p><p>默认情况下，项目都排在主轴线上，使用 flex-wrap 可实现项目的换行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;&#125;</span><br></pre></td></tr></table></figure><p><strong>nowrap</strong>:<strong>默认值</strong>，不换行,即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行。</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151603139.png" alt="img"></p><p><strong>wrap</strong>：换行,当项目主轴总尺寸超过容器时换行,第一行在上方</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151604830.png" alt="img"></p><p><strong>wrap-reverse</strong>:换行，第一行在下方</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151605328.png" alt="img"></p><hr><p> <strong>flex-flow</strong>:<strong>flex-direction 和 flex-wrap 的简写形式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125;</span><br></pre></td></tr></table></figure><p><strong>默认值</strong>为: row nowrap</p><hr><p> <strong>justify-content：定义了项目在主轴的对齐方式。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;&#125;</span><br></pre></td></tr></table></figure><p>假设主轴是<strong>水平方向</strong>,垂直方向同理(左右改为上下)</p><p><strong>flex-start</strong>:左对齐</p><p><strong>flex-end</strong>:右对齐</p><p><strong>center</strong>：居中</p><p><strong>space-between</strong>：两端对齐,项目之间的间隔相等，即剩余空间等分成间隙。</p><p><strong>space-around</strong>：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。</p><hr><p><strong>align-items: 定义了项目在交叉轴上的对齐方式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;&#125;</span><br></pre></td></tr></table></figure><p><strong>baseline</strong>:项目的第一行文字的基线对齐</p><p><strong>stretch</strong>:<strong>默认值</strong>  即如果项目未设置高度或者设为 auto，将占满整个容器的高度</p><hr><p><strong>align-content: 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;&#125;</span><br></pre></td></tr></table></figure><p>当你 flex-wrap 设置为 <strong>nowrap</strong> 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。</p><p>当你 flex-wrap 设置为 <strong>wrap</strong> 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。</p><h5 id="flex元素属性"><a href="#flex元素属性" class="headerlink" title="flex元素属性"></a>flex元素属性</h5><p>有六种属性可运用在 item 项目上：</p><ol><li>order</li><li>flex-basis</li><li>flex-grow</li><li>flex-shrink</li><li>flex</li><li>align-self</li></ol><p> <strong>order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;    <span class="attribute">order</span>: &lt;integer&gt;;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151616010.png" alt="img"></p><hr><p><strong>flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;    <span class="attribute">flex-basis</span>: &lt;length&gt; | auto;&#125;</span><br></pre></td></tr></table></figure><p>默认值：<strong>auto</strong>，即项目本来的大小, 这时候 item 的宽高取决于 width 或 height 的值。</p><iframe class="interactive is-default-height" height="200" src="https://interactive-examples.mdn.mozilla.net/pages/css/flex-basis.html" title="MDN Web Docs Interactive Example" loading="lazy" style="box-sizing: border-box; max-width: 100%; width: 639.297px; border: 1px solid var(--border-primary); background-color: var(--background-secondary); border-radius: var(--elem-radius); color: var(--text-primary); padding: 0px; height: 375px;"></iframe><p><strong>当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。</strong></p><ul><li>当 flex-basis 值为 0 % 时，是把该项目视为零尺寸的，故即使声明该尺寸为 140px，也并没有什么用。</li><li>当 flex-basis 值为 auto 时，则跟根据尺寸的设定值(假如为 100px)，则这 100px 不会纳入剩余空间。</li></ul><p> <strong>flex-grow: 定义项目的放大比例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;    <span class="attribute">flex-grow</span>: &lt;number&gt;;&#125;</span><br></pre></td></tr></table></figure><p><strong>默认值为 0，即如果存在剩余空间，也不放大</strong></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151627863.png" alt="img"></p><p>当所有的项目都以 flex-basis 的值进行排列后，仍有剩余空间，那么这时候 flex-grow 就会发挥作用了。</p><p>如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话)</p><p>如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p><p>当然如果当所有项目以 flex-basis 的值排列完后发现空间不够了，且 flex-wrap：nowrap 时，此时 flex-grow 则不起作用了，这时候就需要接下来的这个属性。</p><p><strong>flex-shrink: 定义了项目的缩小比例</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;    <span class="attribute">flex-shrink</span>: &lt;number&gt;;&#125;</span><br></pre></td></tr></table></figure><p><strong>默认值: 1，即如果空间不足，该项目将缩小，负值对该属性无效。</strong></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151628761.png" alt="img"></p><p>这里可以看出，虽然每个项目都设置了宽度为 50px，但是由于自身容器宽度只有 200px，这时候每个项目会被同比例进行缩小，因为默认值为 1。</p><p>同理可得：</p><p>如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。</p><p>如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。</p><hr><p><strong>flex: flex-grow, flex-shrink 和 flex-basis的简写</strong></p><p>flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 <strong>flex 的默认值是 0 1 auto</strong>。</p><p>grow 和 shrink 是一对双胞胎，grow 表示伸张因子，shrink 表示是收缩因子。</p><p>grow 在 flex 容器下的子元素的宽度和比容器和小的时候起作用。 grow 定义了子元素的尺寸增长因子，容器中除去子元素之和剩下的尺寸会按照各个子元素的 grow 值进行平分加大各个子元素上。</p><hr><p><strong>lign-self: 允许单个项目有与其他项目不一样的对齐方式</strong></p><p>单个项目覆盖 align-items 定义的属性</p><p>默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">     <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个跟 align-items 属性时一样的，只不过 align-self 是对单个项目生效的，而 align-items 则是对容器下的所有项目生效的。</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151642611.png" alt="img"></p><hr><p><a href="https://codepen.io/pen/">A Pen by 张振明 (codepen.io)</a></p><h4 id="如何用flex实现九宫格布局"><a href="#如何用flex实现九宫格布局" class="headerlink" title="如何用flex实现九宫格布局"></a>如何用flex实现九宫格布局</h4><p><a href="https://codepen.io/zhangzhenming20020615/pen/YzYXqWj">flex实现九宫格布局 (codepen.io)</a></p><h4 id="flex-1指的是什么？flex属性默认值是什么"><a href="#flex-1指的是什么？flex属性默认值是什么" class="headerlink" title="flex:1指的是什么？flex属性默认值是什么"></a>flex:1指的是什么？flex属性默认值是什么</h4><p><code>flex:1</code> 为：<code>flex: 1 1 0</code>;</p><p>flex属性默认值为:<code>0 1 auto</code></p><p>具体代表什么属性 上文有说明</p><h4 id="介绍一下flex-shrink和flex-basis属性"><a href="#介绍一下flex-shrink和flex-basis属性" class="headerlink" title="介绍一下flex-shrink和flex-basis属性"></a>介绍一下flex-shrink和flex-basis属性</h4><hr><hr><h3 id="4-1px问题"><a href="#4-1px问题" class="headerlink" title="4.1px问题"></a>4.1px问题</h3><h3 id="5-重绘与回流"><a href="#5-重绘与回流" class="headerlink" title="5.重绘与回流"></a>5.重绘与回流</h3><p>参考:[浏览器的重绘和回流](<a href="https://juejin.cn/post/6844903569087266823">浏览器的回流与重绘 (Reflow &amp; Repaint) - 掘金 (juejin.cn)</a>)</p><p>在讨论回流与重绘之前，我们要知道：</p><ol><li>浏览器使用流式布局模型 (Flow Based Layout)。</li><li>浏览器会把<code>HTML</code>解析成<code>DOM</code>，把<code>CSS</code>解析成<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并就产生了<code>Render Tree</code>。</li><li>有了<code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</li><li>由于浏览器使用流式布局，对<code>Render Tree</code>的计算通常只需要遍历一次就可以完成，但<code>table</code>及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用<code>table</code>布局的原因之一。</li></ol><p><strong>一句话：回流必将引起重绘，重绘不一定会引起回流。</strong></p><h4 id="1-回流-Reflow"><a href="#1-回流-Reflow" class="headerlink" title="1.回流 (Reflow)"></a>1.回流 (Reflow)</h4><p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p><p>会导致回流的操作：</p><ul><li>页面首次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>添加或者删除<strong>可见</strong>的<code>DOM</code>元素</li><li>激活<code>CSS</code>伪类（例如：<code>:hover</code>）</li><li>查询某些属性或调用某些方法</li></ul><p>一些常用且会导致回流的属性和方法：</p><ul><li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li><li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li><li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li><li><code>scrollIntoView()</code>、<code>scrollIntoViewIfNeeded()</code></li><li><code>getComputedStyle()</code></li><li><code>getBoundingClientRect()</code></li><li><code>scrollTo()</code></li></ul><h4 id="2-重绘-Repaint"><a href="#2-重绘-Repaint" class="headerlink" title="2.重绘 (Repaint)"></a>2.重绘 (Repaint)</h4><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code>color</code>、<code>background-color</code>、<code>visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><h4 id="3-性能影响"><a href="#3-性能影响" class="headerlink" title="3.性能影响"></a>3.性能影响</h4><p><strong>回流比重绘的代价要更高。</strong></p><p>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。</p><p>现代浏览器会对频繁的回流或重绘操作进行优化：</p><p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p><p>当你访问以下属性或方法时，浏览器会立刻清空队列：</p><ul><li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li><li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li><li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li><li><code>width</code>、<code>height</code></li><li><code>getComputedStyle()</code></li><li><code>getBoundingClientRect()</code></li></ul><p>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</p><h4 id="4-如何避免"><a href="#4-如何避免" class="headerlink" title="4.如何避免"></a>4.如何避免</h4><h5 id="1-CSS"><a href="#1-CSS" class="headerlink" title="1.CSS"></a>1.CSS</h5><ul><li>避免使用<code>table</code>布局。</li><li>尽可能在<code>DOM</code>树的最末端改变<code>class</code>。</li><li>避免设置多层内联样式。</li><li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上。</li><li>避免使用<code>CSS</code>表达式（例如：<code>calc()</code>）。</li></ul><h5 id="2-JavaScript"><a href="#2-JavaScript" class="headerlink" title="2.JavaScript"></a>2.JavaScript</h5><ul><li>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li><li>避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM操作</code>，最后再把它添加到文档中。</li><li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行的<code>DOM</code>操作不会引发回流和重绘。</li><li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul><hr><p><strong>总结</strong>:会引起元素位置变化的就会reflow，如博主上面介绍的，窗口大小改变、字体大小改变、以及元素位置改变，都会引起周围的元素改变他们以前的位置；不会引起位置变化的，只是在以前的位置进行改变背景颜色等，只会repaint；</p><hr><hr><h3 id="6-居中布局"><a href="#6-居中布局" class="headerlink" title="6.居中布局"></a>6.居中布局</h3><h3 id="7-层叠上下文"><a href="#7-层叠上下文" class="headerlink" title="7.层叠上下文"></a>7.层叠上下文</h3><blockquote><p>参考:<a href="https://juejin.cn/post/6844903667175260174#heading-1">彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index - 掘金 (juejin.cn)</a></p></blockquote><p>首先，<code>z-index</code>属性值并不是在任何元素上都有效果。它<strong>仅在</strong>定位元素（定义了<code>position</code>属性，且属性值为非<code>static</code>值的元素）上有效果。</p><p>判断元素在<code>Z轴</code>上的堆叠顺序，不仅仅是直接比较两个元素的<code>z-index</code>值的大小，这个堆叠顺序实际由元素的<strong>层叠上下文</strong>、<strong>层叠等级</strong>共同决定。</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181527715.png" alt="image-20220226103650745"></p><h4 id="1-什么是层叠上下文"><a href="#1-什么是层叠上下文" class="headerlink" title="1.什么是层叠上下文"></a>1.什么是层叠上下文</h4><p>层叠上下文(stacking context)，是HTML中一个三维的概念。在CSS2.1规范中，每个盒模型的位置是三维的，分别是平面画布上的<code>X轴</code>，<code>Y轴</code>以及表示层叠的<code>Z轴</code>。一般情况下，元素在页面上沿<code>X轴Y轴</code>平铺，我们察觉不到它们在<code>Z轴</code>上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。</p><p>如果一个元素含有层叠上下文，(也就是说它是层叠上下文元素)，我们可以理解为这个元素在<code>Z轴</code>上就“高人一等”，最终表现就是它离屏幕观察者更近。</p><blockquote><p><strong>具象的比喻</strong>：你可以把层叠上下文元素理解为理解为<strong>该元素当了官</strong>，而其他非层叠上下文元素则可以理解为普通群众。凡是“当了官的元素”就比普通元素等级要高，也就是说元素在<code>Z轴</code>上更靠上，更靠近观察者。</p></blockquote><h4 id="2-什么是层叠等级"><a href="#2-什么是层叠等级" class="headerlink" title="2.什么是层叠等级"></a>2.什么是层叠等级</h4><p>那么，层叠等级指的又是什么？层叠等级(stacking level，叫“层叠级别”/“层叠水平”也行)</p><ul><li>在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在<code>Z轴</code>上的上下顺序。</li><li>在其他普通元素中，它描述定义的是这些普通元素在<code>Z轴</code>上的上下顺序。</li></ul><p>说到这，可能很多人疑问了，不论在层叠上下文中还是在普通元素中，层叠等级都表示元素在<code>Z轴</code>上的上下顺序，那就直接说它描述定义了所有元素在<code>Z轴</code>上的上下顺序就OK啊！为什么要分开描述？</p><p>为了说明原因，先举个栗子：</p><blockquote><p><strong>具象的比喻</strong>：我们之前说到，处于层叠上下文中的元素，就像是元素当了官，等级自然比普通元素高。再想象一下，假设一个官员A是个省级领导，他下属有一个秘书a-1，家里有一个保姆a-2。另一个官员B是一个县级领导，他下属有一个秘书b-1，家里有一个保姆b-2。a-1和b-1虽然都是秘书，但是你想一个省级领导的秘书和一个县级领导的秘书之间有可比性么？甚至保姆a-2都要比秘书b-1的等级高得多。谁大谁小，谁高谁低一目了然，所以根本没有比较的意义。只有在A下属的a-1、a-2以及B下属的b-1、b-2中相互比较大小高低才有意义。</p></blockquote><p><strong>再类比回“层叠上下文”和“层叠等级”，就得出一个结论：</strong></p><ol><li>普通元素的层叠等级优先由其所在的层叠上下文决定。</li><li>层叠等级的比较只有在当前层叠上下文元素中才有意义。不同层叠上下文中比较层叠等级是没有意义的。</li></ol><h4 id="3-如何产生“层叠上下文”"><a href="#3-如何产生“层叠上下文”" class="headerlink" title="3.如何产生“层叠上下文”"></a>3.如何产生“层叠上下文”</h4><p>前面说了那么多，知道了“层叠上下文”和“层叠等级”，其中还有一个最关键的问题：到底如何产生层叠上下文呢？如何让一个元素变成层叠上下文元素呢？</p><p>其实，层叠上下文也基本上是有一些特定的CSS属性创建的，一般有3种方法：</p><ol><li><code>HTML</code>中的根元素<code>&lt;html&gt;&lt;/html&gt;</code>本身j就具有层叠上下文，称为“根层叠上下文”。</li><li>普通元素设置<code>position</code>属性为<strong>非</strong><code>static</code>值并设置<code>z-index</code>属性为具体数值，产生层叠上下文。</li><li>CSS3中的新属性也可以产生层叠上下文。</li></ol><hr><p>上面说了那么多，可能你还是有点懵。这么多概念规则，来点最实际的，有没有一个“套路”当遇到元素层叠时，能很清晰地判断出他们谁在上谁在下呢？答案是——肯定有啊！</p><ol><li>首先先看要比较的两个元素是否处于同一个层叠上下文中<ol><li>如果是，谁的层叠等级大，谁在上面</li><li>如果两个元素不在统一层叠上下文中，请先比较他们所处的层叠上下文的层叠等级</li></ol></li><li>当两个元素层叠等级相同、层叠顺序相同时，在DOM结构中后面的元素层叠等级在前面元素之上</li></ol><hr><hr><h3 id="8-sass-less"><a href="#8-sass-less" class="headerlink" title="8.sass/less"></a>8.sass/less</h3><h3 id="9-对盒模型的理解"><a href="#9-对盒模型的理解" class="headerlink" title="9.对盒模型的理解"></a>9.对盒模型的理解</h3><p>盒模型</p><p>盒模型共有两种:</p><ul><li>标准盒模型</li><li>IE盒模型</li></ul><h2 id="3-Vue"><a href="#3-Vue" class="headerlink" title="3.Vue"></a>3.Vue</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181857871.webp" alt="img"></p><h3 id="1-MVVM"><a href="#1-MVVM" class="headerlink" title="1.MVVM"></a>1.MVVM</h3><h4 id="1-什么是MVVM"><a href="#1-什么是MVVM" class="headerlink" title="1.什么是MVVM?"></a>1.什么是MVVM?</h4><blockquote><p>Model–View–ViewModel （MVVM） 是一个软件架构设计模式，源于经典的Model-View-Controller(MVC)模式,MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率.</p></blockquote><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181527689.awebp" alt="1.png"></p><p><strong>MVVM</strong>的核心是<strong>ViewModel</strong>层,它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，<strong>该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互</strong>，起呈上启下作用。</p><p><strong>View层</strong></p><p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。</p><p><strong>Model 层</strong></p><p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</p><p><strong>ViewModel 层</strong></p><p><strong><code>ViewModel</code> 是由前端开发人员组织生成和维护的视图数据层</strong>。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。</p><h4 id="2-ViewModel有什么好处"><a href="#2-ViewModel有什么好处" class="headerlink" title="2.ViewModel有什么好处?"></a>2.ViewModel有什么好处?</h4><p>MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p><h3 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2.生命周期"></a>2.生命周期</h3><h4 id="1-介绍一下Vue生命周期"><a href="#1-介绍一下Vue生命周期" class="headerlink" title="1.介绍一下Vue生命周期"></a>1.介绍一下Vue生命周期</h4><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181527157.awebp" alt="1.png"></p><p>Vue 实例有一个完整的生命周期，也就是从开始创建实例、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p><p><strong>各个生命周期的作用</strong></p><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>组件实例被创建之初，组件的属性生效之前</td></tr><tr><td>created</td><td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td></tr><tr><td>beforeMount</td><td>在挂载开始之前被调用：相关的 render 函数首次被调用</td></tr><tr><td>mounted</td><td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td></tr><tr><td>beforeUpdate</td><td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td></tr><tr><td>updated</td><td>组件数据更新之后</td></tr><tr><td>activited</td><td>keep-alive 专属，组件被激活时调用</td></tr><tr><td>deactivated</td><td>keep-alive 专属，组件被销毁时调用</td></tr><tr><td>beforeDestory</td><td>组件销毁前调用</td></tr><tr><td>destoryed</td><td>组件销毁后调用</td></tr></tbody></table><p><strong>beforeCreate</strong>:此时生命周期以及事件已经被初始化但是数据代理还未开始，无法通过vm访问到data中的数据、methods中的方法</p><p><strong>created</strong>：此时数据监测和数据代理已经初始化，可以通过访问vm访问到data中的数据</p><p><strong>beforeMount</strong>：此阶段Vue开始解析模板，生成虚拟DOM(内存中)，但是页面还不能显示解析好的内容，</p><p>此时页面呈现的时未经Vue编译的DOM结构，所有对DOM的操作，最终都不奏效</p><p><strong>mouted</strong>:此阶段内存中的虚拟DOM已经转成真实DOM插入页面。页面中呈现的时经过Vue编译的DOM，此时对DOM的操作均有效。至此初始化过程结束，一般再次进行:开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作、</p><p><strong>beforeUpdate</strong>:此时数据是新的，但是页面是旧的，页面尚未和数据保持同步</p><p><strong>updated</strong>:此时页面已经完成了从Model到View的更新，页面数据是新的，页面也是新的，即页面和数据保持同步</p><p><strong>beforeDestory</strong>：此时vm中所有的data、methods、指令等等都处于可用状态，但是马上要执行销毁过程，一般在此阶段:关闭定时器，取消订阅消息、解绑自定义事件等收尾操作</p><p><strong>destoryed</strong>:销毁vm实例</p><h4 id="2-nextTick是如何实现的"><a href="#2-nextTick是如何实现的" class="headerlink" title="2.nextTick是如何实现的"></a>2.nextTick是如何实现的</h4><p><strong>什么是nextTick?</strong></p><blockquote><p>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM</p></blockquote><p><strong>nextTick原理</strong></p><h4 id="3-父子组件挂载时-生命周期的顺序是怎么样的"><a href="#3-父子组件挂载时-生命周期的顺序是怎么样的" class="headerlink" title="3.父子组件挂载时,生命周期的顺序是怎么样的"></a>3.父子组件挂载时,生命周期的顺序是怎么样的</h4><p>vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p><ul><li><p>加载渲染过程</p><p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p></li><li><p>子组件更新过程</p><p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p></li><li><p>父组件更新过程</p><p>父 beforeUpdate -&gt; 父 updated</p></li><li><p>销毁过程</p><p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p></li></ul><h3 id="3-数据绑定"><a href="#3-数据绑定" class="headerlink" title="3.数据绑定"></a>3.数据绑定</h3><h4 id="1-Vue的双向绑定如何实现"><a href="#1-Vue的双向绑定如何实现" class="headerlink" title="1.Vue的双向绑定如何实现"></a>1.Vue的双向绑定如何实现</h4><p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191107846.webp" alt="1.png"></p><p>即：</p><ul><li>输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。</li><li>Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。</li></ul><p>其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。</p><p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p><p>实现一个监听器 <strong>Observer</strong>：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</p><p>实现一个解析器 <strong>Compile</strong>：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p><p>实现一个订阅者 <strong>Watcher：Watcher</strong> 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</p><p>实现一个订阅器 <strong>Dep</strong>：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191112642.webp" alt="1.png"></p><p>按我自己的理解就是:当修改数据时,vue会调用dep.notify通知相应的wathcer执行它的update函数,update函数会执行compile中绑定的回调,然会修改dom的值.当修改视图层的数据时,vue通过监听input来获取input中的值并将其赋值给data中的对应属性，修改属性又会触发setter，于是又会执行dep.notify等一系列操作,从而达到双向绑定.</p><h4 id="2-Vue如何监听数组或对象的改变"><a href="#2-Vue如何监听数组或对象的改变" class="headerlink" title="2.Vue如何监听数组或对象的改变"></a>2.Vue如何监听数组或对象的改变</h4><p><strong>1.vue会监视data中所有层次的数据</strong></p><p><strong>2.如何监测对象中的数据？</strong></p><p>​    通过setter事件监视，且要在newVue时就传入要监测的数据</p><p>​        (1).在对象后追加的属性，Vue默认不做响应式处理</p><p>​         (2).如需给后添加的属性做响应式，需要使用以下API:</p><p>​                Vue.set(target,propertyName/index,value)</p><p>​                vm.$set(target,propertyName/index,value)</p><p> <strong>3.如何监测数组中的数据?</strong></p><p>​     通过包裹数组更新元素的方法实现，本质就是做了两件事:</p><p>​            (1).调用原生对应的方法对数组进行更新</p><p>​            (2).重新解析模板，进而更新页面</p><p><strong>4.在Vue修改数组中的某个元素需要用到以下方法:</strong></p><p>​        1.使用这些API:push(),pop(),shift(),unshift(),splice(),sort(),erverse()</p><p>​        2.Vue.set()或vm.$set</p><hr><h4 id="3-defineProperty和proxy的区别"><a href="#3-defineProperty和proxy的区别" class="headerlink" title="3.defineProperty和proxy的区别"></a>3.defineProperty和proxy的区别</h4><p><strong>Proxy 的优势如下:</strong></p><ul><li>Proxy 可以直接监听对象而非属性；</li><li>Proxy 可以直接监听数组的变化；</li><li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li><li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li><li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li></ul><p><strong>Object.defineProperty 的优势如下:</strong></p><ul><li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平</li></ul><h4 id="4-Vue中的数据为什么频繁变化但只会更新一次"><a href="#4-Vue中的数据为什么频繁变化但只会更新一次" class="headerlink" title="4.Vue中的数据为什么频繁变化但只会更新一次"></a>4.Vue中的数据为什么频繁变化但只会更新一次</h4><h3 id="4-状态管理"><a href="#4-状态管理" class="headerlink" title="4.状态管理"></a>4.状态管理</h3><h4 id="1-vuex是什么"><a href="#1-vuex是什么" class="headerlink" title="1.vuex是什么"></a>1.vuex是什么</h4><blockquote><p>专门在Vue中实现集中式状态(数据)管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理(读/写),也是一种组件间通信的方式，且适用于任意组件间通信</p></blockquote><ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li></ul><h4 id="2-什么时候使用vuex"><a href="#2-什么时候使用vuex" class="headerlink" title="2.什么时候使用vuex?"></a>2.什么时候使用vuex?</h4><ul><li>​    多个组件依赖同一状态</li><li>​    来自不同组件的行为需要变更同一状态</li></ul><h4 id="3-vuex的工作原理"><a href="#3-vuex的工作原理" class="headerlink" title="3.vuex的工作原理"></a>3.vuex的工作原理</h4><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181658280.png" alt="vuex"></p><p>vuex包括以下几个模块:</p><ul><li><p><strong>State</strong>：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</p><p>1.vuex管理的状态对象(存放数据的对象)</p><p>2.它应该时唯一的</p><p>3.示例代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">   <span class="comment">// key:value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Getter</strong>：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</p><p>当state中的数据需要经过加工后再使用时，可以使用getters加工,类似于组件中的计算属性</p></li><li><p><strong>Mutation</strong>：是唯一更改 store 中状态的方法，且必须是同步函数。</p><p>1.值是一个对象，包含多个直接更新state的方法</p><p>2.谁能调用mutations中的方法？如何让调用？</p><p>​    在action中使用:**commit(‘对应的mutations方法名’)**触发</p><p>3.mutations中方法的特点：不能写异步代码、只能单纯的操作state</p><p>4.示例代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">   <span class="comment">//函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Action</strong>：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</p><p>1.值为一个对象，包含多个响应用户动作的回调函数</p><p>2.通过commit()来触发mutation中函数的调用，间接更新state</p><p>3.示例代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Module</strong>：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</p></li></ul><hr><h4 id="4-vuex中4个map方法的使用"><a href="#4-vuex中4个map方法的使用" class="headerlink" title="4.vuex中4个map方法的使用"></a>4.<strong>vuex中4个map方法的使用</strong></h4><p>定义:使用vuex提供的map方法可以对组件中的计算属性和方法进行映射，可以大大的减少代码量，提高代码的复用率</p><h5 id="1-mapState"><a href="#1-mapState" class="headerlink" title="1.mapState"></a>1.mapState</h5><p>理解:用于帮助我们映射state中的数据为计算属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    <span class="comment">//借助mapState生成计算属性:count,student,school(对象写法)</span></span><br><span class="line">    <span class="comment">//对象中的key是我们在自己的组件中渲染时需要调用的值，value是我们在store中state内定义的值</span></span><br><span class="line">     ...mapState(&#123;<span class="attr">count</span>:<span class="string">&#x27;count&#x27;</span>,<span class="attr">student</span>:<span class="string">&#x27;student&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>&#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//借助mapState生成计算属性:count,student,school(数组写法)</span></span><br><span class="line">     ...mapState([<span class="string">&#x27;count&#x27;</span>,<span class="string">&#x27;student&#x27;</span>,<span class="string">&#x27;school&#x27;</span>]),</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><h5 id="2-mapGetters"><a href="#2-mapGetters" class="headerlink" title="2.mapGetters"></a>2.mapGetters</h5><p>理解:用于帮助我们映射getters中的数据为计算属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性:bigCount(对象写法)</span></span><br><span class="line">    <span class="comment">//对象中的key是我们在自己的组件中渲染时需要调用的值，value是我们在store中getters内定义的值</span></span><br><span class="line">     ...mapState(&#123;<span class="attr">count</span>:<span class="string">&#x27;count&#x27;</span>,<span class="attr">student</span>:<span class="string">&#x27;student&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>&#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性:bigCount(数组写法)</span></span><br><span class="line">     ...mapGetters([<span class="string">&#x27;bigCount&#x27;</span>])</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><h5 id="3-mapActions"><a href="#3-mapActions" class="headerlink" title="3.mapActions"></a>3.mapActions</h5><p>理解:用于帮助我们生成与action对话的方法，即：包含$store.dispatch(xxx)的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  <span class="comment">//借助mapActions生成方法:addOdd，addWait(对象写法)</span></span><br><span class="line">  <span class="comment">//对象中的key是我们在自己的组件中需要调用的方法，value是我们在store中actions内定义的方法名</span></span><br><span class="line">  ...mapActions(&#123;<span class="attr">addOdd</span>:<span class="string">&#x27;addOdd&#x27;</span>,<span class="attr">addWait</span>:<span class="string">&#x27;addWait&#x27;</span>&#125;),</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//借助mapActions生成方法:addOdd，addWait(数组写法)</span></span><br><span class="line">   ...mapActions([<span class="string">&#x27;addOdd&#x27;</span>,<span class="string">&#x27;addWait&#x27;</span>])</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="4-mapMutations"><a href="#4-mapMutations" class="headerlink" title="4.mapMutations"></a>4.mapMutations</h5><p>理解：用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">   <span class="comment">//借助mapActions生成方法:Add，Reduce(对象写法)</span></span><br><span class="line">   <span class="comment">//对象中的key是我们在自己的组件中需要调用的方法，value是我们在store中mutations内定义的方法名</span></span><br><span class="line">   ...mapMutations(&#123;<span class="attr">add</span>:<span class="string">&#x27;Add&#x27;</span>,<span class="attr">reduce</span>:<span class="string">&#x27;Reduce&#x27;</span>&#125;),</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//借助mapActions生成方法:Add，Reduce(数组写法)</span></span><br><span class="line">    ...mapActions([<span class="string">&#x27;Add&#x27;</span>,<span class="string">&#x27;Reduce&#x27;</span>])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注意:当我们使用<strong>mapActions</strong>和<strong>mapMutations</strong>方法时，我们需要将dispatch和commit中需要传递的值通过组件中方法传参，例如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add(n)&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-vuex的基本使用"><a href="#5-vuex的基本使用" class="headerlink" title="5.vuex的基本使用"></a>5.vuex的基本使用</h4><p>案例:点击按钮对数字进行各种操作</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181716339.png" alt="image-20210911201800277"></p><p>我们将求和之后的数字定义为count，存入vuex的临时组件中，每次进行操作从原组件中调用vuex的api，最终完成求和的计算</p><p>Count.vue组件:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>当前求和为:&#123;&#123;$store.state.count&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model.number</span>=<span class="string">&quot;n&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;reduce&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addOdd&quot;</span>&gt;</span>当前求和为奇数再加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addWait&quot;</span>&gt;</span>等一等再加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span>&#123;</span><br><span class="line">       <span class="attr">n</span>:<span class="number">1</span>,<span class="comment">//选择框中选择的数字</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">      <span class="function"><span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;Add&#x27;</span>,<span class="built_in">this</span>.n)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">reduce</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;Reduce&#x27;</span>,<span class="built_in">this</span>.n)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">addOdd</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;addOdd&#x27;</span>,<span class="built_in">this</span>.n)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">addWait</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;addWait&#x27;</span>,<span class="built_in">this</span>.n)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>store中index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该文件用于创建Vuex中最核心的store</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="comment">//准备actions--用于响应组件中的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;<span class="comment">//action中可以进行异步操作,例如从请求服务器接口</span></span><br><span class="line">    <span class="function"><span class="title">addOdd</span>(<span class="params">context,value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(context.state.count % <span class="number">2</span>)&#123;</span><br><span class="line">           context.commit(<span class="string">&#x27;AddOdd&#x27;</span>,value) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">addWait</span>(<span class="params">context,value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            context.commit(<span class="string">&#x27;AddWait&#x27;</span>,value) </span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备mutations--用于操作数据(state)</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="function"><span class="title">Add</span>(<span class="params">state,value</span>)</span>&#123;</span><br><span class="line">        state.count += value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">Reduce</span>(<span class="params">state,value</span>)</span>&#123;</span><br><span class="line">        state.count -= value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">AddOdd</span>(<span class="params">state,value</span>)</span>&#123;</span><br><span class="line">        state.count += value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">AddWait</span>(<span class="params">state,value</span>)</span>&#123;</span><br><span class="line">        state.count += value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备state--用于存储数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">    <span class="attr">count</span>:<span class="number">1</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>效果</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181716612.gif" alt="GIF 2021-9-11 20-22-35"></p><h4 id="6-vuex中的数据在页面刷新后消失怎么办"><a href="#6-vuex中的数据在页面刷新后消失怎么办" class="headerlink" title="6.vuex中的数据在页面刷新后消失怎么办?"></a>6.vuex中的数据在页面刷新后消失怎么办?</h4><p>用sessionstorage 或者 localstorage 存储数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存储： sessionStorage.setItem( &#x27;名&#x27;, JSON.stringify(值) )</span><br><span class="line">使用： sessionStorage.getItem(&#x27;名&#x27;) ---得到的值为字符串类型，用JSON.parse()去引号；</span><br></pre></td></tr></table></figure><h3 id="5-组件通信"><a href="#5-组件通信" class="headerlink" title="5.组件通信"></a>5.组件通信</h3><h4 id="1-vue组件间通信有哪几种方式"><a href="#1-vue组件间通信有哪几种方式" class="headerlink" title="1.vue组件间通信有哪几种方式?"></a>1.<strong>vue组件间通信有哪几种方式?</strong></h4><h5 id="1-props-emit"><a href="#1-props-emit" class="headerlink" title="1.props/$emit"></a>1.<strong>props/$emit</strong></h5><p>适用:<strong>父子组件通信</strong></p><p><strong>父传子</strong>:父组件通过往子组件标签中添加需要传递的数据，子组件使用<strong>props</strong>来接收,<strong>prop只读，不可修改,即单向数据流</strong></p><p><strong>子传父</strong>:<code>$emit</code>绑定一个自定义事件, 当这个语句被执行时, 就会将参数arg传递给父组件,父组件通过v-on监听并接收参数</p><h5 id="2-ref"><a href="#2-ref" class="headerlink" title="2.ref"></a><strong>2.ref</strong></h5><p>适用:<strong>父子组件通信</strong></p><p>如果ref挂载在普通的DOM元素上,引用指向的就是DOM元素;如<strong>果挂载在子组件上,引用就指向组件实例</strong></p><p><strong>父组件可以通过this.$ref.xxx来获取子组件实例</strong></p><h5 id="3-parent-children"><a href="#3-parent-children" class="headerlink" title="3.$parent/$children"></a>3.$parent/$children</h5><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181616964.webp" alt="image"></p><p>适用于:<strong>父子组件通信</strong></p><p>通过<strong>this.$parent</strong>和<strong>this.$children</strong>来获取对应的父子组件实例</p><h5 id="4-EventBus"><a href="#4-EventBus" class="headerlink" title="4.EventBus"></a>4.EventBus</h5><p>适用于:<strong>任意组件间通信</strong></p><p>这种方法通过一个空的Vue实例作为中央<strong>事件总线</strong>，用它来触发事件和监听事件，从而实现任意组件之间的通信</p><p>发布事件:通过$emit来发布事件</p><p>订阅事件:通过$on来订阅事件,当监听到发布的事件后,执行相应的回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组件1 发布事件</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">emit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.bus.$emit.sayhello(<span class="string">&#x27;say&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>)<span class="comment">//发布事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//组件2 订阅事件</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">data</span>:&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.bus.$on(<span class="string">&#x27;say&#x27;</span>,<span class="built_in">this</span>.say)<span class="comment">//订阅事件  </span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">say</span>(<span class="params">word</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(word);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>eventBus也有不方便之处, 当项目较大,就容易造成难以维护的灾难</p></blockquote><h5 id="5-attrs-listeners"><a href="#5-attrs-listeners" class="headerlink" title="5.$attrs/$listeners"></a>5.$attrs/$listeners</h5><p>适用于:<strong>隔代组件通信</strong></p><p><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件。通常配合 inheritAttrs 选项一起使用。</p><p><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的)  v-on 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件</p><h5 id="6-provide-inject"><a href="#6-provide-inject" class="headerlink" title="6.provide/inject"></a>6.provide/inject</h5><p>适用于:<strong>隔代组件通信</strong></p><p><code>provide</code>/ <code>inject</code> 是<code>vue2.2.0</code>新增的api, 简单来说就是父组件中通过<code>provide</code>来提供变量, 然后再子组件中通过<code>inject</code>来注入变量。</p><blockquote><p>注意: 这里不论子组件嵌套有多深, 只要调用了<code>inject</code> 那么就可以注入<code>provide</code>中的数据，而不局限于只能从当前父组件的props属性中回去数据</p></blockquote><h5 id="7-vuex"><a href="#7-vuex" class="headerlink" title="7.vuex"></a>7.vuex</h5><p>适用于:<strong>任意组件间通信</strong></p><p><strong>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. Vuex 解决了<code>多个视图依赖于同一状态</code>和<code>来自不同视图的行为需要变更同一状态</code>的问题，将开发者的精力聚焦于数据的更新而不是数据在组件之间的传递上</p><p>Vuex的各个模块:</p><ul><li><code>state</code>：用于数据的存储，是store中的唯一数据源</li><li><code>getters</code>：如vue中的计算属性一样，基于state数据的二次包装，常用于数据的筛选和多个数据的相关性计算</li><li><code>mutations</code>：类似函数，改变state数据的唯一途径，且不能用于处理异步事件</li><li><code>actions</code>：类似于<code>mutation</code>，用于提交<code>mutation</code>来改变状态，而不直接变更状态，可以包含任意异步操作</li><li><code>modules</code>：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护</li></ul><h5 id="8-localStorage-sessionStorage"><a href="#8-localStorage-sessionStorage" class="headerlink" title="8.localStorage/sessionStorage"></a>8.localStorage/sessionStorage</h5><p>通过浏览器缓存来实现组件间通信</p><h3 id="6-Virtual-DOM"><a href="#6-Virtual-DOM" class="headerlink" title="6.Virtual DOM"></a>6.Virtual DOM</h3><h4 id="1-虚拟dom是什么"><a href="#1-虚拟dom是什么" class="headerlink" title="1.虚拟dom是什么"></a>1.虚拟dom是什么</h4><p><strong>虚拟DOM</strong>简而言之就是，用JS去按照DOM结构来实现的树形结构对象，你也可以叫做<strong>DOM对象</strong></p><h4 id="2-为什么需要虚拟dom"><a href="#2-为什么需要虚拟dom" class="headerlink" title="2.为什么需要虚拟dom"></a>2.为什么需要虚拟dom</h4><p><strong>优点：</strong></p><ul><li><strong>保证性能下限：</strong> 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li><li><strong>无需手动操作 DOM：</strong> 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li><li><strong>跨平台：</strong> 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ul><p><strong>缺点:</strong></p><ul><li><strong>无法进行极致优化：</strong> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li></ul><h4 id="3-vue的虚拟dom解决了什么问题"><a href="#3-vue的虚拟dom解决了什么问题" class="headerlink" title="3.vue的虚拟dom解决了什么问题"></a>3.vue的虚拟dom解决了什么问题</h4><ul><li><strong>无需手动操纵dom</strong></li><li>虚拟dom可以方便的进行<strong>跨平台</strong>操作，例如在node环境中无法应用真实dom，但是可以使用虚拟dom</li></ul><h4 id="4-虚拟DOM的实现原理"><a href="#4-虚拟DOM的实现原理" class="headerlink" title="4.虚拟DOM的实现原理"></a>4.虚拟DOM的实现原理</h4><p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p><ul><li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li><li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li><li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li></ul><h3 id="7-diff"><a href="#7-diff" class="headerlink" title="7.diff"></a>7.diff</h3><h4 id="1-实现diff的思路"><a href="#1-实现diff的思路" class="headerlink" title="1.实现diff的思路"></a>1.实现diff的思路</h4><ul><li>用JS模拟真实DOM节点</li><li>把虚拟DOM转换成真实DOM插入页面中</li><li>发生变化时，比较两棵树的差异，生成差异对象</li><li>根据差异对象更新真实DOM</li></ul><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181739970.webp" alt="img"></p><h4 id="2-vue中的key的作用"><a href="#2-vue中的key的作用" class="headerlink" title="2.vue中的key的作用"></a>2.vue中的key的作用</h4><p>1.key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据<strong>新数据</strong>生成<strong>新的虚拟DOM</strong>，随后Vue进行<strong>新虚拟DOM</strong>与<strong>旧虚拟DOM</strong>的差异比较</p><p>2.对比规则:</p><p>​    (1).<strong>旧虚拟DOM</strong>中找到了与<strong>新虚拟DOM</strong>相同的<strong>key</strong>:</p><p>​          ①.若<strong>虚拟DOM</strong>中内容<strong>没有变化</strong>，直接使用之前的<strong>真实DOM</strong></p><p>​          ②.若<strong>虚拟DOM</strong>中<strong>内容变了</strong>，则生成<strong>新的真实DOM</strong>，随后替换掉页面中之前的<strong>真实DOM</strong></p><p>​    (2).<strong>旧虚拟DOM</strong>中未找到与<strong>新虚拟DOM</strong>相同的<strong>key</strong></p><p>​            创建新的<strong>真实DOM</strong>,随后渲染到页面</p><p>   3.用<strong>index</strong>作为<strong>key</strong>可能会引发的问题:</p><p>​      (1).若对数据进行<strong>逆序添加</strong>、<strong>逆序删除</strong>等<strong>破坏顺序的操作</strong>会产生<strong>没有必要的真实DOM更新</strong>，界                    面效果没有问题，<strong>但是执行效率很低</strong></p><p>​      (2).如果结构中还包含<strong>输入类的DOM</strong>:会产生<strong>错误DOM更新</strong>，<strong>界面有问题</strong></p><p>​    4.开发中如何选择key？</p><p>​        (1).最好使用<strong>每条数据的唯一标识</strong>作为<strong>key</strong>，比如id、手机号、身份证号、学号等唯一值</p><p>​        (2).如果不存在对数据的<strong>逆序添加</strong>、<strong>逆序删除</strong>等<strong>破坏顺序的操作</strong>，仅用于渲染列表用于展示，                    <strong>使用index作为key是没有问题的</strong></p><p><strong>index作为key和id作为key的区别</strong></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181741532.png" alt="image-20210819211653838"></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181741864.png" alt="image-20210819211812731"></p><h3 id="8-Vue-computed-watch"><a href="#8-Vue-computed-watch" class="headerlink" title="8.Vue computed/watch"></a>8.Vue computed/watch</h3><h4 id="1-computed-和-watch-的区别和运用的场景？"><a href="#1-computed-和-watch-的区别和运用的场景？" class="headerlink" title="1.computed 和 watch 的区别和运用的场景？"></a>1.computed 和 watch 的区别和运用的场景？</h4><p><strong>computed：</strong> 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；</p><p><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><p><strong>运用场景：</strong></p><ul><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li><li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul><h3 id="9-Vue和React有什么不同"><a href="#9-Vue和React有什么不同" class="headerlink" title="9.Vue和React有什么不同"></a>9.Vue和React有什么不同</h3><h5 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h5><p>1，都使用了<strong>Virtual DOM</strong>。</p><p>2，都提供了响应式和组件化的视图组件。</p><p>3，都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关库。</p><h5 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h5><p>1，React中，当某组件的状态发生改变时，它会以该组件为根，重新渲染整个组件子树，而在Vue中，组件的依赖是在渲染的过程中自动追踪的，所以系统能准确知晓哪个组件确实需要被重新渲染。</p><p>2，Vue的路由库和状态管理库都由官方维护支持且与核心库同步更新，而React选择把这些问题交给社区维护，因此生态更丰富。</p><p>3，Vue-cli脚手架可进行配置</p><hr><hr><h2 id="4-网络"><a href="#4-网络" class="headerlink" title="4.网络"></a>4.网络</h2><h3 id="1-HTTP"><a href="#1-HTTP" class="headerlink" title="1.HTTP"></a>1.HTTP</h3><h4 id="1-常见的状态码和作用"><a href="#1-常见的状态码和作用" class="headerlink" title="1.常见的状态码和作用"></a>1.常见的状态码和作用</h4><p><strong>1xx</strong></p><hr><p><strong>1xx：表示请求已经被接收,但需要进行后续处理</strong></p><p><strong>100</strong>:表示客户端应该继续发送请求</p><p><strong>101</strong>:表示需要切换协议</p><p><strong>2xx</strong></p><hr><p><strong>请求已成功被服务器接收</strong></p><p><strong>200</strong>:请求已经成功,请求所希望的响应头或数据体将随此响应返回</p><p><strong>201</strong>：请求已经被实现,并且有一个新的资源已经依据请求的需要而创建</p><p><strong>202</strong>：服务器已经接受请求,但尚未处理</p><p><strong>204</strong>:服务器成功处理了请求,但不需要返回任何实体内容</p><p><strong>205</strong>：服务器成功处理了请求，但不需要返回任何实体内容</p><p><strong>3xx</strong></p><hr><p><strong>通常这类状态码用来重定向,重定向目标在本次响应的location头字段中指明</strong></p><p>**301(永久重定向)**：被请求的资源已经永久的移动到新位置，301通常用于网站迁移时，服务器对旧的URL进行301重定向到新的URL。</p><p>**302(临时重定向)**：请求的资源现在临时从不同的uri响应请求</p><p><strong>303</strong>：请求的响应可以在另一个uri上被找到</p><p>**★304(资源未被修改)**：表示上次请求至今，文档的内容并没有改变，客户端可以利用这个状态码做出相应的缓存处理</p><p><strong>4xx</strong></p><hr><p><strong>表示客户端发生了错误妨碍了服务器的处理</strong></p><p><strong>400</strong>：发生了语法错误导致当前请求无法被服务器理解.</p><p><strong>401</strong>:表示当前请求需要用户验证</p><p><strong>403</strong>：表示服务器已经理解请求但是拒绝执行它</p><p><strong>404</strong>：表示请求的资源没有在服务器上被发现</p><p><strong>405</strong>:表示请求的方法不能被用于请求相应的资源</p><p><strong>413</strong>：表示服务器拒绝处理当前请求,因为该请求提交的实体数据大小超过了服务器愿意或者能处理的范围</p><p><strong>5xx</strong></p><hr><p><strong>表示服务器在处理请求的过程中出现了错误</strong></p><p><strong>500</strong>：通常是代码出错，后台出现bug</p><p><strong>502</strong>：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p><p><strong>504</strong>：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器收到响应。注意与502的区别：502是接收到了无效响应比如<code>Connection Refused</code>； 504是响应超时，通常是被墙了。</p><hr><h4 id="2-介绍一下http缓存策略"><a href="#2-介绍一下http缓存策略" class="headerlink" title="2.介绍一下http缓存策略"></a>2.介绍一下http缓存策略</h4><p>HTTP的缓存属于客户端缓存,我们人为浏览器存在一个缓存数据库，用于储存一些不经常变化的静态文件(图片，css，js等)，我们将缓存分为<strong>强制缓存</strong>和<strong>协商缓存</strong></p><h5 id="缓存规则"><a href="#缓存规则" class="headerlink" title="缓存规则"></a>缓存规则</h5><h6 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h6><p>当缓存数据库中已经有所请求的数据时，客户端直接从缓存数据库中获取数据，当缓存数据库中没有所请求的数据时，客户端才会从服务端获取数据</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191430961.webp" alt="img"></p><h6 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h6><p>客户端会从缓存数据库中获取到一个缓存数据的标识,得到标识后请求服务端验证是否失效。如果没有失效服务端会返回304状态码，说明客户端请求的文档还是新鲜的(与缓存文档相同),此时客户端直接从缓存中获取所请求的数据,如果标识失效，服务端会返回更新后的数据</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191439631.webp" alt="img"></p><p>两类缓存机制可以同时存在,强制缓存的优先级高于协商缓存，浏览器在加载资源时，会先判断是否命中<strong>强缓存</strong>再验证是命中<strong>协商缓存</strong>。</p><hr><h5 id="缓存方案"><a href="#缓存方案" class="headerlink" title="缓存方案"></a>缓存方案</h5><h6 id="强制缓存-1"><a href="#强制缓存-1" class="headerlink" title="强制缓存"></a>强制缓存</h6><p>对于强制缓存，服务器响应的header中会用两个字段来表明——Expires和Cache-Control。</p><p><strong>Expires</strong></p><p>这个字段包含了一个时间，过了这个时间，响应将会失效。</p><p>也就是说，<code>Expire</code> 这个字段表示缓存到期时间，我们来打开一个网站并查看 <code>Response Header</code> 看看这个字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires:Fri, 27 Oct 2017 07:55:30 GMT</span><br></pre></td></tr></table></figure><p>可能在你查看这的时候发现时间不对啊，怎么都已经是过去了 ~</p><p><code>GMT</code> 表示的是格林威治时间，和北京时间相差8小时。</p><p>上面的这个时间表示的是 <code>2017年10月27日15:55:30</code>。</p><p>通过设置 <code>Expire</code> 来设置缓存有一个致命缺点：</p><p>可以看出，这个是个绝对时间，也就是说，如果我修改了客户端的本地时间，是不是就会导致判断缓存失效了呢。</p><p><strong>Cache-Control</strong></p><p>既然不能设置绝对时间，那我就设置个相对时间呗。</p><p>在 <code>HTTP/1.1</code> 中，增加了一个字段 <code>Cache-Control</code> ，它包含一个 <code>max-age</code> 属性，该字段表示资源缓存的最大有效时间，这就是一个相对时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:max-age=600</span><br></pre></td></tr></table></figure><p>这个表示的就是最大有效时间是 <code>600s</code> ，对的，它的单位是秒。</p><p><code>Cache-Control</code> 除了 <code>max-age</code> 属性之外还有一些属性：</p><ul><li>no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。</li><li>no-store：禁止使用缓存，每一次都要重新请求数据。</li><li>public：默认设置。</li><li>private：不能被多用户共享。</li></ul><p>现在基本上都会同时设置 <code>Expire</code> 和 <code>Cache-Control</code> ，<code>Cache-Control</code> 的优先级别更高。</p><hr><h6 id="协商缓存-1"><a href="#协商缓存-1" class="headerlink" title="协商缓存"></a>协商缓存</h6><p>协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。 对于协商缓存来说，缓存标识我们需要着重理解一下，下面我们将着重介绍它的两种缓存方案。</p><p><strong>Last-Modified，If-Modified-Since</strong></p><p>浏览器第一次请求资源的时候，服务器返回的 <code>header</code> 上会带有一个 <code>Last-Modified</code> 字段，表示资源<strong>最后修改</strong>的时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Fri, 27 Oct 2017 07:55:30 GMT</span><br></pre></td></tr></table></figure><p>同样的，这是一个 <code>GMT</code> 的绝对时间。</p><p>当浏览器再次请求该资源时，请求头中会带有一个 <code>If-Modified-Since</code> 字段，这个值是第一次请求返回的 <code>Last-Modified</code> 的值。服务器收到这个请求后，将 <code>If-Modified-Since</code> 和当前的 <code>Last-Modified</code> 进行对比。如果相等，则说明资源未修改，返回 <code>304</code>，浏览器使用本地缓存。</p><p>well，这个方法也是有缺点的：</p><ul><li>最小单位是秒。也就是说如果我短时间内资源发生了改变，<code>Last-Modified</code> 并不会发生变化；</li><li>周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 <code>Last-Modified</code> 可不这样认为。</li></ul><p>所以，后来又引入一个 <code>Etag</code>。</p><p><strong>Etag</strong></p><p><code>Etag</code> 一般是由文件内容 <code>hash</code> 生成的，也就是说它可以保证资源的唯一性，资源发生改变就会导致 <code>Etag</code> 发生改变。</p><p>同样地，在浏览器第一次请求资源时，服务器会返回一个 <code>Etag</code> 标识。当再次请求该资源时， 会通过 <code>If-no-match</code> 字段将 <code>Etag</code> 发送回服务器，然后服务器进行比较，如果相等，则返回 <code>304</code> 表示未修改。</p><p><strong><code>Last-Modified</code> 和 <code>Etag</code> 是可以同时设置的，服务器会优先校验 <code>Etag</code>，如果 <code>Etag</code> 相等就会继续比对 <code>Last-Modified</code>，最后才会决定是否返回 <code>304</code>。</strong></p><hr><h5 id="缓存的优点"><a href="#缓存的优点" class="headerlink" title="缓存的优点"></a><strong>缓存的优点</strong></h5><ul><li>减少了冗余的数据传递，节省宽带流量</li><li>减少了服务器的负担，大大提高了网站性能</li><li>加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因。</li></ul><hr><p>当浏览器再次访问一个已经访问过的资源时，它会这样做：</p><ol><li>看看是否命中强缓存，如果命中，就直接使用缓存了；</li><li>如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存；</li><li>如果命中协商缓存，服务器会返回 <code>304</code> 告诉浏览器使用本地缓存；</li><li>否则，返回最新的资源。</li></ol><hr><h4 id="3-介绍一下keep-alive"><a href="#3-介绍一下keep-alive" class="headerlink" title="3.介绍一下keep-alive"></a>3.介绍一下keep-alive</h4><h5 id="1-什么是keep-alive"><a href="#1-什么是keep-alive" class="headerlink" title="1.什么是keep-alive?"></a>1.<strong>什么是keep-alive?</strong></h5><p>keep-alive 是客户端和服务端的一个约定，如果开启 keep-alive，则服务端在返回 response 后不关闭 TCP 连接；同样的，在接收完响应报文后，客户端也不关闭连接，发送下一个 HTTP 请求时会重用该连接。</p><p>在 HTTP/1.0 协议中，如果请求头中包含：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>则代表开启 keep-alive，而服务端的返回报文头中，也会包含相同的内容。</p><p>在 HTTP/1.1 协议中，默认开启 keep-alive，除非显式地关闭它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure><p>keep-alive 技术创建的目的，就是能在多次 HTTP 之间重用同一个 TCP 连接，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等），参考如下示意图（来源：维基百科）：</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191521396.png" alt="image-20220319152129292"></p><p>然而天下没有免费的午餐，如果客户端在接收完所有的信息之后还没有关闭连接，则服务端相应的资源还在被占用（尽管已经没用了）。例如 Tomcat 的 BIO 实现中，未关闭的连接会占用对应的处理线程，如果一个长连接实际上已经处理完毕，但关闭的超时时间未到，则该线程会一直被占用（使用 NIO 的实现没有该问题）。</p><p>显然，如果客户端和服务端的确需要进行多次通信，则开启 keep-alive 是更好的选择，例如在微服务架构中，通常微服务的使用方和提供方会长期有交流，此时最好开启 keep-alive。</p><p>在一些 TPS/QPS 很高的 REST 服务中，如果使用的是短连接（即没有开启keep-alive），则很可能发生客户端端口被占满的情形。这是由于短时间内会创建大量TCP 连接，而在 TCP 四次挥手结束后，客户端的端口会处于 TIME_WAIT一段时间(2*MSL)，这期间端口不会被释放，从而导致端口被占满。这种情况下最好使用长连接。</p><h3 id="2-DNS"><a href="#2-DNS" class="headerlink" title="2.DNS"></a>2.DNS</h3><h4 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS?"></a>什么是DNS?</h4><p><strong>DNS（Domain Name System，域名系统）</strong>，最初，由于ip长且难记，通过ip访问网站不方便。。所以后来通过发明了DNS服务器，这个时候我们访问网站输入网站域名，DNS服务器就解析我们的域名为ip。这样我们实际访问的就是对应的ip地址啦。</p><p>抽象点<strong>DNS就是 一个记录ip地址的超级分布式数据库。</strong></p><h4 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h4><p>当用户在浏览器中输入<a href="http://www.baidu.com时/">www.baidu.com时</a></p><ul><li><p>第1步，查找<strong>浏览器缓存</strong>。</p><blockquote><p>浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制，通常情况下为几分钟到几小时不等。这个缓存时间太长和太短都不好，如果缓存时间太长，一旦域名被解析到的IP有变化，会导致被客户端缓存的域名无法解析到变化后的IP地址，以致该域名不能正常解析，这段时间内有可能会有一部分用户无法访问网站。如果时间设置太短，会导致用户每次访问网站都要重新解析一次域名。</p></blockquote></li><li><p>第2步，查找<strong>系统缓存</strong>。</p><blockquote><p>如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果。其实操作系统也会有一个域名解析的过程，在Windows中可以通过C:\Windows\System32\drivers\etc\hosts文件来设置，你可以将任何域名解析到任何能够访问的IP地址。如果你在这里指定了一个域名对应的IP地址，那么浏览器会首先使用这个IP地址。例如，我们在测试时可以将一个域名解析到一台测试服务器上，这样不用修改任何代码就能测试到单独服务器上的代码的业务逻辑是否正确。正是因为有这种本地DNS解析的规程，所以黑客就有可能通过修改你的域名解析来把特定的域名解析到它指定的IP地址上，导致这些域名被劫持。</p></blockquote></li><li><p>第3步，查找<strong>路由器缓存</strong>。</p><blockquote><p>如果系统缓存中也找不到，那么查询请求就会发向路由器，它一般会有自己的DNS缓存。</p></blockquote></li><li><p>第4步，查找<strong>ISP DNS 缓存</strong>。</p><blockquote><p>运气实在不好，就只能查询ISP DNS 缓存服务器了。在我们的网络配置中都会有”DNS服务器地址”这一项，操作系统会把这个域名发送给这里设置的DNS，也就是本地区的域名服务器，通常是提供给你接入互联网的应用提供商。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约80%的域名解析都到这里就已经完成了，所以ISP DNS主要承担了域名的解析工作。</p></blockquote></li><li><p>第5步，<strong>递归搜索</strong>。</p><blockquote><p>　最无奈的情况发生了, 在前面都没有办法命中的DNS缓存的情况下,(1)本地 DNS服务器即将该请求转发到互联网上的根域（即一个完整域名最后面的那个点，通常省略不写）。(2)根域将所要查询域名中的顶级域（假设要查询ke.qq.com，该域名的顶级域就是com）的服务器IP地址返回到本地DNS。(3) 本地DNS根据返回的IP地址，再向顶级域（就是com域）发送请求。(4) com域服务器再将域名中的二级域（即ke.qq.com中的qq）的IP地址返回给本地DNS。(5) 本地DNS再向二级域发送请求进行查询。(6) 之后不断重复这样的过程，直到本地DNS服务器得到最终的查询结果，并返回到主机。这时候主机才能通过域名访问该网站。</p></blockquote></li></ul><h4 id="DNS的安全问题"><a href="#DNS的安全问题" class="headerlink" title="DNS的安全问题"></a>DNS的安全问题</h4><p>1、DNS欺骗：DNS欺骗即域名信息欺骗是最常见的DNS安全问题。当一个DNS服务器掉入陷阱，使用了来自一个恶意DNS服务器的错误信息，那么该DNS服务器就被欺骗了。DNS欺骗会使那些易受攻击的DNS服务器产生许多安全问题，例如：将用户引导到错误的互联网站点，或者发送一个电子邮件到一个未经授权的邮件服务器。网络攻击者通常通过两种方法进行DNS欺骗。</p><ul><li>缓存感染：黑客会熟练的使用DNS请求，将数据放入一个没有设防的DNS服务器的缓存当中。这些缓存信息会在客户进行DNS访问时返回给客户，从而将客户引导到入侵者所设置的运行木马的Web服务器或邮件服务器上，然后黑客从这些服务器上获取用户信息。<ul><li>DNS信息劫持：入侵者通过监听客户端和DNS服务器的对话，通过猜测服务器响应给客户端的DNS查询ID。每个DNS报文包括一个相关联的16位ID号，DNS服务器根据这个ID号获取请求源位置。黑客在DNS服务器之前将虚假的响应交给用户，从而欺骗客户端去访问恶意的网站。</li><li>DNS重定向：攻击者能够将DNS名称查询重定向到恶意DNS服务器。这样攻击者可以获得DNS服务器的写权限</li></ul></li></ul><p>2、拒绝服务攻击 　　黑客主要利用一些DNS软件的漏洞，如在BIND 9版本（版本9.2.0以前的 9系列）如果有人向运行BIND的设备发送特定的DNS数据包请求，BIND就会自动关闭。攻击者只能使BIND关闭，而无法在服务器上执行任意命令。如果得不到DNS服务，那么就会产生一场灾难：由于网址不能解析为IP地址，用户将无方访问互联网。这样，DNS产生的问题就好像是互联网本身所产生的问题，这将导致大量的混乱。</p><p>3、分布式拒绝服务攻击 　　DDOS 攻击通过使用攻击者控制的几十台或几百台计算机攻击一台主机，使得服务拒绝攻击更难以防范，更难以通过阻塞单一攻击源主机的数据流，来防范服务拒绝攻击。</p><p>4、缓冲区漏洞溢出攻击 　　黑客利用DNS服务器软件存在漏洞，比如对特定的输入没有进行严格检查，那幺有可能被攻击者利用，攻击者构造特殊的畸形数据包来对DNS服务器进行缓冲区溢出攻击。如果这一攻击成功，就会造成DNS服务停止，或者攻击者能够在DNS服务器上执行其设定的任意代码。</p><h4 id="DNS有关的网络性能优化"><a href="#DNS有关的网络性能优化" class="headerlink" title="DNS有关的网络性能优化"></a>DNS有关的网络性能优化</h4><p>1、减少DNS查找，避免重定向 　　浏览器DNS缓存 、计算机DNS缓存、 服务器DNS缓存、使用Keep-Alive特性 来减少DNS查找。考虑影响DNS缓存的因素：</p><ul><li><p>服务器可以设置TTL值表示DNS记录的存活时间。本机DNS缓存将根据这个TTL值判断DNS记录什么时候被抛弃，这个TTL值一般都不会设置很大，主要是考虑到快速故障转移的问题。</p></li><li><p>浏览器DNS缓存也有自己的过期时间，这个时间是独立于本机DNS缓存的，相对也比较短，例如chrome只有1分钟左右。</p></li><li><p>浏览器DNS记录的数量也有限制，如果短时间内访问了大量不同域名的网站，则较早的DNS记录将被抛弃，必须重新查找。不过即使浏览器丢弃了DNS记录，操作系统的DNS缓存也有很大机率保留着该记录，这样可以避免通过网络查询而带来的延迟。</p><p>2、DNS的预解析</p><ul><li>可以通过用meta信息来告知浏览器, 我这页面要做DNS预解析</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;</span><br></pre></td></tr></table></figure><ul><li>可以使用link标签来强制对DNS做预解析:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://ke.qq.com/&quot; /&gt;</span><br></pre></td></tr></table></figure><ul><li>当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等。减少唯一主机名的数量就可以减少DNS查找的数量。较少的域名来减少DNS查找（2-4个主机）</li></ul><p>本文是前端与计算机网络培训的一点总结，关于DNS解析过程做了简短的介绍，相关的安全防范和网络性能优化，还需要更多的学习。</p><h3 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3.TCP"></a>3.TCP</h3><h4 id="什么是TCP-IP"><a href="#什么是TCP-IP" class="headerlink" title="什么是TCP/IP?"></a>什么是TCP/IP?</h4><p><strong>TCP/IP是一类协议系统。他是用于网络通信的一套协议集合</strong></p><p>传统上来说TCP/IP被认为是一个四层协议</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191608064.webp" alt="img"></p><p><strong>1网络接口层:</strong></p><p><strong>主要是指物理层次的一些接口,比如电缆等．</strong></p><ol start="2"><li><strong>网络层:</strong></li></ol><p><strong>提供独立于硬件的逻辑寻址,实现物理地址与逻辑地址的转换．</strong></p><p><strong>在 TCP / IP 协议族中，网络层协议包括 IP 协议（网际协议），ICMP 协议（ Internet 互联网控制报文协议），以及 IGMP 协议（ Internet 组管理协议）.</strong></p><ol start="3"><li><strong>传输层:</strong></li></ol><p><strong>为网络提供了流量控制,错误控制和确认服务.</strong></p><p><strong>在 TCP / IP 协议族中有两个互不相同的传输协议： TCP（传输控制协议）和 UDP（用户数据报协议）.</strong></p><ol start="4"><li><strong>应用层:</strong></li></ol><p><strong>为网络排错,文件传输,远程控制和 Internet 操作提供具体的应用程序</strong></p><h4 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h4><h5 id="三次握手流程"><a href="#三次握手流程" class="headerlink" title="三次握手流程"></a>三次握手流程</h5><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191611193.webp" alt="img"></p><ul><li>客户端发送SYN，表明要向服务器建立连接。同时带上序列号ISN</li><li>服务器返回ACK（序号为客户端序列号+1）作为确认。同时发送SYN作为应答（SYN的序列号为服务端唯一的序号）</li><li>客户端发送ACK确认收到回复（序列号为服务端序列号+1）</li></ul><h5 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手?"></a>为什么是三次握手?</h5><p>tcp连接是全双工的，数据在两个方向上能同时传递。</p><p>所以要<strong>确保双方，同时能发数据和收数据</strong></p><p><strong>第一次握手</strong>：证明了发送方能发数据</p><p><strong>第二次握手</strong>：ack确保了接收方能收数据，syn确保了接收方能发数据</p><p><strong>第三次握手</strong>：确保了发送方能收数据</p><p>实际上是四个维度的信息交换，不过中间两步合并为一次握手了。</p><p>四次握手浪费，两次握手不能保证“双方同时具备收发功能”</p><h4 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h4><h5 id="四次挥手流程"><a href="#四次挥手流程" class="headerlink" title="四次挥手流程"></a>四次挥手流程</h5><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191637291.webp" alt="img"></p><ul><li>主动关闭的一方发送FIN，表示要单方面关闭数据的传输</li><li>服务端收到FIN后，发送一个ACK作为确认（序列号为收到的序列号+1）</li><li>等服务器数据传输完毕，也发送一个FIN标识，表示关闭这个方向的数据传输</li><li>客户端回复ACK以确认回复</li></ul><h5 id="为什么是四次挥手"><a href="#为什么是四次挥手" class="headerlink" title="为什么是四次挥手?"></a>为什么是四次挥手?</h5><ul><li>因为tcp连接是全双工的，数据在两个方向上能同时传递。</li><li>同时tcp支持半关闭（发送一方结束发送还能接收数据的功能）。</li><li>因此每个方向都要单独关闭，且收到关系通知需要发送确认回复</li></ul><h3 id="TCP建立连接和关闭连接对应的状态"><a href="#TCP建立连接和关闭连接对应的状态" class="headerlink" title="TCP建立连接和关闭连接对应的状态"></a>TCP建立连接和关闭连接对应的状态</h3><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191643424.webp" alt="img"></p><h3 id="4-HTTPS"><a href="#4-HTTPS" class="headerlink" title="4.HTTPS"></a>4.HTTPS</h3><h4 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h4><p><strong>什么是HTTPS?</strong></p><p><strong>HTTPS是在HTTP上建立SSL加密层并对传输数据进行加密。是HTTP协议的安全版</strong></p><p>现在他被广泛用于万维网上安全敏感的通讯，例如交易支付方面</p><p>HTTPS的主要作用是:</p><ul><li>对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全</li><li>对网站服务器进行真实身份认证</li></ul><p><strong>为什么需要https?</strong></p><p>原本的http协议中有可能存在信息窃取或者身份伪装等安全问题。使用https通信机制可以有效地结解决这个问题。</p><p><strong>http协议存在的问题:</strong></p><ul><li>通信使用明文(不加密),可能会被窃听</li><li>无法证明报文的完整性，所以可能遭篡改</li><li>不验证通信方的身份，因此有可能遭遇伪装</li></ul><p><strong>https的优势:</strong></p><ul><li><strong>数据隐私性</strong>：内容经过堆成加密，每个连接生成一个唯一的加密密匙</li><li><strong>数据完整性</strong>：内容传输经过完整性校验</li><li><strong>身份认证</strong>：第三方无法伪造服务器(客户端)身份</li></ul><h4 id="HTTPS和HTTP有什么区别"><a href="#HTTPS和HTTP有什么区别" class="headerlink" title="HTTPS和HTTP有什么区别"></a>HTTPS和HTTP有什么区别</h4><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203201056419.webp" alt="img"></p><p>HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。</p><p>通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，<strong>所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP</strong>。</p><p>在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。也就是说<strong>HTTP加上加密处理和认证以及完整性保护后即是HTTPS</strong>。</p><ul><li>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ul><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203201057264.webp" alt="img"></p><p>关于安全性，用最简单的比喻形容两者的关系就是卡车运货，HTTP下的运货车是敞篷的，货物都是暴露的。而https则是封闭集装箱车，安全性自然提升不少。</p><ul><li>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;</li><li>HTTPS需要用到SSL证书，而HTTP不用;</li><li>HTTPS标准端口443，HTTP标准端口80;</li><li>HTTPS基于传输层，HTTP基于应用层;</li><li>HTTPS在浏览器显示绿色安全锁，HTTP没有显示;</li></ul><h3 id="5-CDN"><a href="#5-CDN" class="headerlink" title="5.CDN"></a>5.CDN</h3><h4 id="CDN是什么"><a href="#CDN是什么" class="headerlink" title="CDN是什么?"></a>CDN是什么?</h4><p>CDN的全称是Content Delivery Network，即<strong>内容分发网络</strong>。</p><p><strong>其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定</strong>。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p><p>在不同地域的用户访问网站的响应速度存在差异,为了提高用户访问的响应速度、优化现有Internet中信息的流动,需要在用户和服务器间加入中间层CDN. 使用户能以最快的速度，从最接近用户的地方获得所需的信息，彻底解决网络拥塞，提高响应速度，是目前大型网站使用的流行的应用方案.</p><p><strong>CDN的基本工作过程：</strong></p><ul><li>当用户点击网站页面上的内容URL，先经过本地DNS系统解析，如果本地DNS服务器没有相应域名的缓存，则本地DNS系统会将域名的解析权交给CNAME指向的CDN专用DNS服务器。</li><li>CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户。</li><li>用户向CDN的全局负载均衡设备发起URL访问请求。</li><li>CDN全局负载均衡设备根据用户IP地址，以及用户请求的URL，选择一台用户所属区域的区域负载均衡设备，并将请求转发到此设备上。</li><li>基于以下这些条件的综合分析之后，区域负载均衡设备会选择一个最优的缓存服务器节点，并从缓存服务器节点处得到缓存服务器的IP地址，最终将得到的IP地址返回给全局负载均衡设备：</li><li>根据用户IP地址，判断哪一个边缘节点距用户最近；</li><li>根据用户所请求的URL中携带的内容名称，判断哪一个边缘节点上有用户所需内容；</li><li>查询各个边缘节点当前的负载情况，判断哪一个边缘节点尚有服务能力。</li><li>全局负载均衡设备把服务器的IP地址返回给用户。</li><li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</li></ul><p><strong>CDN的应用场景:</strong></p><ul><li>用户量大的直播平台，需要快速、低延迟的获取各类直播信息</li><li>电子商务网站</li><li>大型企业</li></ul><p>既然CDN的核心作用是提高网络的访问速度，那么其用户也就是访问量很大的网站，例如ICP 、ISP、大型企业、电子商务网站和政府网站等。利用CDN技术，这些网站无需投资昂贵的各类服务器，设立分站点。通过采用CDN，CDN将负责信息传递工作，保证信息正常传输，而技术人员只需要维护网站内容，不需要考虑流量问题。这样，网站可保证用户得到更多的新业务，可以快速访问网络上的内容，获得更好的服务质量。举个例子来讲，对于访问量比较大，而被访问内容更新周期比较长的网站，如政府网站，用户往往进行大量的查询工作。这类网站比较适合采用CDN。还有，大家是否注意到，在所谓的宽带社区中，瓶颈是社区的对外出口。这样，如果采用CDN无疑对社区用户使用视频点播、网络教育等宽带应用提供了保证。</p><h3 id="6-从输入url到页面展示发生了什么"><a href="#6-从输入url到页面展示发生了什么" class="headerlink" title="6.从输入url到页面展示发生了什么"></a>6.从输入url到页面展示发生了什么</h3><p>总体来说分为以下几个过程:</p><ol><li><strong>DNS解析</strong></li><li><strong>TCP连接</strong></li><li><strong>发送HTTP请求</strong></li><li><strong>服务器处理请求并返回HTTP报文</strong></li><li><strong>浏览器解析渲染页面</strong></li><li><strong>连接结束</strong></li></ol><p>具体过程：</p><ol><li>用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL </li><li>用户输入完内容，按下回车键，浏览器导航栏显示loading状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得</li><li>浏览器进程浏览器构建请求行信息，会通过进程间通信（IPC）将URL请求发送给网络进程 GET /index.html HTTP1.1 </li><li>网络进程获取到URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接200返回；否则，进入网络请求过程</li><li>网络进程请求DNS返回域名对应的IP和端口号，如果之前DNS数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的IP和端口号，如果没有端口号，http默认80，https默认443。如果是https请求，还需要建立TLS连接。</li><li>Chrome 有个机制，同一个域名同时最多只能建立 6 个TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立TCP连接。</li><li>TCP三次握手建立连接，http请求加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输</li><li>网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层</li><li>底层通过物理网络传输给目的服务器主机 </li><li>目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层 </li><li>目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层 </li><li>应用层HTTP解析请求头和请求体，如果需要重定向，HTTP直接返回HTTP响应数据的状态code301或者302，同时在请求头的Location字段中附上重定向地址，浏览器会根据code和Location进行重定向操作；如果不是重定向，首先服务器会根据 请求头中的If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；否则，返回新数据，200的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段： Cache-Control:Max-age=2000 响应数据又顺着应用层——传输层——网络层——网络层——传输层——应用层的顺序返回到网络进程 </li><li><strong>数据传输完成，TCP四次挥手断开连接</strong>。如果，浏览器或者服务器在HTTP头部加上如下信息，TCP就一直保持连接。保持TCP连接可以省下下次需要建立连接的时间，提示资源加载速度 Connection:Keep-Alive </li><li>网络进程将获取到的数据包进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是text/html类型，就通知浏览器进程获取到文档准备渲染 </li><li>浏览器进程获取到通知，根据当前页面B是否是从页面A打开的并且和页面A是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程</li><li>浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程 </li><li>浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页 </li><li>渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端知识杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTML </tag>
            
            <tag> Http </tag>
            
            <tag> CSS </tag>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题整理</title>
      <link href="/2022/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2022/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、CSS问题"><a href="#一、CSS问题" class="headerlink" title="一、CSS问题"></a>一、CSS问题</h1><h4 id="1-flex布局"><a href="#1-flex布局" class="headerlink" title="1.flex布局"></a>1.flex布局</h4><blockquote><p>display:flex; 在父元素设置，子元素受弹性盒影响，默认排成一行，如果超出一行，按比例压缩 flex:1; 子元素设置，设置子元素如何分配父元素的空间，flex:1,子元素宽度占满整个父元素align-items:center 定义子元素在父容器中的对齐方式，center 垂直居中justify-content:center 设置子元素在父元素中居中，前提是子元素没有把父元素占满，让子元素水平居中。</p></blockquote><h4 id="2-css3的新特性"><a href="#2-css3的新特性" class="headerlink" title="2.css3的新特性"></a>2.css3的新特性</h4><blockquote><p>transtion transition-property 规定设置过渡效果的 CSS 属性的名称。</p></blockquote><blockquote><p>transition-duration 规定完成过渡效果需要多少秒或毫秒。</p></blockquote><blockquote><p>transition-timing-function 规定速度效果的速度曲线。</p></blockquote><blockquote><p>transition-delay 定义过渡效果何时开始。</p></blockquote><blockquote><p>animation属性可以像Flash制作动画一样，通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果。</p></blockquote><blockquote><p>ainimation实现动画效果主要由两部分组成：</p></blockquote><blockquote><p>通过类似Flash动画中的帧来声明一个动画；</p></blockquote><blockquote><p>在animation属性中调用关键帧声明的动画。</p></blockquote><blockquote><p>translate 3D建模效果</p></blockquote><h4 id="3-img中alt和title的区别"><a href="#3-img中alt和title的区别" class="headerlink" title="3.img中alt和title的区别"></a>3.img中alt和title的区别</h4><blockquote><p>图片中的 alt属性是在图片不能正常显示时出现的文本提示。alt有利于SEO优化</p></blockquote><blockquote><p>图片中的 title属性是在鼠标在移动到元素上的文本提示。</p></blockquote><h4 id="4-用纯CSS创建一个三角形"><a href="#4-用纯CSS创建一个三角形" class="headerlink" title="4.用纯CSS创建一个三角形"></a>4.用纯CSS创建一个三角形</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: 0;</span><br><span class="line">        height: 0;</span><br><span class="line">        border-top: 40px solid transparent;</span><br><span class="line">        border-left: 40px solid transparent;</span><br><span class="line">        border-right: 40px solid transparent;</span><br><span class="line">        border-bottom: 40px solid #ff0000;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="5-如何理解CSS的盒子模型？"><a href="#5-如何理解CSS的盒子模型？" class="headerlink" title="5.如何理解CSS的盒子模型？"></a>5.如何理解CSS的盒子模型？</h4><blockquote><p>标准盒子模型：宽度=内容的宽度（content）+ border + padding</p></blockquote><blockquote><p>低版本IE盒子模型：宽度=内容宽度（content+border+padding)</p></blockquote><h4 id="6-如何让一个div水平居中"><a href="#6-如何让一个div水平居中" class="headerlink" title="6.如何让一个div水平居中"></a>6.如何让一个div水平居中</h4><blockquote><p>已知宽度，block元素 ，添加添加margin:0 auto属性。</p></blockquote><blockquote><p>已知宽度，绝对定位的居中 ，上下左右都为0，margin:auto</p></blockquote><h4 id="7-如何让一个div水平垂直居中"><a href="#7-如何让一个div水平垂直居中" class="headerlink" title="7.如何让一个div水平垂直居中"></a>7.如何让一个div水平垂直居中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">position: relative / fixed; /* 相对定位或绝对定位均可 */</span><br><span class="line">width:500px;</span><br><span class="line">height:300px;</span><br><span class="line">top: 50%;</span><br><span class="line">left: 50%;</span><br><span class="line">margin-top:-150px;</span><br><span class="line">margin-left:-250px;</span><br><span class="line"> 外边距为自身宽高的一半 */</span><br><span class="line">background-color: pink; /* 方便看效果 */</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">display: flex;</span><br><span class="line">align-items: center; /* 垂直居中 */</span><br><span class="line">justify-content: center; /* 水平居中 */</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">.container div &#123;</span><br><span class="line">width: 100px; /* 可省 */</span><br><span class="line">height: 100px; /* 可省 */</span><br><span class="line">background-color: pink; /* 方便看效果 */</span><br><span class="line">&#125;  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="8-如何清除浮动？"><a href="#8-如何清除浮动？" class="headerlink" title="8.如何清除浮动？"></a>8.如何清除浮动？</h4><blockquote><p>clear清除浮动（添加空div法）在浮动元素下方添加空div,并给该元素写css样式 {clear:both;height:0;overflow:hidden;}</p></blockquote><blockquote><p>给浮动元素父级设置高度</p></blockquote><blockquote><p>父级同时浮动（需要给父级同级元素添加浮动）</p></blockquote><blockquote><p>父级设置成inline-block，其margin: 0 auto居中方式失效</p></blockquote><blockquote><p>给父级添加overflow:hidden 清除浮动方法</p></blockquote><blockquote><p>万能清除法 after伪类 清浮动（现在主流方法，推荐使用）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">float_div:after&#123;</span><br><span class="line">content:&quot;.&quot;;</span><br><span class="line">clear:both;</span><br><span class="line">display:block;</span><br><span class="line">height:0;</span><br><span class="line">overflow:hidden;</span><br><span class="line">visibility:hidden;</span><br><span class="line">&#125;</span><br><span class="line">.float_div&#123;</span><br><span class="line">zoom:1</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="9-css3实现三栏布局，左右固定，中间自适应"><a href="#9-css3实现三栏布局，左右固定，中间自适应" class="headerlink" title="9.css3实现三栏布局，左右固定，中间自适应"></a>9.css3实现三栏布局，左右固定，中间自适应</h4><blockquote><p>圣杯布局/双飞翼布局</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        .middle,</span><br><span class="line">        .left,</span><br><span class="line">        .right &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            float: left;</span><br><span class="line">            min-height: 130px;</span><br><span class="line">        &#125;</span><br><span class="line">        .container &#123;</span><br><span class="line">            padding: 0 220px 0 200px;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">        .left &#123;</span><br><span class="line">            margin-left: -100%;</span><br><span class="line">            left: -200px;</span><br><span class="line">            width: 200px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .right &#123;</span><br><span class="line">            margin-left: -220px;</span><br><span class="line">            right: -220px;</span><br><span class="line">            width: 220px;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line">        .middle &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            background: blue;</span><br><span class="line">            word-break: break-all;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&#x27;container&#x27;&gt;</span><br><span class="line">        &lt;div class=&#x27;middle&#x27;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&#x27;left&#x27;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&#x27;right&#x27;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="10-display-none-和-visibility-hidden的区别"><a href="#10-display-none-和-visibility-hidden的区别" class="headerlink" title="10.display:none 和 visibility: hidden的区别"></a>10.display:none 和 visibility: hidden的区别</h4><blockquote><p>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</p></blockquote><blockquote><p>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p></blockquote><h4 id="11-CSS中-link-和-import-的区别是？"><a href="#11-CSS中-link-和-import-的区别是？" class="headerlink" title="11.CSS中 link 和@import 的区别是？"></a>11.CSS中 link 和@import 的区别是？</h4><blockquote><p>link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载</p></blockquote><blockquote><p>import只在IE5以上才能识别，而link是HTML标签，无兼容问题</p></blockquote><blockquote><p>link方式的样式的权重 高于@import的权重.</p></blockquote><h4 id="12-position的absolute与fixed共同点与不同点"><a href="#12-position的absolute与fixed共同点与不同点" class="headerlink" title="12.position的absolute与fixed共同点与不同点"></a>12.position的absolute与fixed共同点与不同点</h4><blockquote><p>共同点： 改变行内元素的呈现方式，display被置为block 让元素脱离普通流，不占据空间 默认会覆盖到非定位元素上</p></blockquote><blockquote><p>不同点： absolute的”根元素“是可以设置的 fixed的”根元素“固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p></blockquote><h4 id="13-transition和animation的区别"><a href="#13-transition和animation的区别" class="headerlink" title="13..transition和animation的区别"></a>13..transition和animation的区别</h4><blockquote><p>Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性， 而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from …. to，而animation可以一帧一帧的。</p></blockquote><blockquote><p>transition 规定动画的名字  规定完成过渡效果需要多少秒或毫秒  规定速度效果  定义过渡效果何时开始 animation  指定要绑定到选择器的关键帧的名称</p></blockquote><h4 id="14-CSS优先级"><a href="#14-CSS优先级" class="headerlink" title="14.CSS优先级"></a>14.CSS优先级</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">不同级别：总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</span><br><span class="line">1.属性后面加!import 会覆盖页面内任何位置定义的元素样式</span><br><span class="line">2.作为style属性写在元素内的样式</span><br><span class="line">3.id选择器</span><br><span class="line">4.类选择器</span><br><span class="line">5.标签选择器</span><br><span class="line">6.通配符选择器（*）</span><br><span class="line">7.浏览器自定义或继承</span><br><span class="line">**同一级别：后写的会覆盖先写的**</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>css选择器的解析原则：选择器定位DOM元素是从右往左的方向，这样可以尽早的过滤掉一些不必要的样式规则和元素</p></blockquote><h4 id="15-雪碧图："><a href="#15-雪碧图：" class="headerlink" title="15.雪碧图："></a>15.雪碧图：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        多个图片集成在一个图片中的图</span><br><span class="line">使用雪碧图可以减少网络请求的次数，加快允许的速度</span><br><span class="line">通过background-position，去定位图片在屏幕的哪个位置</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="二、JS问题"><a href="#二、JS问题" class="headerlink" title="二、JS问题"></a>二、JS问题</h1><h4 id="1-typeof和instance-of-检测数据类型有什么区别？"><a href="#1-typeof和instance-of-检测数据类型有什么区别？" class="headerlink" title="1.typeof和instance of 检测数据类型有什么区别？"></a>1.typeof和instance of 检测数据类型有什么区别？</h4><blockquote><p>相同点： 都常用来判断一个变量是否为空，或者是什么类型的。</p></blockquote><blockquote><p>不同点： typeof        返回值是一个字符串，用来说明变量的数据类型 instanceof        用于判断一个变量是否属于某个对象的实例.</p></blockquote><h4 id="16-使元素消失的方法"><a href="#16-使元素消失的方法" class="headerlink" title="16.使元素消失的方法"></a>16.使元素消失的方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">visibility:hidden、display:none、z-index=-1、opacity：0</span><br><span class="line">1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发</span><br><span class="line">2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件</span><br><span class="line">3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="谈一谈深克隆和浅克隆？"><a href="#谈一谈深克隆和浅克隆？" class="headerlink" title=".谈一谈深克隆和浅克隆？"></a>.谈一谈深克隆和浅克隆？</h4><blockquote><p>浅克隆: 只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。</p></blockquote><blockquote><p>深克隆： 创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。 JSON.parse、JSON.stringify()</p></blockquote><h4 id="3-es6的新特性都有哪些？"><a href="#3-es6的新特性都有哪些？" class="headerlink" title="3.es6的新特性都有哪些？"></a>3.es6的新特性都有哪些？</h4><blockquote><p>let定义块级作用域变量 没有变量的提升，必须先声明后使用 let声明的变量，不能与前面的let，var，conset声明的变量重名</p></blockquote><blockquote><p>const 定义只读变量 const声明变量的同时必须赋值，const声明的变量必须初始化，一旦初始化完毕就不允许修改 const声明变量也是一个块级作用域变量 const声明的变量没有“变量的提升”，必须先声明后使用 const声明的变量不能与前面的let， var ， const声明的变量重 const定义的对象\数组中的属性值可以修改,基础数据类型不可以</p></blockquote><blockquote><p>ES6可以给形参函数设置默认值</p></blockquote><blockquote><p>在数组之前加上三个点（…）展开运算符</p></blockquote><blockquote><p>数组的解构赋值、对象的解构赋值</p></blockquote><blockquote><p>箭头函数的特点 箭头函数相当于匿名函数，是不能作为构造函数的，不能被new 箭头函数没有arguments实参集合,取而代之用…剩余运算符解决 箭头函数没有自己的this。他的this是继承当前上下文中的this 箭头函数没有函数原型 箭头函数不能当做Generator函数，不能使用yield关键字 不能使用call、apply、bind改变箭头函数中this指向 Set数据结构，数组去重</p></blockquote><h4 id="4-和-区别是什么？"><a href="#4-和-区别是什么？" class="headerlink" title="4.==和===区别是什么？"></a>4.==和===区别是什么？</h4><blockquote><p>=赋值</p></blockquote><blockquote><p>==返回一个布尔值；相等返回true，不相等返回false； 允许不同数据类型之间的比较； 如果是不同类型的数据进行，会默认进行数据类型之间的转换； 如果是对象数据类型的比较，比较的是空间地址</p></blockquote><blockquote><p>=== 只要数据类型不一样，就返回false；</p></blockquote><h4 id="5-常见的设计模式有哪些？"><a href="#5-常见的设计模式有哪些？" class="headerlink" title="5.常见的设计模式有哪些？"></a>5.常见的设计模式有哪些？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、js工厂模式</span><br><span class="line">2、js构造函数模式</span><br><span class="line">3、js原型模式</span><br><span class="line">4、构造函数+原型的js混合模式</span><br><span class="line">5、构造函数+原型的动态原型模式</span><br><span class="line">6、观察者模式</span><br><span class="line">7、发布订阅模式</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="6-call-bind-apply-的区别？"><a href="#6-call-bind-apply-的区别？" class="headerlink" title="6.call bind apply 的区别？"></a>6.call bind apply 的区别？</h4><blockquote><p>call() 和apply()的第一个参数相同，就是指定的对象。这个对象就是该函数的执行上下文。</p></blockquote><blockquote><p>call()和apply()的区别就在于，两者之间的参数。</p></blockquote><blockquote><p>call()在第一个参数之后的 后续所有参数就是传入该函数的值。</p></blockquote><blockquote><p>apply() 只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。 bind() 方法和前两者不同在于： bind() 方法会返回执行上下文被改变的函数而不会立即执行，而前两者是    直接执行该函数。他的参数和call()相同。</p></blockquote><h4 id="7-js继承方式有哪些？"><a href="#7-js继承方式有哪些？" class="headerlink" title="7.js继承方式有哪些？"></a>7.js继承方式有哪些？</h4><blockquote><p>原型链继承 核心： 将父类的实例作为子类的原型</p></blockquote><blockquote><p>构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类</p></blockquote><blockquote><p>实例继承 核心：为父类实例添加新特性，作为子类实例返回</p></blockquote><blockquote><p>拷贝继承</p></blockquote><blockquote><p>组合继承 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现    函数复用</p></blockquote><blockquote><p>寄生组合继承 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实    例方法/属性，避免的组合继承的缺点</p></blockquote><h4 id="8-你怎样看待闭包？"><a href="#8-你怎样看待闭包？" class="headerlink" title="8.你怎样看待闭包？"></a>8.你怎样看待闭包？</h4><blockquote><p>个人感觉，简单来说闭包就是在函数里面声明函数，本质上说就是在函数内部和函数外部搭建起一座桥梁，使得子函数可以访问父函数中所有的局部变量，但是反之不可以，这只是闭包的作用之一，另一个作用，则是保护变量不受外界污染，使其一直存在内存中，在工作中我们还是少使用闭包的好，因为闭包太消耗内存，不到万不得已的时候尽量不使用。</p></blockquote><h4 id="9-你是如何理解原型和原型链的？"><a href="#9-你是如何理解原型和原型链的？" class="headerlink" title="9.你是如何理解原型和原型链的？"></a>9.你是如何理解原型和原型链的？</h4><blockquote><p>把所有的对象共用的属性全部放在堆内存的一个对象（共用属性组成的对象），然后让每一个对象的 __proto__存储这个「共用属性组成的对象」的地址。而这个共用属性就是原型，原型出现的目的就是为了减少不必要的内存消耗。而原型链就是对象通过__proto__向当前实例所属类的原型上查找属性或方法的机制，如果找到Object的原型上还是没有找到想要的属性或者是方法则查找结束，最终会返回undefined</p></blockquote><h4 id="10-浏览器渲染的主要流程是什么"><a href="#10-浏览器渲染的主要流程是什么" class="headerlink" title="10.浏览器渲染的主要流程是什么?"></a>10.浏览器渲染的主要流程是什么?</h4><blockquote><p>将html代码按照深度优先遍历来生成DOM树。 css文件下载完后也会进行渲染，生成相应的CSSOM。 当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。 接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。 最后，通过Painting环节将所有的节点内容呈现到屏幕上。</p></blockquote><h4 id="11-从输入url地址到页面相应都发生了什么？"><a href="#11-从输入url地址到页面相应都发生了什么？" class="headerlink" title="11.从输入url地址到页面相应都发生了什么？"></a>11.从输入url地址到页面相应都发生了什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、浏览器的地址栏输入URL并按下回车。2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。3、DNS解析URL对应的IP。4、根据IP建立TCP连接（三次握手）。5、HTTP发起请求。6、服务器处理请求，浏览器接收HTTP响应。7、渲染页面，构建DOM树。8、关闭TCP连接（四次挥手）复制代码</span><br></pre></td></tr></table></figure><h4 id="12-session、cookie、localStorage的区别"><a href="#12-session、cookie、localStorage的区别" class="headerlink" title="12.session、cookie、localStorage的区别"></a>12.session、cookie、localStorage的区别</h4><blockquote><p>相同点 都是保存在浏览器端，且同源的。</p></blockquote><blockquote><p>不同点</p></blockquote><ul><li>cookie数据始终在同源的http请求中携带，即cookie在浏览器和服务器间来回传递。</li><li>而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li><li>cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。 存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据。</li><li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；</li><li>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；</li><li>cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</li><li>localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li></ul><h4 id="13-js中跨域方法"><a href="#13-js中跨域方法" class="headerlink" title="13.js中跨域方法"></a>13.js中跨域方法</h4><blockquote><p>同源策略（协议+端口号+域名要相同）</p></blockquote><blockquote><p>1、jsonp跨域(只能解决get） 原理：动态创建一个script标签。利用script标签的src属性不受同源策略限制，因为所有的src属性和href属性都不受同源策略的限制，可以请求第三方服务器资源内容</p><blockquote><p>步骤： 1).去创建一个script标签 2).script的src属性设置接口地址 3).接口参数，必须要带一个自定义函数名，要不然后台无法返回数据 4).通过定义函数名去接受返回的数据</p></blockquote></blockquote><blockquote><p>2、document.domain 基础域名相同 子域名不同</p></blockquote><blockquote><p>3、window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name</p></blockquote><blockquote><p>4、服务器设置对CORS的支持 原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p></blockquote><blockquote><p>5、利用h5新特性window.postMessage()</p></blockquote><h4 id="14-前端有哪些页面优化方法"><a href="#14-前端有哪些页面优化方法" class="headerlink" title="14.前端有哪些页面优化方法?"></a>14.前端有哪些页面优化方法?</h4><ul><li>减少 HTTP请求数</li><li>从设计实现层面简化页面</li><li>合理设置 HTTP缓存</li><li>资源合并与压缩</li><li>合并 CSS图片，减少请求数的又一个好办法。</li><li>将外部脚本置底（将脚本内容在页面信息内容加载后再加载）</li><li>多图片网页使用图片懒加载。</li><li>在js中尽量减少闭包的使用</li><li>尽量合并css和js文件</li><li>尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片</li><li>减少对DOM的操作</li><li>在JS中避免“嵌套循环”和 “死循环”</li><li>尽可能使用事件委托（事件代理）来处理事件绑定的操作</li></ul><h4 id="15-Ajax的四个步骤"><a href="#15-Ajax的四个步骤" class="headerlink" title="15.Ajax的四个步骤"></a>15.Ajax的四个步骤</h4><blockquote><p>1.创建ajax实例</p></blockquote><blockquote><p>2.执行open 确定要访问的链接 以及同步异步</p></blockquote><blockquote><p>3.监听请求状态</p></blockquote><blockquote><p>4.发送请求</p></blockquote><h4 id="16-数组去重的方法"><a href="#16-数组去重的方法" class="headerlink" title="16.数组去重的方法"></a>16.数组去重的方法</h4><blockquote><p>ES6的set对象 先将原数组排序，在与相邻的进行比较，如果不同则存入新数组</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr)&#123;    var arr2 = arr.sort();    var res = [arr2[0]];    for(var i=1;i&lt;arr2.length;i++)&#123;        if(arr2[i] !== res[res.length-1])&#123;        res.push(arr2[i]);    &#125;&#125;return res;&#125;利用下标查询 function unique(arr)&#123;    var newArr = [arr[0]];    for(var i=1;i&lt;arr.length;i++)&#123;        if(newArr.indexOf(arr[i]) == -1)&#123;        newArr.push(arr[i]);    &#125;&#125;return newArr;&#125;复制代码</span><br></pre></td></tr></table></figure><h4 id="17-ajax中get和post请求的区别"><a href="#17-ajax中get和post请求的区别" class="headerlink" title="17.ajax中get和post请求的区别"></a>17.ajax中get和post请求的区别</h4><ul><li>get 一般用于获取数据</li><li>get请求如果需要传递参数，那么会默认将参数拼接到url的后面；然后发送给服务器；</li><li>get请求传递参数大小是有限制的；是浏览器的地址栏有大小限制；</li><li>get安全性较低</li><li>get 一般会走缓存，为了防止走缓存，给url后面每次拼的参数不同；放在?后面，一般用个时间戳</li><li>post 一般用于发送数据</li><li>post传递参数，需要把参数放进请求体中，发送给服务器；</li><li>post请求参数放进了请求体中，对大小没有要求；</li><li>post安全性比较高；</li><li>post请求不会走缓存；</li><li></li></ul><h4 id="18-ajax的状态码"><a href="#18-ajax的状态码" class="headerlink" title="18.ajax的状态码"></a>18.ajax的状态码</h4><blockquote><p>2开头</p></blockquote><ul><li>200 : 代表请求成功；</li></ul><blockquote><p>3开头</p></blockquote><ul><li>301 : 永久重定向；</li><li>302: 临时转移</li><li>304 : 读取缓存 [表示浏览器端有缓存，并且服务端未更新，不再向服务端请求资源]</li><li>307:临时重定向</li></ul><blockquote><p>以4开头的都是客户端的问题；</p></blockquote><ul><li>400 :数据/格式错误</li><li>401: 权限不够；（身份不合格，访问网站的时候，登录和不登录是不一样的）</li><li>404 : 路径错误，找不到文件</li></ul><blockquote><p>以5开头都是服务端的问题</p></blockquote><ul><li>500 : 服务器的问题</li><li>503: 超负荷；</li></ul><h4 id="19-移动端的兼容问题"><a href="#19-移动端的兼容问题" class="headerlink" title="19.移动端的兼容问题"></a>19.移动端的兼容问题</h4><ul><li><p>给移动端添加点击事件会有300S的延迟 如果用点击事件，需要引一个fastclick.js文件，解决300s的延迟 一般在移动端用ontouchstart、ontouchmove、ontouchend</p></li><li><p>移动端点透问题,touchstart 早于 touchend 早于click,click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上 尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。 用fastclick，<a href="https://link.juejin.cn/?target=https://github.com/ftlabs/fastclick">github.com/ftlabs/fast…</a> 用preventDefault阻止a标签的click 消除 IE10 里面的那个叉号 input:-ms-clear{display:none;}</p></li><li><p>设置缓存 手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。</p></li><li><p>圆角BUG 某些Android手机圆角失效 background-clip: padding-box; 防止手机中网页放大和缩小 这点是最基本的，做为手机网站开发者来说应该都知道的，就是设置meta中的viewport</p></li><li><p>设置用户截止缩放，一般写视口的时候就已经写好了。</p></li><li></li></ul><h4 id="20-JS中同步和异步-以及js的事件流"><a href="#20-JS中同步和异步-以及js的事件流" class="headerlink" title="20.JS中同步和异步,以及js的事件流"></a>20.JS中同步和异步,以及js的事件流</h4><blockquote><p>同步：在同一时间内做一件事情</p></blockquote><blockquote><p>异步：在同一时间内做多个事情 JS是单线程的，每次只能做一件事情，JS运行在浏览器中，浏览器是多线程的，可以在同一时间执行多个任务。</p></blockquote><h4 id="21-JS中常见的异步任务"><a href="#21-JS中常见的异步任务" class="headerlink" title="21.JS中常见的异步任务"></a>21.JS中常见的异步任务</h4><blockquote><p>定时器、ajax、事件绑定、回调函数、async await、promise</p></blockquote><h4 id="22-TCP的三次握手和四次挥手"><a href="#22-TCP的三次握手和四次挥手" class="headerlink" title="22.TCP的三次握手和四次挥手"></a>22.TCP的三次握手和四次挥手</h4><blockquote><p>三次握手</p></blockquote><ul><li>第一次握手：客户端发送一个SYN码给服务器，要求建立数据连接；</li><li>第二次握手： 服务器SYN和自己处理一个SYN（标志）；叫SYN+ACK（确认包）；发送给客户端，可以建立连接</li><li>第三次握手： 客户端再次发送ACK向服务器，服务器验证ACK没有问题，则建立起连接；</li></ul><blockquote><p>四次挥手</p></blockquote><ul><li>第一次挥手： 客户端发送FIN(结束)报文，通知服务器数据已经传输完毕；</li><li>第二次挥手: 服务器接收到之后，通知客户端我收到了SYN,发送ACK(确认)给客户端，数据还没有传输完成</li><li>第三次挥手： 服务器已经传输完毕，再次发送FIN通知客户端，数据已经传输完毕</li><li>第四次挥手： 客户端再次发送ACK,进入TIME_WAIT状态；服务器和客户端关闭连接；</li></ul><h4 id="23-为什么建立连接是三次握手，而断开连接是四次挥手呢"><a href="#23-为什么建立连接是三次握手，而断开连接是四次挥手呢" class="headerlink" title="23.为什么建立连接是三次握手，而断开连接是四次挥手呢?"></a>23.为什么建立连接是三次握手，而断开连接是四次挥手呢?</h4><blockquote><blockquote><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p></blockquote></blockquote><h4 id="24-DOM-diff原理"><a href="#24-DOM-diff原理" class="headerlink" title="24.DOM diff原理"></a>24.DOM diff原理</h4><blockquote><ul><li>如果元素类型发生变化，直接替换</li><li>如果是文本，则比较文本里面的内容，是否有差异，如果是元素就需要比较当前元素的属性是否相等,会先比较key， 在比较类型 为什么 react中循环 建议不要使用索引 ,如果纯为了展示 那可以使用索引</li></ul></blockquote><h4 id="25-作用域"><a href="#25-作用域" class="headerlink" title="25.作用域"></a>25.作用域</h4><blockquote><p>全局作用域</p></blockquote><ul><li>浏览器打开一个页面时，浏览器会给JS代码提供一个全局的运行环境，那么这个环境就是全局作用域 一个页面只有一个全局作用域，全局作用域下有一个window对象 window是全局作用域下的最大的一个内置对象（全局作用域下定义的变量和函数都会存储在window下） 如果是全局变量，都会给window新增一个键值对；属性名就是变量名，属性值就是变量所存储的值 如果变量只被var过，那么存储值是undefined 在私有作用域中是可以获取到全局变量的，但是在全局作用域中不能获取私有变量</li></ul><blockquote><p>私有作用域</p></blockquote><ul><li>函数执行会形成一个新的私有的作用域（执行多次，形成多个私有作用域） 私有作用域在全局作用域中形成，具有包含的关系； 在一个全局作用域中，可以有很多个私有作用域 在私有作用域下定义的变量都是私有变量 形参也是私有变量 函数体中通过function定义的函数也是私有的，在全局作用域不能使用；</li></ul><blockquote><p>块级作用域</p></blockquote><ul><li>es6中新引入的一种作用域 在js中常见到的if{}、for{}、while{}、try{}、catch{}、switch case{}都是块级作用域 var obj = {} //对象的大括号不是块级作用域 块级作用域中的同一变量不能被重复声明（块级下var和function不能重名，否则会报错） 作用域链</li></ul><blockquote><p>上级作用域</p></blockquote><ul><li>函数在哪里定义，他的上一级作用域就是哪，和函数在哪个作用域下执行没有关系 作用域链：当获取变量所对应的值时，首先看变量是否是私有变量，如果不是私有变量，要继续向上一级作用域中查找，如果上一级也没有，那么会继续向上一级查找，直到找到全局作用域为止；如果全局作用域也没有，则会报错；这样一级一级向上查找，就会形成作用域链 当前作用域没有的，则会继续向上一级作用域查找 当前函数的上一级作用域跟函数在哪个作用域下执行没有关系，只跟函数在哪定义有关（重点）</li></ul><h4 id="26-Promise处理异步"><a href="#26-Promise处理异步" class="headerlink" title="26.Promise处理异步"></a>26.Promise处理异步</h4><blockquote><p>他是ES6中新增加的一个类（new Promise）,目的是为了管理JS中的异步编程的，所以把他称为“Promise设计模式” new Promise 经历三个状态：padding(准备状态：初始化成功、开始执行异步的任务)、fullfilled(成功状态)、rejected(失败状态)== Promise本身是同步编程的，他可以管理异步操作的（重点），new Promise的时候，会把传递的函数立即执行 Promise函数天生有两个参数，resolve(当异步操作执行成功，执行resolve方法),rejected(当异步操作失败，执行reject方法) then()方法中有两个函数，第一个传递的函数是resolve,第二个传递的函数是reject ajax中false代表同步，true代表异步，如果使用异步，不等ajax彻底完成</p></blockquote><h4 id="27-map和forEach的区别"><a href="#27-map和forEach的区别" class="headerlink" title="27.map和forEach的区别"></a>27.map和forEach的区别</h4><blockquote><p>相同点</p></blockquote><ul><li>都是循环遍历数组中的每一项 forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组），需要用哪个的时候就写哪个 匿名函数中的this都是指向window 只能遍历数组</li></ul><blockquote><p>不同点</p></blockquote><ul><li>map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。(原数组进行处理之后对应的一个新的数组。) map()方法不会改变原始数组 map()方法不会对空数组进行检测 forEach()方法用于调用数组的每个元素，将元素传给回调函数.(没有return，返回值是undefined）</li></ul><blockquote><blockquote><p><strong>注意</strong>：forEach对于空数组是不会调用回调函数的。</p></blockquote></blockquote><h4 id="28-async-await函数"><a href="#28-async-await函数" class="headerlink" title="28.async await函数"></a>28.async await函数</h4><blockquote><p>async/await函数是异步代码的新方式</p></blockquote><blockquote><p>async/await是基于promise实现的</p></blockquote><blockquote><p>async/await使异步代码更像同步代码</p></blockquote><blockquote><p>await 只能在async函数中使用，不能再普通函数中使用，要成对出现</p></blockquote><blockquote><p>默认返回一个promise实例，不能被改变</p></blockquote><blockquote><p>await下面的代码是异步，后面的代码是同步的</p></blockquote><h4 id="29-this指向"><a href="#29-this指向" class="headerlink" title="29.this指向"></a>29.this指向</h4><blockquote><ul><li>全局作用域下的this指向window</li><li>如果给元素的事件行为绑定函数，那么函数中的this指向当前被绑定的那个元素</li><li>函数中的this，要看函数执行前有没有 . , 有 . 的话，点前面是谁，this就指向谁，如果没有点，指向window</li><li>自执行函数中的this永远指向window</li><li>定时器中函数的this指向window</li><li>构造函数中的this指向当前的实例</li><li>call、apply、bind可以改变函数的this指向</li><li>箭头函数中没有this，如果输出this，就会输出箭头函数定义时所在的作用域中的this</li></ul></blockquote><h4 id="30-原型"><a href="#30-原型" class="headerlink" title="30.原型"></a>30.原型</h4><blockquote><blockquote><p>所有的函数数据类型都天生自带一个prototype属性，该属性的属性值是一个对象 prototype的属性值中天生自带一个constructor属性，其constructor属性值指向当前原型所属的类 所有的对象数据类型，都天生自带一个_proto_属性，该属性的属性值指向当前实例所属类的原型</p></blockquote></blockquote><h4 id="31-异步回调（如何解决回调地狱）"><a href="#31-异步回调（如何解决回调地狱）" class="headerlink" title="31.异步回调（如何解决回调地狱）"></a>31.异步回调（如何解决回调地狱）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise、generator、async/awaitpromise： 1.是一个对象，用来传递异步操作的信息。代表着某个未来才会知道结果的时间，并未这个事件提供统一的api，供进异步处理  2.有了这个对象，就可以让异步操作以同步的操作的流程来表达出来，避免层层嵌套的回调地狱  3.promise代表一个异步状态，有三个状态pending（进行中），Resolve(以完成），Reject（失败）  4.一旦状态改变，就不会在变。任何时候都可以得到结果。从进行中变为以完成或者失败promise.all() 里面状态都改变，那就会输出，得到一个数组promise.race() 里面只有一个状态变为rejected或者fulfilled即输出promis.finally()不管指定不管Promise对象最后状态如何，都会执行的操作（本质上还是then方法的特例）复制代码</span><br></pre></td></tr></table></figure><h4 id="32-前端事件流"><a href="#32-前端事件流" class="headerlink" title="32.前端事件流"></a>32.前端事件流</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件流描述的是从页面中接受事件的顺序，事件 捕获阶段 处于目标阶段 事件冒泡阶段 addeventListener 最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。  1、事件捕获阶段：实际目标div在捕获阶段不会接受事件，也就是在捕获阶段，事件从document到&lt;html&gt;再到&lt;body&gt;就停止了。      2、处于目标阶段：事件在div发生并处理，但是事件处理会被看成是冒泡阶段的一部分。      3、冒泡阶段：事件又传播回文档   阻止冒泡事件event.stopPropagation()  function stopBubble(e) &#123;    if (e &amp;&amp; e.stopPropagation) &#123; // 如果提供了事件对象event 这说明不是IE浏览器      e.stopPropagation()    &#125; else &#123;      window.event.cancelBubble = true //IE方式阻止冒泡          &#125;     &#125;   阻止默认行为event.preventDefault() function stopDefault(e) &#123;    if (e &amp;&amp; e.preventDefault) &#123;      e.preventDefault()    &#125; else &#123;      // IE浏览器阻止函数器默认动作的行为      window.event.returnValue = false    &#125;  &#125;复制代码</span><br></pre></td></tr></table></figure><h4 id="33-事件如何先捕获后冒泡？"><a href="#33-事件如何先捕获后冒泡？" class="headerlink" title="33.事件如何先捕获后冒泡？"></a>33.事件如何先捕获后冒泡？</h4><blockquote><p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果， 对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。</p></blockquote><ul><li>哪些事件不支持冒泡事件：鼠标事件：mouserleave  mouseenter 焦点事件：blur focus UI事件：scroll resize</li></ul><h4 id="34-如何判断一个变量是对象还是数组（prototype-toString-call-）。"><a href="#34-如何判断一个变量是对象还是数组（prototype-toString-call-）。" class="headerlink" title="34. 如何判断一个变量是对象还是数组（prototype.toString.call()）。"></a>34. 如何判断一个变量是对象还是数组（prototype.toString.call()）。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。复制代码</span><br></pre></td></tr></table></figure><blockquote><p>typeOf()是判断基本类型的Boolean,Number，symbol, undefined, String。 对于引用类型：除function，都返回object   null返回object。</p></blockquote><blockquote><p>installOf() 用来判断A是否是B的实例，installof检查的是原型。</p></blockquote><blockquote><p>toString() 是Object的原型方法，对于 Object 对象，直接调用 toString()  就能返回 [Object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p></blockquote><blockquote><p>hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。</p></blockquote><blockquote><p>isProperty()方法测试一个对象是否存在另一个对象的原型链上。</p></blockquote><h4 id="35-setTimeout-和-setInterval的机制"><a href="#35-setTimeout-和-setInterval的机制" class="headerlink" title="35.setTimeout 和 setInterval的机制"></a>35.setTimeout 和 setInterval的机制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为js是单线程的。浏览器遇到etTimeout 和 setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码复制代码</span><br></pre></td></tr></table></figure><h4 id="36-splice和slice、map和forEach、-filter-、reduce-的区别"><a href="#36-splice和slice、map和forEach、-filter-、reduce-的区别" class="headerlink" title="36.splice和slice、map和forEach、 filter()、reduce()的区别"></a>36.splice和slice、map和forEach、 filter()、reduce()的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.slice(start,end):方法可以从已有数组中返回选定的元素，返回一个新数组， 包含从start到end（不包含该元素）的数组方法注意：该方法不会更新原数组，而是返回一个子数组 2.splice():该方法想或者从数组中添加或删除项目，返回被删除的项目。（该方法会改变原数组）splice(index, howmany,item1,...itemx)·index参数：必须，整数规定添加或删除的位置，使用负数，从数组尾部规定位置·howmany参数：必须，要删除的数量，·item1..itemx:可选，向数组添加新项目3.map()：会返回一个全新的数组。使用于改变数据值的时候。会分配内存存储空间数组并返回，forEach（）不会返回数据4.forEach(): 不会返回任何有价值的东西，并且不打算改变数据，单纯的只是想用数据做一些事情，他允许callback更改原始数组的元素5.reduce(): 方法接收一个函数作为累加器，数组中的每一个值（从左到右）开始缩减，最终计算一个值，不会改变原数组的值6.filter(): 方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。它里面通过function去做处理复制代码</span><br></pre></td></tr></table></figure><h1 id="VUE问题"><a href="#VUE问题" class="headerlink" title="VUE问题"></a>VUE问题</h1><h4 id="1-聊聊对vue的理解"><a href="#1-聊聊对vue的理解" class="headerlink" title="1.聊聊对vue的理解"></a>1.聊聊对vue的理解</h4><blockquote><p>vue是一个渐进式的JS框架。他易用，灵活，高效； 可以把一个页面分隔成多个组件；当其他页面有类似功能时，直接让封装的组件进行复用； 他是构建用户界面的声明式框架，只关心图层；不关心具体是如何实现的</p></blockquote><h4 id="2-V-model的原理是什么？"><a href="#2-V-model的原理是什么？" class="headerlink" title="2.V-model的原理是什么？"></a>2.V-model的原理是什么？</h4><blockquote><p>Vue的双向数据绑定是由数据劫持结合发布者订阅者实现的。 数据劫持是通过Object.defineProperty()来劫持对象数据的setter和getter操作。 在数据变动时作你想做的事</p><ul><li>原理 通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化-&gt;视图更新 在初始化vue实例时，遍历data这个对象，给每一个键值对利用Object.definedProperty对data的键值对新增get和set方法，利用了事件监听DOM的机制，让视图去改变数据</li></ul></blockquote><h4 id="3-谈谈对生命周期的理解"><a href="#3-谈谈对生命周期的理解" class="headerlink" title="3.谈谈对生命周期的理解"></a>3.谈谈对生命周期的理解</h4><ul><li>beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。</li><li>created阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有</li><li>beforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点</li><li>mounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点</li><li>beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</li><li>updated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环</li><li>beforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件</li><li>destroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁</li></ul><h4 id="4-VUE和REACT有什么区别？"><a href="#4-VUE和REACT有什么区别？" class="headerlink" title="4.VUE和REACT有什么区别？"></a>4.VUE和REACT有什么区别？</h4><blockquote><p>react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；</p></blockquote><blockquote><p>vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。</p></blockquote><h4 id="5-vuex的流程"><a href="#5-vuex的流程" class="headerlink" title="5.vuex的流程"></a>5.vuex的流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">页面通过mapAction异步提交事件到action。action通过commit把对应参数同步提交到mutation。mutation会修改state中对于的值。 最后通过getter把对应值跑出去，在页面的计算属性中通过mapGetter来动态获取state中的值复制代码</span><br></pre></td></tr></table></figure><h4 id="6-vuex有哪几种状态和属性"><a href="#6-vuex有哪几种状态和属性" class="headerlink" title="6.vuex有哪几种状态和属性"></a>6.vuex有哪几种状态和属性</h4><blockquote><ul><li>state中保存着共有数据，数据是响应式的</li><li>getter可以对state进行计算操作，主要用来过滤一些数据，可以在多组件之间复用</li><li>mutations定义的方法动态修改state中的数据，通过commit提交方法，方法必须是同步的</li><li>actions将mutations里面处理数据的方法变成异步的，就是异步操作数据，通store.dispatch来分发actions，把异步的方法写在actions中，通过commit提交mutations，进行修改数据。</li><li>modules：模块化vuex</li></ul></blockquote><h4 id="7-vue路由的两种模式"><a href="#7-vue路由的两种模式" class="headerlink" title="7.vue路由的两种模式"></a>7.vue路由的两种模式</h4><blockquote><ul><li>hash ——即地址栏URL中的#符号（此hsah 不是密码学里的散列运算） hash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。</li><li>history ——利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法</li></ul><p>这两个方法应用于浏览器的历史记录站，在当前已有的back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改是，虽然改变了当前的URL，但你浏览器不会立即向后端发送请求。</p></blockquote><h4 id="8-vue中-key-值的作用"><a href="#8-vue中-key-值的作用" class="headerlink" title="8.vue中 key 值的作用"></a>8.vue中 key 值的作用</h4><blockquote><p>当 Vue.js 用v-for正在更新已渲染过的元素列表时，它默认用“就地复用”策略。 如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p></blockquote><blockquote><p>key的作用主要是为了高效的更新虚拟DOM。</p></blockquote><h4 id="9-route和-router的区别"><a href="#9-route和-router的区别" class="headerlink" title="9$route和$router的区别"></a>9<code>$route</code>和<code>$router</code>的区别</h4><blockquote><ul><li>$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。</li><li>$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li></ul></blockquote><h4 id="10-vue-router守卫"><a href="#10-vue-router守卫" class="headerlink" title="10.vue-router守卫"></a>10.vue-router守卫</h4><blockquote><ul><li>导航守卫 router.beforeEach 全局前置守卫</li></ul></blockquote><ul><li>to: Route: 即将要进入的目标（路由对象）</li><li>from: Route: 当前导航正要离开的路由</li><li>next: Function: 一定要调用该方法来 resolve 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截） 执行效果依赖 next 方法的调用参数。</li><li>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</li><li>next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// main.js 入口文件    import router from &#x27;./router&#x27;; // 引入路由    router.beforeEach((to, from, next) =&gt; &#123;       next();    &#125;);    router.beforeResolve((to, from, next) =&gt; &#123;      next();    &#125;);    router.afterEach((to, from) =&gt; &#123;      console.log(&#x27;afterEach 全局后置钩子&#x27;);    &#125;);复制代码</span><br></pre></td></tr></table></figure><p>路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;  routes: [    &#123;      path: &#x27;/foo&#x27;,      component: Foo,      beforeEnter: (to, from, next) =&gt; &#123;        // ...      &#125;    &#125;  ]&#125;)复制代码</span><br></pre></td></tr></table></figure><p>组件内的守卫 你可以在路由组件内直接定义以下路由导航守卫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Foo = &#123;  template: `...`,  beforeRouteEnter (to, from, next) &#123;    // 在渲染该组件的对应路由被 confirm 前调用    // 不！能！获取组件实例 `this`    // 因为当守卫执行前，组件实例还没被创建  &#125;,  beforeRouteUpdate (to, from, next) &#123;    // 在当前路由改变，但是该组件被复用时调用    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。    // 可以访问组件实例 `this`  &#125;,  beforeRouteLeave (to, from, next) &#123;    // 导航离开该组件的对应路由时调用，我们用它来禁止用户离开    // 可以访问组件实例 `this`    // 比如还未保存草稿，或者在用户离开前，    将setInterval销毁，防止离开之后，定时器还在调用。  &#125;&#125;复制代码</span><br></pre></td></tr></table></figure><h4 id="11-axios是什么？怎么使用？描述使用它实现登录功能的流程？"><a href="#11-axios是什么？怎么使用？描述使用它实现登录功能的流程？" class="headerlink" title="11.axios是什么？怎么使用？描述使用它实现登录功能的流程？"></a>11.axios是什么？怎么使用？描述使用它实现登录功能的流程？</h4><blockquote><p>请求后台资源的模块。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install axios -S装好复制代码</span><br></pre></td></tr></table></figure><blockquote><p>然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。 js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中</p></blockquote><h4 id="12-vue修饰符"><a href="#12-vue修饰符" class="headerlink" title="12.vue修饰符"></a>12.vue修饰符</h4><ul><li>stop：阻止事件的冒泡</li><li>prevent：阻止事件的默认行为</li><li>once：只触发一次</li><li>self：只触发自己的事件行为时，才会执行</li></ul><h4 id="13-vue项目中的性能优化"><a href="#13-vue项目中的性能优化" class="headerlink" title="13.vue项目中的性能优化"></a>13.vue项目中的性能优化</h4><blockquote><p>1.不要在模板里面写过多表达式</p></blockquote><blockquote><p>2.循环调用子组件时添加key</p></blockquote><blockquote><p>3.频繁切换的使用v-show，不频繁切换的使用v-if</p></blockquote><blockquote><p>4.尽量少用float，可以用flex</p></blockquote><blockquote><p>5.按需加载，可以用require或者import()按需加载需要的组件</p></blockquote><blockquote><p>6.路由懒加载</p></blockquote><h4 id="14-vue-extend和vue-component"><a href="#14-vue-extend和vue-component" class="headerlink" title="14.vue.extend和vue.component"></a>14.vue.extend和vue.component</h4><blockquote><ul><li>extend 是构造一个组件的语法器。 然后这个组件你可以作用到Vue.component这个全局注册方法里 还可以在任意vue模板里使用组件。 也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件。</li><li>Vue.component 你可以创建 ，也可以取组件。</li></ul></blockquote><h3 id="常见的兼容问题"><a href="#常见的兼容问题" class="headerlink" title="常见的兼容问题"></a>常见的兼容问题</h3><blockquote><p>png24位的图片在iE6浏览器上出现背景 解决方案是做成PNG8.也可以引用一段脚本处理.</p></blockquote><blockquote><p>浏览器默认的margin和padding不同。 解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p></blockquote><blockquote><p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p></blockquote><blockquote><p>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;}</p></blockquote><h1 id="React问题"><a href="#React问题" class="headerlink" title="React问题"></a>React问题</h1><h4 id="1-react和vue的区别"><a href="#1-react和vue的区别" class="headerlink" title="1.react和vue的区别"></a>1.react和vue的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt;  相同点：1.数据驱动页面，提供响应式的试图组件2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范3.数据流动单向，都支持服务器的渲染SSR4.都有支持native的方法，react有React native， vue有wexx=&gt;  不同点：1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的2.数据渲染：大规模的数据渲染，react更快3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目4.开发风格：react推荐做法jsx + inline style把html和css都写在js了    vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件复制代码</span><br></pre></td></tr></table></figure><h4 id="2-redux中的reducer（纯函数）"><a href="#2-redux中的reducer（纯函数）" class="headerlink" title="2.redux中的reducer（纯函数）"></a>2.redux中的reducer（纯函数）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current action）更新state(这个state可以理解为上下累加器的结果）每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是&#x27;自身消减&#x27;(reduce),进而返回最新的state,这也就是典型reduce函数的用法：state -&gt;  action -&gt;  state复制代码</span><br></pre></td></tr></table></figure><h4 id="3-react的refs"><a href="#3-react的refs" class="headerlink" title="3.react的refs"></a>3.react的refs</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">refs就想一个逃生窗，允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函数，它将接受地城dom元素或组件的已挂在实例，作为第一个参数复制代码</span><br></pre></td></tr></table></figure><h4 id="4-react中的keys"><a href="#4-react中的keys" class="headerlink" title="4.react中的keys"></a>4.react中的keys</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">帮组我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去定位元素，并且操作它复制代码</span><br></pre></td></tr></table></figure><h4 id="5-React的生命周期"><a href="#5-React的生命周期" class="headerlink" title="5.React的生命周期"></a>5.React的生命周期</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三个状态：Mounting(已插入真实的DOM）  Updating(正在被重新渲染)  Unmounting(已移除真实的DOM)componentDIdMount 在第一次渲染后调用，只在客服端。之后组件已经生成对应的DOM结构，componentDidUpdate 在组件完成更新后立即调用，在出初始化是不会调用复制代码</span><br></pre></td></tr></table></figure><h4 id="6-React子组件向父组件传值"><a href="#6-React子组件向父组件传值" class="headerlink" title="6.React子组件向父组件传值"></a>6.React子组件向父组件传值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数据。复制代码</span><br></pre></td></tr></table></figure><h4 id="7-为什么虚拟DOM会提高性能-www-zhihu-com-question-29…"><a href="#7-为什么虚拟DOM会提高性能-www-zhihu-com-question-29…" class="headerlink" title="7.为什么虚拟DOM会提高性能 www.zhihu.com/question/29…"></a>7.为什么虚拟DOM会提高性能 <a href="https://link.juejin.cn/?target=https://www.zhihu.com/question/29504639?sort=created">www.zhihu.com/question/29…</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的doom操作，从而提高性能具体实现步骤：·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档中        ·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。复制代码</span><br></pre></td></tr></table></figure><h4 id="8-diff算法"><a href="#8-diff算法" class="headerlink" title="8.diff算法"></a>8.diff算法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.把树形结构按照层级分解，只比较同级元素2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个标记3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就记录到一个对象里面Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进行使用react只会匹配相同的class的component（这里的class指的是组件的名字）合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借宿，React检查所有标记dirty的component重新绘制4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能复制代码</span><br></pre></td></tr></table></figure><h4 id="9-简述下flux的思想"><a href="#9-简述下flux的思想" class="headerlink" title="9.简述下flux的思想"></a>9.简述下flux的思想</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flux的最大特点，就是数据的‘单向流动’1.用户访问View2.View发出用户的Action3.Dispatcher收到Action,要求state进行相应的更新4.store更新后，发出一个‘change’事件后，更新页面复制代码</span><br></pre></td></tr></table></figure><h4 id="10-reac性能优化是哪个周期函"><a href="#10-reac性能优化是哪个周期函" class="headerlink" title="10.reac性能优化是哪个周期函"></a>10.reac性能优化是哪个周期函</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的描绘非常消耗性能，如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能复制代码</span><br></pre></td></tr></table></figure><h4 id="11-react怎么划分业务组件和技术组件"><a href="#11-react怎么划分业务组件和技术组件" class="headerlink" title="11.react怎么划分业务组件和技术组件"></a>11.react怎么划分业务组件和技术组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据组件的职责通常把组件分为UI组件和容器组件UI组件负责UI的呈现，容器组件负责管理数据和逻辑两者通过React-redux提供connect方法联系起来复制代码</span><br></pre></td></tr></table></figure><h4 id="12-setState"><a href="#12-setState" class="headerlink" title="12.setState"></a>12.setState</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状态队列而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改this.state的值那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略之前修改的state，造成不可预知的错误同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state同步更新state:setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible 有可能先于数据渲染完毕就执行。第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执行也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步例子：componentDidMount() &#123;fetch(&#x27;https://test.com&#x27;)    .then((res) =&gt; res.json())    .then(    (data) =&gt; &#123;this.setState(&#123; data:data &#125;);StatusBar.setNetworkActivityIndicatorVisible(false);        &#125;复制代码</span><br></pre></td></tr></table></figure><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h4 id="一、webpack打包文件体积过大？（最终打包为一个js文件）"><a href="#一、webpack打包文件体积过大？（最终打包为一个js文件）" class="headerlink" title="一、webpack打包文件体积过大？（最终打包为一个js文件）"></a>一、webpack打包文件体积过大？（最终打包为一个js文件）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.异步加载模块2.提取第三库3.代码压缩4.去除不必要的插件复制代码</span><br></pre></td></tr></table></figure><h4 id="二、如何优化webpack构建的性能"><a href="#二、如何优化webpack构建的性能" class="headerlink" title="二、如何优化webpack构建的性能"></a>二、如何优化webpack构建的性能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一、减少代码体积 1.使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积 2.把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理 3.对一些组件库采用按需加载，避免无用的代码二、减少目录检索范围 ·在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度三、减少检索路经：resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias复制代码</span><br></pre></td></tr></table></figure><h4 id="三、移动端的性能优化"><a href="#三、移动端的性能优化" class="headerlink" title="三、移动端的性能优化"></a>三、移动端的性能优化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、首屏加载和按需加载，懒加载  2、资源预加载  3、图片压缩处理，使用base64内嵌图片  4、合理缓存dom对象  5、使用touchstart代替click（click 300毫秒的延迟）  6、利用transform:translateZ(0)，开启硬件GUP加速  7、不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明  8、使用viewport固定屏幕渲染，加速页面渲染内容  9、尽量使用事件代理，避免直接事件绑定复制代码</span><br></pre></td></tr></table></figure><h4 id="四、Vue的SPA-如何优化加载速度"><a href="#四、Vue的SPA-如何优化加载速度" class="headerlink" title="四、Vue的SPA 如何优化加载速度"></a>四、Vue的SPA 如何优化加载速度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.减少入口文件体积2.静态资源本地缓存3.开启Gzip压缩4.使用SSR,nuxt.js复制代码</span><br></pre></td></tr></table></figure><h4 id="五、移动端300ms延迟"><a href="#五、移动端300ms延迟" class="headerlink" title="五、移动端300ms延迟"></a>五、移动端300ms延迟</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由来：300毫米延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放值原始比例。由于用户可以双击缩放或者是滚动的操作，当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作因此，safair浏览器就会等待300ms，用来判断用户是否在次点击了屏幕       解决方案：1.禁用缩放，设置meta标签 user-scalable=no  2.fastclick.js原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即      发出click事件，并把浏览器在300ms之后真正的click事件阻止掉fastclick.js还可以解决穿透问题复制代码</span><br></pre></td></tr></table></figure><h4 id="六、页面的重构；"><a href="#六、页面的重构；" class="headerlink" title="六、页面的重构；"></a>六、页面的重构；</h4><blockquote><p>在不改变外部行为的前提下，简化结构、添加可读性</p></blockquote><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><h4 id="一、状态码："><a href="#一、状态码：" class="headerlink" title="一、状态码："></a>一、状态码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2XX（成功处理了请求状态）      200 服务器已经成功处理请求，并提供了请求的网页      201 用户新建或修改数据成功      202 一个请求已经进入后台      204 用户删除成功  3XX（每次请求使用的重定向不要超过5次）      304 网页上次请求没有更新，节省带宽和开销  4XX（表示请求可能出错，妨碍了服务器的处理）      400 服务器不理解请求的语法      401 用户没有权限（用户名，密码输入错误）      403 用户得到授权（401相反），但是访问被禁止      404 服务器找不到请求的网页，  5XX（表示服务器在处理请求的时候发生内部错误）      500 服务器遇到错误，无法完成请求      503 服务器目前无法使用（超载或停机维护）     复制代码</span><br></pre></td></tr></table></figure><h4 id="二、304的缓存原理（添加Etag标签-last-modified）-304-网页上次请求没有更新，节省带宽和开销"><a href="#二、304的缓存原理（添加Etag标签-last-modified）-304-网页上次请求没有更新，节省带宽和开销" class="headerlink" title="二、304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销"></a>二、304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.服务器首先产生Etag,服务器可在稍后使用它来判断页面是否被修改。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）2.304是HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去去找浏览器缓存的文件3.流程：客户端请求一个页面A。服务器返回页面A，并在A上加一个Tage客服端渲染该页面，并把Tage也存储在缓存中。客户端再次请求页面A并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该页面自上次客户端请求之后未被修改。直接返回304last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最后修改的时间客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-Modified-Since报头，询问该事件之后文件是否被修改，没修改返回304 有了Last-Modified，为什么还要用ETag？  1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—Modified不能识别秒单位的修改）  2、某些服务器不能精确的得到文件的最后修改时间  3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新GetETag，为什么还要用Last-Modified？  1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改  2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）  1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。复制代码</span><br></pre></td></tr></table></figure><h4 id="三、get-post的区别"><a href="#三、get-post的区别" class="headerlink" title="三、get/post的区别"></a>三、get/post的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&amp;相连； post方法是把提交的数据放在http包的Body中2.get提交的数据大小有限制，（因为浏览器对url的长度有限制），post的方法提交的数据没有限制3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量的值4.get的方法提交数据，会带来安全问题，比如登录一个页面，通过get的方式提交数据，用户名和密码就会出现在url上复制代码</span><br></pre></td></tr></table></figure><h4 id="四、http协议的理解"><a href="#四、http协议的理解" class="headerlink" title="四、http协议的理解"></a>四、http协议的理解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议2.基于TCP/IP通信协议来传递数据（HTML，图片资源）3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统4.http请求信息request：请求行（request line）、请求头部（header）,空行和请求数据四部分构成请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.请求头部，用来说明服务器要使用的附加信息空行，请求头部后面的空行是必须的请求数据也叫主体，可以添加任意的其他数据。5.http相应信息Response状态行、消息报头、空行和响应正文状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成消息报头，用来说明客户端要使用的一些附加信息空行，消息报头后面的空行是必须的响应正文，服务器返回给客户端的文本信息。复制代码</span><br></pre></td></tr></table></figure><h4 id="五、http和https"><a href="#五、http和https" class="headerlink" title="五、http和https"></a>五、http和https</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密http：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少复制代码</span><br></pre></td></tr></table></figure><h4 id="六、http1-0-1-1-2-0的区别"><a href="#六、http1-0-1-1-2-0的区别" class="headerlink" title="六、http1.0 1.1 2.0的区别"></a>六、http1.0 1.1 2.0的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量3.多路复用：一个连接可以并发处理多个请求4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源复制代码</span><br></pre></td></tr></table></figure><h4 id="七、web缓存"><a href="#七、web缓存" class="headerlink" title="七、web缓存"></a>七、web缓存</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本2.缓存的好处        （1）减少不必要的请求    （2）降低服务器的压力，减少服务器的消耗    （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）复制代码</span><br></pre></td></tr></table></figure><h4 id="八、常见的web安全及防护原理"><a href="#八、常见的web安全及防护原理" class="headerlink" title="八、常见的web安全及防护原理"></a>八、常见的web安全及防护原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。也就是说，            在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作时，会拼接对应参数，            同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。防范：1.对用户输入进行校验       2.不适用动态拼接sql2.XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。        举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息防范：1.尽量采用post而不使用get提交表单      2.避免cookie中泄漏用户的隐式3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求举例子：黄轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来获取QQ音乐的数据防范：在客服端页面增加伪随机数，通过验证码XSS和CSRF的区别：   1.XSS是获取信息，不需要提前知道其他用户页面的代码和数据包   2.CSRF代替用户完成指定的动作，需要知道其他页面的代码和数据包复制代码</span><br></pre></td></tr></table></figure><h4 id="九、CDN（内容分发网络）"><a href="#九、CDN（内容分发网络）" class="headerlink" title="九、CDN（内容分发网络）"></a>九、CDN（内容分发网络）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。2.关键技术：内容存储和分发技术中3.基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术    将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）复制代码</span><br></pre></td></tr></table></figure><h4 id="十、TCP三次握手-客服端和服务器端都需要确认各自可收发）"><a href="#十、TCP三次握手-客服端和服务器端都需要确认各自可收发）" class="headerlink" title="十、TCP三次握手    (客服端和服务器端都需要确认各自可收发）"></a>十、TCP三次握手    (客服端和服务器端都需要确认各自可收发）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客服端发c起请求连接服务器端s确认，服务器端也发起连接确认客服端确认。第一次握手：客服端发送一个请求连接，服务器端只能确认自己可以接受客服端发送的报文段第二次握手： 服务端向客服端发送一个链接，确认客服端收到自己发送的报文段第三次握手： 服务器端确认客服端收到了自己发送的报文段复制代码</span><br></pre></td></tr></table></figure><h4 id="十一、从输入url到获取页面的完整过程-blog-csdn-net-samjustin1-…"><a href="#十一、从输入url到获取页面的完整过程-blog-csdn-net-samjustin1-…" class="headerlink" title="十一、从输入url到获取页面的完整过程  blog.csdn.net/samjustin1/…"></a>十一、从输入url到获取页面的完整过程  <a href="https://link.juejin.cn/?target=https://blog.csdn.net/samjustin1/article/details/52650520">blog.csdn.net/samjustin1/…</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.查询NDS(域名解析),获取域名对应的IP地址  查询浏览器缓存2.浏览器与服务器建立tcp链接（三次握手）3.浏览器向服务器发送http请求(请求和传输数据）4.服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器5.浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js，图片一样的步骤6.浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来复制代码</span><br></pre></td></tr></table></figure><h4 id="十二、浏览器渲染原理及流程-DOM-gt-CSSOM-gt-render-gt-layout-gt-print"><a href="#十二、浏览器渲染原理及流程-DOM-gt-CSSOM-gt-render-gt-layout-gt-print" class="headerlink" title="十二、浏览器渲染原理及流程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print"></a>十二、浏览器渲染原理及流程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">流程：解析html以及构建dom树 -&gt; 构建render树 -&gt;  布局render树 -&gt; 绘制render树概念：1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树      2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）      3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置      4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点重绘：当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上触发重绘的条件：改变元素外观属性。如：color，background-color等重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观注意：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多发时间，要尽量避免使用table布局重排（重构/回流/reflow）： 当渲染书中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。每个页面都需要一次回流，就是页面第一次渲染的时候重排一定会影响重绘，但是重绘不一定会影响重排复制代码</span><br></pre></td></tr></table></figure><h4 id="十三、为什么css放在顶部而js写在后面"><a href="#十三、为什么css放在顶部而js写在后面" class="headerlink" title="十三、为什么css放在顶部而js写在后面"></a>十三、为什么css放在顶部而js写在后面</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了2.其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面复制代码</span><br></pre></td></tr></table></figure><h4 id="十四、存储方式与传输方式"><a href="#十四、存储方式与传输方式" class="headerlink" title="十四、存储方式与传输方式"></a>十四、存储方式与传输方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.indexBD: 是h5的本地存储库，把一些数据存储到浏览器中，没网络，浏览器可以从这里读取数据，离线运用。5m2.Cookie: 通过浏览器记录信息确认用户身份，最大4kb,这也就限制了传输的数据，请求的性能会受到影响3.Session: 服务器端使用的一种记录客户状态的机制（session_id存在set_cookie发送到客服端，保存为cookie）4.localStroage: h5的本地存储，数据永久保存在客服端复制代码</span><br></pre></td></tr></table></figure><h4 id="cookie，sessionStorage，localStorage"><a href="#cookie，sessionStorage，localStorage" class="headerlink" title="cookie，sessionStorage，localStorage"></a>cookie，sessionStorage，localStorage</h4><p>1、cookie，sessionStorage，localStorage是存放在客户端，session对象数据是存放在服务器上 实际上浏览器和服务器之间仅需传递session id即可，服务器根据session-id找到对应的用户session对象 session存储数据更安全一些，一般存放用户信息，浏览器只适合存储一般的数据 2、cookie数据始终在同源的http请求中携带，在浏览器和服务器来回传递，里面存放着session-id sessionStorage，localStorage仅在本地保存 3、大小限制区别，cookie数据不超过4kb，localStorage在谷歌浏览中2.6MB 4、数据有效期不同，cookie在设置的（服务器设置）有效期内有效，不管窗口和浏览器关闭 sessionStorage仅在当前浏览器窗口关闭前有效，关闭即销毁（临时存储） localStorage始终有效</p><p>SessionStorage和localStorage区别： 1.sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在用一个会话的页面中才能被访问（也就是说在第一次通信过程中） 并且在会话结束后数据也随之销毁，不是一个持久的本地存储，会话级别的储存 2.localStorage用于持久化的本地存储，除非主动删除数据，否则不会过期</p><h4 id="token、cookie、session三者的理解？？？！！！"><a href="#token、cookie、session三者的理解？？？！！！" class="headerlink" title="token、cookie、session三者的理解？？？！！！"></a>token、cookie、session三者的理解？？？！！！</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件（最好的身份认证，安全性好，且是唯一的）    用户身份的验证方式    2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名    服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信息）3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的就是服务器和客户端的一次会话过程）    cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。复制代码</span><br></pre></td></tr></table></figure><h4 id="基于Token的身份验证：（最简单的token-uid用户唯一的身份识别-time当前事件戳-sign签名）"><a href="#基于Token的身份验证：（最简单的token-uid用户唯一的身份识别-time当前事件戳-sign签名）" class="headerlink" title="基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前事件戳 + sign签名）"></a>基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前事件戳 + sign签名）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、用户通过用户名和密码发送请求  2、服务器端验证  3、服务器端返回一个带签名的token，给客户端  4、客户端储存token，并且每次用于发送请求  5、服务器验证token并且返回数据  每一次请求都需要token复制代码</span><br></pre></td></tr></table></figure><h4 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、cookie数据存放在客户的浏览器上，session数据放在服务器上。  2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。  3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。  4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。复制代码</span><br></pre></td></tr></table></figure><h4 id="session与token区别"><a href="#session与token区别" class="headerlink" title="session与token区别"></a>session与token区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认证手段。只存在服务端，不能共享到其他的网站和第三方App  2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的就是让某APP有权访问某用户的的信息。Token是唯一的，     token不能转移到其他的App，也不能转到其他用户上。（适用于App）  3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客户端的复制代码</span><br></pre></td></tr></table></figure><h4 id="Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）"><a href="#Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）" class="headerlink" title="Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）"></a>Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、数量和长度的限制。每个特定的域名下最多生成20个cookie（chorme和safari没有限制）  2、安全性问题。复制代码</span><br></pre></td></tr></table></figure><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote><p>一、观察者模式：<a href="https://juejin.cn/post/6844903513009422343">juejin.cn/post/684490…</a>   <a href="https://juejin.cn/post/6844903603107266567">juejin.cn/post/684490…</a> 在软件开发设计中是一个对象(subject)，维护一系列依赖他的对象（observer），当任何状态发生改变自动通知他们。强依赖关系 简单理解：数据发生改变时，对应的处理函数就会自动执行。一个Subjet,用来维护Observers,为某些event来通知（notify）观察者</p></blockquote><blockquote><p>二、发布-订阅者  有一个信息中介，过滤 耦合性低 它定义了一种一对多的关系，可以使多个观察者对象对一个主题对象进行监听，当这个主题对象发生改变时，依赖的所有对象都会被通知到。</p></blockquote><ul><li>-两者的区别： 1.观察者模式中，观察者知道Subject ,两者是相关联的，而发发布订阅者只有通过信息代理进行通信 2.在发布订阅模式中，组件式松散耦合的。正好和观察者模式相反。 3.观察者大部分是同步的，比如事件的触发。Subject就会调用观察者的方法。而发布订阅者大多数是异步的（） 4.观察者模式需要在单个应用程序地址空间中实现，而发布订阅者更像交叉应用模式。</li></ul><h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h4 id="一、两个栈实现一个队列，两个队列实现一个栈-www-cnblogs-com-MrListening…"><a href="#一、两个栈实现一个队列，两个队列实现一个栈-www-cnblogs-com-MrListening…" class="headerlink" title="一、两个栈实现一个队列，两个队列实现一个栈 www.cnblogs.com/MrListening…"></a>一、两个栈实现一个队列，两个队列实现一个栈 <a href="https://link.juejin.cn/?target=https://www.cnblogs.com/MrListening/p/5697459.html">www.cnblogs.com/MrListening…</a></h4><h4 id="二、红黑树（解决二叉树依次插入多个节点时的线型排列）-juejin-cn-post-684490…"><a href="#二、红黑树（解决二叉树依次插入多个节点时的线型排列）-juejin-cn-post-684490…" class="headerlink" title="二、红黑树（解决二叉树依次插入多个节点时的线型排列） juejin.cn/post/684490…"></a>二、红黑树（解决二叉树依次插入多个节点时的线型排列） <a href="https://juejin.cn/post/6844903519632228365">juejin.cn/post/684490…</a></h4><h4 id="三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin-cn-post-684490…"><a href="#三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin-cn-post-684490…" class="headerlink" title="三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin.cn/post/684490…"></a>三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）<a href="https://juejin.cn/post/6844903521280589831">juejin.cn/post/684490…</a></h4><h4 id="四、十大排序"><a href="#四、十大排序" class="headerlink" title="四、十大排序"></a>四、十大排序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.冒泡排序：重复走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把它们交换过来。  实现过程：1.比较相邻的元素。如果第一个比第二个大，就交换他们两个    2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数    3.针对所有的元素重复以上的步骤，除了最后一个    4.重复步骤1-3，直到排序完成。2.选择排序：首先在未排序序列中找到最小值，放在排序序列的起始位置，然后，在从剩下未排序元素中继续寻找最小值，然后放在与排序序列的末尾  实现过程：3.插入排序：构建有序序列，对于未排序数据，在已排序序列中冲后向前扫描，找到相应位置并插入  实现过程：1.从第一个元素开始，该元素可以认为已经被排序    2.取出下一个元素，在已排序的元素序列中冲后向前扫描    3.如果该元素（以排序）大于新元素，将元素向后移一位    4.在取出一个元素，比较之前的，直到找到自己合适的位置4.桶排序：将数据分布到有限数量的桶里，每个桶在分别排序1.快速排序：快速排序使用分治法把一个串（list）分为两个子串（sub-lists）.具体算法实现  实现过程：1.从数组中挑出一个元素，成为一个基准    2.重新排列数组，所有元素比基准小的摆在基准前面，所有元素比基准大的摆在基准后面（相同的可以摆在一边）这个分区退出之后，该基准就处于数列的中间位置。成为分区操作。    3.递归的把小于基准值的子数列和大于基准值元素的子数列排序算法实现： function quickSort (arr) &#123;if （arr.length &lt;= 1） &#123;return arr&#125;var destIndex = Math.floor(arr.length/2)var left = [], right = [];var dest = arr.splice(destIndex,1)[0];for (var i =0;i&lt;arr.length;i++)&#123;if (arr[i]&lt;dest) &#123;left.push(arr[i])&#125; else &#123;right.push(arr[i]) &#125;return quickSort(left).concat([dest],quickSort(right)2.堆排序：利用对这种数据结构所涉及的一种排序算法，堆积是一个近乎完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或大于）它的父节点。  实现过程：1.复制代码</span><br></pre></td></tr></table></figure><h4 id="五、数组去重-juejin-cn-post-684490…"><a href="#五、数组去重-juejin-cn-post-684490…" class="headerlink" title="五、数组去重 juejin.cn/post/684490…"></a>五、数组去重 <a href="https://juejin.cn/post/6844903602197102605#heading-6">juejin.cn/post/684490…</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.双重循环2.indexOf3.数组排序去重 最快你Olong复制代码</span><br></pre></td></tr></table></figure><h4 id="六、字符串"><a href="#六、字符串" class="headerlink" title="六、字符串"></a>六、字符串</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断回文字符串：（递归的思想）1.字符串分隔，倒转，聚合[...obj].reverse().join(&#x27;&#x27;)2.字符串头部和尾部，逐次向中间检测 实现：function isPalindrome(line) &#123;line += &#x27;&#x27;;for (var i=0,j=line.length-1;i&lt;j;i++,j--) &#123;if (line.chartAt(i) !== line.chartAt(j) &#123;return false&#125;3.递归复制代码</span><br></pre></td></tr></table></figure><h4 id="七、二分查找（有序数组的查找）"><a href="#七、二分查找（有序数组的查找）" class="headerlink" title="七、二分查找（有序数组的查找）"></a>七、二分查找（有序数组的查找）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二分查找可以解决已排序数组的查找问题，即只要数组中包含T(要查找的值)，那么通过不断的缩小包含T的数据范围，就可以最终要找到的数 (1) 一开始,数据范围覆盖整个数组。 (2) 将数组的中间项与T进行比较，如果T比数组的中间项小，则到数组的前半部分继续查找，反之，则到数组的后半部分继续查找。 (3) 就这样，每次查找都可以排除一半元素，相当于范围缩小一半。这样反复比较，反复缩小范围，最终会在数组中找到T代码实现：function binarySearch (data, dest, start, end)&#123;var end = end || data.length-1;var start = start || 0;var m = Math.floor((start+end)/2);if (dest&lt;data[m])&#123;return binarySearch(data, dest, 0, m-1)&#125; else &#123;return binarySearch(data, dest, m+1, end)&#125;&#125;return false复制代码</span><br></pre></td></tr></table></figure><h1 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h1><h4 id="一、动手实现一个bind（原理通过apply，call）"><a href="#一、动手实现一个bind（原理通过apply，call）" class="headerlink" title="一、动手实现一个bind（原理通过apply，call）"></a>一、动手实现一个bind（原理通过apply，call）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一句话概括：1.bind()返回一个新函数，并不会立即执行。    2.bind的第一个参数将作为他运行时的this，之后的一系列参数将会在传递的实参前传入作为他的参数    3.bind返回函数作为构造函数，就是可以new的，bind时指定的this值就会消失，但传入的参数依然生效复制代码Function.prototype.bind = function (obj, arg) &#123;   var arg = Array.prototype.slice.call(arguments, 1);   var context = this;   var bound = function (newArg) &#123;   arg = arg.concat(Array.prototype.slice.call(newArg);   return context.apply(obj, arg)&#125;  var F =  function () &#123;&#125;  // 在new一个bind会生成新函数，必须的条件就是要继承原函数的原型，因此用到寄生继承来完成我们的过程  F.prototype = context.prototype;  bound.prototype =  new F();  return bound;&#125;复制代码</span><br></pre></td></tr></table></figure><h4 id="二、-AJAX-（异步的javascript和xml）"><a href="#二、-AJAX-（异步的javascript和xml）" class="headerlink" title="二、 AJAX （异步的javascript和xml）"></a>二、 AJAX （异步的javascript和xml）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">ajax的原理：相当于在用户和服务器之间加一个中间层（ajax引擎),使用户操作与服务器响应异步化。</span><br><span class="line">优点：在不刷新整个页面的前提下与服务器通信维护数据。不会导致页面的重载</span><br><span class="line">      可以把前端服务器的任务转嫁到客服端来处理，减轻服务器负担，节省宽带</span><br><span class="line">劣势：不支持back。对搜索引擎的支持比较弱；不容易调试</span><br><span class="line">怎么解决呢？通过location.hash值来解决Ajax过程中导致的浏览器前进后退按键失效，</span><br><span class="line">解决以前被人常遇到的重复加载的问题。主要比较前后的hash值，看其是否相等，在判断是否触发ajax</span><br><span class="line">复制代码</span><br><span class="line">function getData(url) &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();  // 创建一个对象，创建一个异步调用的对象</span><br><span class="line">    xhr.open(&#x27;get&#x27;, url, true)  // 设置一个http请求，设置请求的方式，url以及验证身份</span><br><span class="line">    xhr.send() //发送一个http请求</span><br><span class="line">    xhr.onreadystatechange = function () &#123;  //设置一个http请求状态的函数</span><br><span class="line">      if (xhr.readyState == 4 &amp;&amp; xhr.status ==200) &#123;</span><br><span class="line">        console.log(xhr.responseText)  // 获取异步调用返回的数据</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Promise(getData(url)).resolve(data =&gt; data)</span><br><span class="line"></span><br><span class="line"> AJAX状态码：0 - （未初始化）还没有调用send()方法</span><br><span class="line">     1 - （载入）已调用send方法，正在发送请求</span><br><span class="line">     2 - （载入完成呢）send()方法执行完成</span><br><span class="line">     3 - （交互）正在解析相应内容</span><br><span class="line">     4 - （完成）响应内容解析完成，可以在客户端调用了</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">#### 三、函数节流（throttle）</span><br><span class="line">```</span><br><span class="line"> function throttle (func, wait) &#123;</span><br><span class="line">        var timeout;</span><br><span class="line">        var previous = 0;</span><br><span class="line">        return function () &#123;</span><br><span class="line">            context = this;</span><br><span class="line">            args = arguments;</span><br><span class="line">            if (!timeout) &#123;</span><br><span class="line">                timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">                    timeout = null;</span><br><span class="line">                    func.apply(context,args)</span><br><span class="line">                &#125;, wait);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">#### 四、函数防抖（dobounce）</span><br><span class="line">```</span><br><span class="line"> function debounce (func, wait) &#123;</span><br><span class="line">         var timeout;</span><br><span class="line">         return function() &#123;</span><br><span class="line">             var context = this;</span><br><span class="line">             var args = arguments;</span><br><span class="line">             clearTimeout(timeout);</span><br><span class="line">             timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">                 func.apply(context,args)</span><br><span class="line">             &#125;, wait);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">#### 五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</span><br><span class="line">```    </span><br><span class="line">    Object.prototype.clone = function() &#123;</span><br><span class="line">      var newObject = this.constructor === Array ? [] : &#123;&#125;  //对象的深拷贝 获取对应的构造函数 [] 或者 &#123;&#125;</span><br><span class="line">      for (let e in this) &#123; //遍历对象的属性 in  this[e]</span><br><span class="line">        newObject[e] = typeof this[e] === &#x27;object&#x27; ? this[e].clone() : this[e]  //对象中的属性如果还是对象 那就继续递归 否则就返回基本的数据类型</span><br><span class="line">      &#125;</span><br><span class="line">      return newObject</span><br><span class="line">    &#125;</span><br><span class="line">```</span><br><span class="line"> </span><br><span class="line">#### 六、实现一个简单的Promise https://juejin.cn/post/6844903625769091079</span><br><span class="line">```</span><br><span class="line">class Promise &#123;</span><br><span class="line">  constructor (executor) &#123;   // executor里面有两个参数，一个叫resolve（成功），一个叫reject（失败）。</span><br><span class="line">    this.status = &#x27;pending&#x27;,</span><br><span class="line">    this.value = undefined;</span><br><span class="line">    this.reason = undefined;</span><br><span class="line">    // 成功存放的数组</span><br><span class="line">    this.onResolvedCallbacks = [];</span><br><span class="line">     // 失败存放法数组</span><br><span class="line">     this.onRejectedCallbacks = [];</span><br><span class="line">    let resolve = (value) =&gt; &#123;</span><br><span class="line">      if (this.status == &#x27;pending&#x27;) &#123;</span><br><span class="line">        this.status = &#x27;resolve&#x27;;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.onResolvedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let reject = (reason) =&gt; &#123;</span><br><span class="line">      if (this.status == &#x27;pending&#x27;) &#123;</span><br><span class="line">        this.status = &#x27;reject&#x27;;</span><br><span class="line">        this.reason = reason;</span><br><span class="line">        this.onRejectedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  then (onFullFilled,onRejected) &#123;</span><br><span class="line">    if (this.status == &#x27;resolved&#x27;) &#123;</span><br><span class="line">      onFullFilled(this.value)</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status == &#x27;rejectd&#x27;) &#123;</span><br><span class="line">      onRejected(this.reason);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status == &#x27;pending&#x27;) &#123;</span><br><span class="line">      this.onResolvedCallbacks.push(()=&gt;&#123;</span><br><span class="line">        onFullFilled(this.value);</span><br><span class="line">      &#125;)</span><br><span class="line">      this.onRejectedCallbacks.push(()=&gt; &#123;</span><br><span class="line">          onRejected(this.reason);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(&#x27;hello world&#x27;)</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line">p.then((data) =&gt;&#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;,(err) =&gt;&#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">#### 七、发布订阅者模式（观察者模式）</span><br><span class="line">```</span><br><span class="line">var event = &#123;&#125;; // 发布者</span><br><span class="line">event.clientList = [] //发布者的缓存列表</span><br><span class="line"></span><br><span class="line">event.listen = function (fn) &#123;  // 增加订阅者函数</span><br><span class="line">  this.clientList.push(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.trigger = function () &#123;  // 发布信息</span><br><span class="line">  for (var i =0;i&lt;this.clientList.length;i++) &#123;</span><br><span class="line">    var fn = this.clientList[i];</span><br><span class="line">    fn.apply(this, arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.listen (function(time) &#123;</span><br><span class="line">  console.log(&#x27;正式上班时间为：&#x27; +time)</span><br><span class="line">&#125;)</span><br><span class="line">event.trigger (&#x27;2018/7&#x27;)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">#### 八、手动写一个node服务器</span><br><span class="line">```</span><br><span class="line">const http = require(&#x27;http&#x27;);</span><br><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line">const server = http.createServer((req,res) =&gt; &#123;</span><br><span class="line">if (reu.url == &#x27;/&#x27;) &#123;</span><br><span class="line">const indexFile = fs.createReadStream(&#x27;./index.html&#x27;)</span><br><span class="line">req.writeHead(200,&#123;&#x27;context-Type&#x27;:&#x27;text/html;charset = utf8&#125;)</span><br><span class="line">indexFile.pipe(res)</span><br><span class="line">&#125;</span><br><span class="line">server.listen(8080)</span><br><span class="line">```</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTML </tag>
            
            <tag> Http </tag>
            
            <tag> CSS </tag>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试复习路线</title>
      <link href="/2022/03/01/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2022/03/01/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JavaScript-基础"><a href="#1-JavaScript-基础" class="headerlink" title="1. JavaScript 基础"></a>1. JavaScript 基础</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132109771.png" alt="image-20220301163103625"></p><h2 id="2-CSS-基础"><a href="#2-CSS-基础" class="headerlink" title="2. CSS 基础"></a>2. CSS 基础</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132109578.png" alt="image-20220301162753126"></p><h2 id="3-框架-Vue-为主"><a href="#3-框架-Vue-为主" class="headerlink" title="3. 框架(Vue 为主)"></a>3. 框架(Vue 为主)</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132109505.png" alt="image-20220301162814498"></p><h2 id="4-工程化"><a href="#4-工程化" class="headerlink" title="4. 工程化"></a>4. 工程化</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132109106.png" alt="image-20220301162824681"></p><h2 id="5-性能优化"><a href="#5-性能优化" class="headerlink" title="5.性能优化"></a>5.性能优化</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132109562.png" alt="image-20220301162854191"></p><h2 id="6-TypeScript"><a href="#6-TypeScript" class="headerlink" title="6. TypeScript"></a>6. TypeScript</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132109633.png" alt="image-20220301162905975"></p><h2 id="7-网络"><a href="#7-网络" class="headerlink" title="7. 网络"></a>7. 网络</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132109531.png" alt="image-20220301162917274"></p><h2 id="8-设计模式"><a href="#8-设计模式" class="headerlink" title="8. 设计模式"></a>8. 设计模式</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132109065.png" alt="image-20220301162929421"></p><h2 id="9-数据结构-算法"><a href="#9-数据结构-算法" class="headerlink" title="9. 数据结构/算法"></a>9. 数据结构/算法</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132109602.png" alt="image-20220301162944459"></p><h2 id="10-安全"><a href="#10-安全" class="headerlink" title="10. 安全"></a>10. 安全</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132109601.png" alt="image-20220301162958144"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习路线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript深入之作用域链</title>
      <link href="/2022/03/01/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/2022/03/01/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="https://github.com/mqyqingfeng/Blog/issues/4">《JavaScript深入之执行上下文栈》</a>中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable object，VO)</li><li>作用域链(Scope chain)</li><li>this</li></ul><p>今天重点讲讲作用域链。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>在<a href="https://github.com/mqyqingfeng/Blog/issues/5">《JavaScript深入之变量对象》</a>中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><p>下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。</p><h2 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h2><p>在<a href="https://github.com/mqyqingfeng/Blog/issues/3">《JavaScript深入之词法作用域和动态作用域》</a>中讲到，函数的作用域在函数定义的时候就决定了。</p><p>这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    function bar() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数创建时，各自的[[scope]]为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">    fooContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h2><p>当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。</p><p>这时候执行上下文的作用域链，我们命名为 Scope：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure><p>至此，作用域链创建完毕。</p><h2 id="捋一捋"><a href="#捋一捋" class="headerlink" title="捋一捋"></a>捋一捋</h2><p>以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope2 = &#x27;local scope&#x27;;</span><br><span class="line">    return scope2;</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><p>执行过程如下：</p><p>1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: undefined</span><br><span class="line">    &#125;，</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.第三步：将活动对象压入 checkscope 作用域链顶端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: &#x27;local scope&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 作用域链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>史上最强vue总结---面试开发全靠它了</title>
      <link href="/2022/02/27/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BAvue%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E5%BC%80%E5%8F%91%E5%85%A8%E9%9D%A0%E5%AE%83%E4%BA%86/"/>
      <url>/2022/02/27/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BAvue%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E5%BC%80%E5%8F%91%E5%85%A8%E9%9D%A0%E5%AE%83%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h2 id="vue框架篇"><a href="#vue框架篇" class="headerlink" title="vue框架篇"></a>vue框架篇</h2><h3 id="vue的优点"><a href="#vue的优点" class="headerlink" title="vue的优点"></a>vue的优点</h3><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；</p><p>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</p><p>双向数据绑定：保留了angular的特点，在数据操作方面更为简单；</p><p>组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；</p><p>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p><p>虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；</p><p>运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。</p><h3 id="请详细说下你对vue生命周期的理解？"><a href="#请详细说下你对vue生命周期的理解？" class="headerlink" title="请详细说下你对vue生命周期的理解？"></a>请详细说下你对vue生命周期的理解？</h3><p>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p><blockquote><p>创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el为undefined，还未初始化。</p></blockquote><blockquote><p>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</p></blockquote><blockquote><p>更新前/后：当data变化时，会触发beforeUpdate和updated方法</p></blockquote><blockquote><p>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p></blockquote><h3 id="为什么vue组件中data必须是一个函数？"><a href="#为什么vue组件中data必须是一个函数？" class="headerlink" title="为什么vue组件中data必须是一个函数？"></a>为什么vue组件中data必须是一个函数？</h3><p>对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。</p><h3 id="vue中v-if和v-show有什么区别？"><a href="#vue中v-if和v-show有什么区别？" class="headerlink" title="vue中v-if和v-show有什么区别？"></a>vue中v-if和v-show有什么区别？</h3><p>v-if和v-show看起来似乎差不多，当条件不成立时，其所对应的标签元素都不可见，但是这两个选项是有区别的:</p><p>1、v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大。</p><p>2、v-if是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则v-if不会去渲染标签。v-show则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的CSS切换。</p><h3 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h3><h4 id="计算属性computed："><a href="#计算属性computed：" class="headerlink" title="计算属性computed："></a>计算属性computed：</h4><ul><li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li><li>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</li><li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li><li>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</li></ul><h4 id="侦听属性watch："><a href="#侦听属性watch：" class="headerlink" title="侦听属性watch："></a>侦听属性watch：</h4><ul><li>不支持缓存，数据变，直接会触发相应的操作；</li><li>watch支持异步；</li><li>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li><li>当一个属性发生变化时，需要执行对应的操作；一对多；</li><li>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：</li></ul><blockquote><p>immediate：组件加载立即触发回调函数执行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  firstName: &#123;</span><br><span class="line">    handler(newName, oldName) &#123;</span><br><span class="line">      this.fullName = newName + &#x27; &#x27; + this.lastName;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 代表在wacth里声明了firstName这个方法之后立即执行handler方法</span><br><span class="line">    immediate: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    handler(newName, oldName) &#123;</span><br><span class="line">      console.log(&#x27;obj.a changed&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    immediate: true,</span><br><span class="line">    deep: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>优化：我们可以使用字符串的形式监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  &#x27;obj.a&#x27;: &#123;</span><br><span class="line">    handler(newName, oldName) &#123;</span><br><span class="line">      console.log(&#x27;obj.a changed&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    immediate: true,</span><br><span class="line">    // deep: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数。</p><h3 id="vue-loader是什么？使用它的用途有哪些？"><a href="#vue-loader是什么？使用它的用途有哪些？" class="headerlink" title="vue-loader是什么？使用它的用途有哪些？"></a>vue-loader是什么？使用它的用途有哪些？</h3><p>vue文件的一个加载器，跟template/js/style转换成js模块。</p><h3 id="nextTick是什么？"><a href="#nextTick是什么？" class="headerlink" title="$nextTick是什么？"></a>$nextTick是什么？</h3><p>vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。</p><blockquote><p>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM</p></blockquote><h3 id="v-for-key的作用"><a href="#v-for-key的作用" class="headerlink" title="v-for key的作用"></a>v-for key的作用</h3><p>当Vue用 v-for 正在更新已渲染过的元素列表是，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p><p>为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。key属性的类型只能为 string或者number类型。</p><p>key 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p><h3 id="Vue的双向数据绑定原理是什么？"><a href="#Vue的双向数据绑定原理是什么？" class="headerlink" title="Vue的双向数据绑定原理是什么？"></a>Vue的双向数据绑定原理是什么？</h3><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p><blockquote><p>1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p></blockquote><blockquote><p>2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p></blockquote><blockquote><p>3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p></blockquote><blockquote><p>4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p></blockquote><h3 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h3><h4 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h4><p>通过props传递</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父组件： &lt;child value = &#x27;传递的数据&#x27; /&gt;</span><br><span class="line"></span><br><span class="line">子组件: props[&#x27;value&#x27;],接收数据,接受之后使用和data中定义数据使用方式一样</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h4><p>在父组件中给子组件绑定一个自定义的事件，子组件通过$emit()触发该事件并传值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父组件： &lt;child @receive = &#x27;receive&#x27; /&gt;</span><br><span class="line"></span><br><span class="line"> 子组件: this.$emit(&#x27;receive&#x27;,&#x27;传递的数据&#x27;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="兄弟组件传值"><a href="#兄弟组件传值" class="headerlink" title="兄弟组件传值"></a>兄弟组件传值</h4><ul><li>通过中央通信 let bus = new Vue()</li></ul><blockquote><p>A：methods :{ 函数{bus.$emit(‘自定义事件名’，数据)} 发送</p></blockquote><blockquote><p>B：created （）{bus.$on(‘A发送过来的自定义事件名’，函数)} 进行数据接收</p></blockquote><ul><li>通过vuex</li></ul><h3 id="prop-验证，和默认值"><a href="#prop-验证，和默认值" class="headerlink" title="prop 验证，和默认值"></a>prop 验证，和默认值</h3><p>我们在父组件给子组件传值的时候，可以指定该props的默认值及类型，当传递数据类型不正确的时候，vue会发出警告</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    visible: &#123;</span><br><span class="line">        default: true,</span><br><span class="line">        type: Boolean,</span><br><span class="line">        required: true</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="请说下封装-vue-组件的过程"><a href="#请说下封装-vue-组件的过程" class="headerlink" title="请说下封装 vue 组件的过程"></a>请说下封装 vue 组件的过程</h3><p>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。</p><p>然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</p><h3 id="Vue-js的template编译"><a href="#Vue-js的template编译" class="headerlink" title="Vue.js的template编译"></a>Vue.js的template编译</h3><p>简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点），详细步骤如下：</p><blockquote><p>首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。</p></blockquote><blockquote><p>然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）</p></blockquote><h3 id="scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？"><a href="#scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？" class="headerlink" title="scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？"></a>scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</h3><p>css的预编译,使用步骤如下：</p><p>第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）</p><p>第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss</p><p>第三步：还是在同一个文件，配置一个module属性</p><p>第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”</p><p>特性主要有:</p><ul><li>可以用变量，例如（$变量名称=值）</li><li>可以用混合器，例如（）</li><li>可以嵌套</li></ul><h3 id="vue如何监听对象或者数组某个属性的变化"><a href="#vue如何监听对象或者数组某个属性的变化" class="headerlink" title="vue如何监听对象或者数组某个属性的变化"></a>vue如何监听对象或者数组某个属性的变化</h3><p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。</p><p>解决方式：</p><ul><li>this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$set(this.arr, 0, &quot;OBKoro1&quot;); // 改变数组</span><br><span class="line">this.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); // 改变对象</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>调用以下几个数组的方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">splice()、 push()、pop()、shift()、unshift()、sort()、reverse()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用我们再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作</p><h3 id="常用的事件修饰符"><a href="#常用的事件修饰符" class="headerlink" title="常用的事件修饰符"></a>常用的事件修饰符</h3><ul><li>.stop:阻止冒泡</li><li>.prevent:阻止默认行为</li><li>.self:仅绑定元素自身触发</li><li>.once: 2.1.4 新增,只触发一次</li><li>passive: 2.3.0 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和.prevent 一起使用</li><li>.sync 修饰符</li></ul><p>从 2.3.0 起vue重新引入了.sync修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;复制代码</span><br></pre></td></tr></table></figure><p>会被扩展为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;复制代码</span><br></pre></td></tr></table></figure><p>当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&#x27;update:foo&#x27;, newValue)复制代码</span><br></pre></td></tr></table></figure><h3 id="vue如何获取dom"><a href="#vue如何获取dom" class="headerlink" title="vue如何获取dom"></a>vue如何获取dom</h3><p>先给标签设置一个ref值，再通过this.$refs.domName获取，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ref=&quot;test&quot;&gt;&lt;/div&gt;const dom = this.$refs.test复制代码</span><br></pre></td></tr></table></figure><h3 id="v-on可以监听多个方法吗？"><a href="#v-on可以监听多个方法吗？" class="headerlink" title="v-on可以监听多个方法吗？"></a>v-on可以监听多个方法吗？</h3><p>是可以的，来个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-on=&quot;&#123; input:onInput,focus:onFocus,blur:onBlur, &#125;&quot;&gt;复制代码</span><br></pre></td></tr></table></figure><h3 id="assets和static的区别"><a href="#assets和static的区别" class="headerlink" title="assets和static的区别"></a>assets和static的区别</h3><p>这两个都是用来存放项目中所使用的静态资源文件。</p><p>两者的区别：</p><p>assets中的文件在运行npm run build的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到static中。</p><p>static中的文件则不会被打包。</p><blockquote><p>建议：将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了。</p></blockquote><h3 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h3><p>很多时候，我们封装了一个子组件之后，在父组件使用的时候，想添加一些dom元素，这个时候就可以使用slot插槽了，但是这些dom是否显示以及在哪里显示，则是看子组件中slot组件的位置了。</p><h3 id="vue初始化页面闪动问题"><a href="#vue初始化页面闪动问题" class="headerlink" title="vue初始化页面闪动问题"></a>vue初始化页面闪动问题</h3><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。</p><p>首先：在css里加上以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[v-cloak] &#123;    display: none;&#125;复制代码</span><br></pre></td></tr></table></figure><p>如果没有彻底解决问题，则在根元素加上style=”display: none;” :style=”{display: ‘block’}”</p><h2 id="vue插件篇"><a href="#vue插件篇" class="headerlink" title="vue插件篇"></a>vue插件篇</h2><h3 id="状态管理（vuex）"><a href="#状态管理（vuex）" class="headerlink" title="状态管理（vuex）"></a>状态管理（vuex）</h3><h4 id="vuex是什么"><a href="#vuex是什么" class="headerlink" title="vuex是什么"></a>vuex是什么</h4><p>Vuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p><h4 id="怎么使用vuex"><a href="#怎么使用vuex" class="headerlink" title="怎么使用vuex"></a>怎么使用vuex</h4><p>第一步安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex -S复制代码</span><br></pre></td></tr></table></figure><p>第二步创建store</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;;import Vuex from &#x27;vuex&#x27;;Vue.use(Vuex);//不是在生产环境debug为trueconst debug = process.env.NODE_ENV !== &#x27;production&#x27;;//创建Vuex实例对象const store = new Vuex.Store(&#123;    strict:debug,//在不是生产环境下都开启严格模式    state:&#123;    &#125;,    getters:&#123;    &#125;,    mutations:&#123;    &#125;,    actions:&#123;    &#125;&#125;)export default store;复制代码</span><br></pre></td></tr></table></figure><p>第三步注入vuex</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;import store from &#x27;./store&#x27;;const vm = new Vue(&#123;    store:store,    render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;)复制代码</span><br></pre></td></tr></table></figure><h4 id="vuex中有几个核心属性，分别是什么？"><a href="#vuex中有几个核心属性，分别是什么？" class="headerlink" title="vuex中有几个核心属性，分别是什么？"></a>vuex中有几个核心属性，分别是什么？</h4><p>一共有5个核心属性，分别是:</p><ul><li>state 唯一数据源,Vue 实例中的 data 遵循相同的规则</li><li>getters 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;  state: &#123;    todos: [      &#123; id: 1, text: &#x27;...&#x27;, done: true &#125;,      &#123; id: 2, text: &#x27;...&#x27;, done: false &#125;    ]  &#125;,  getters: &#123;    doneTodos: state =&gt; &#123;      return state.todos.filter(todo =&gt; todo.done)    &#125;  &#125;&#125;)store.getters.doneTodos // -&gt; [&#123; id: 1, text: &#x27;...&#x27;, done: true &#125;]复制代码</span><br></pre></td></tr></table></figure><ul><li>mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,非常类似于事件,通过store.commit 方法触发</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;  state: &#123;    count: 1  &#125;,  mutations: &#123;    increment (state) &#123;      // 变更状态      state.count++    &#125;  &#125;&#125;)store.commit(&#x27;increment&#x27;)复制代码</span><br></pre></td></tr></table></figure><ul><li>action Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  mutations: &#123;    increment (state) &#123;      state.count++    &#125;  &#125;,  actions: &#123;    increment (context) &#123;      context.commit(&#x27;increment&#x27;)    &#125;  &#125;&#125;)复制代码</span><br></pre></td></tr></table></figure><ul><li>module  由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;  state: () =&gt; (&#123; ... &#125;),  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;,  getters: &#123; ... &#125;&#125;const moduleB = &#123;  state: () =&gt; (&#123; ... &#125;),  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123;  modules: &#123;    a: moduleA,    b: moduleB  &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态复制代码</span><br></pre></td></tr></table></figure><h4 id="ajax请求代码应该写在组件的methods中还是vuex的actions中"><a href="#ajax请求代码应该写在组件的methods中还是vuex的actions中" class="headerlink" title="ajax请求代码应该写在组件的methods中还是vuex的actions中"></a>ajax请求代码应该写在组件的methods中还是vuex的actions中</h4><p>如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。</p><p>如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。</p><h4 id="从vuex中获取的数据能直接更改吗？"><a href="#从vuex中获取的数据能直接更改吗？" class="headerlink" title="从vuex中获取的数据能直接更改吗？"></a>从vuex中获取的数据能直接更改吗？</h4><p>从vuex中取的数据，不能直接更改，需要浅拷贝对象之后更改，否则报错；</p><h4 id="vuex中的数据在页面刷新后数据消失"><a href="#vuex中的数据在页面刷新后数据消失" class="headerlink" title="vuex中的数据在页面刷新后数据消失"></a>vuex中的数据在页面刷新后数据消失</h4><p>用sessionstorage 或者 localstorage 存储数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存储： sessionStorage.setItem( &#x27;名&#x27;, JSON.stringify(值) )使用： sessionStorage.getItem(&#x27;名&#x27;) ---得到的值为字符串类型，用JSON.parse()去引号；复制代码</span><br></pre></td></tr></table></figure><p>也可以引入插件vuex-persist，使用方法如下：</p><ul><li>安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save vuex-persistoryarn add vuex-persist复制代码</span><br></pre></td></tr></table></figure><ul><li>引入</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import VuexPersistence from &#x27;vuex-persist&#x27;复制代码</span><br></pre></td></tr></table></figure><ul><li>先创建一个对象并进行配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const vuexLocal = new VuexPersistence(&#123;    storage: window.localStorage&#125;)复制代码</span><br></pre></td></tr></table></figure><ul><li>引入进vuex插件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;  state: &#123; ... &#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;,  plugins: [vuexLocal.plugin]&#125;) 复制代码</span><br></pre></td></tr></table></figure><p>通过以上设置，在图3中各个页面之间跳转，如果刷新某个视图，数据并不会丢失，依然存在，并且不需要在每个 mutations 中手动存取 storage 。</p><h4 id="Vuex的严格模式是什么-有什么作用-怎么开启？"><a href="#Vuex的严格模式是什么-有什么作用-怎么开启？" class="headerlink" title="Vuex的严格模式是什么,有什么作用,怎么开启？"></a>Vuex的严格模式是什么,有什么作用,怎么开启？</h4><p>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p><p>在Vuex.Store 构造器选项中开启,如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;    strict:true,&#125;)复制代码</span><br></pre></td></tr></table></figure><h4 id="怎么在组件中批量使用Vuex的getter属性"><a href="#怎么在组件中批量使用Vuex的getter属性" class="headerlink" title="怎么在组件中批量使用Vuex的getter属性"></a>怎么在组件中批量使用Vuex的getter属性</h4><p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;mapGetters&#125; from &#x27;vuex&#x27;export default&#123;    computed:&#123;        ...mapGetters([&#x27;total&#x27;,&#x27;discountTotal&#x27;])    &#125;&#125;复制代码</span><br></pre></td></tr></table></figure><h4 id="组件中重复使用mutation"><a href="#组件中重复使用mutation" class="headerlink" title="组件中重复使用mutation"></a>组件中重复使用mutation</h4><p>使用mapMutations辅助函数,在组件中这么使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapMutations &#125; from &#x27;vuex&#x27;methods:&#123;    ...mapMutations(&#123;        setNumber:&#x27;SET_NUMBER&#x27;,    &#125;)&#125;复制代码</span><br></pre></td></tr></table></figure><p>然后调用this.setNumber(10)相当调用this.$store.commit(‘SET_NUMBER’,10)</p><h4 id="mutation和action有什么区别"><a href="#mutation和action有什么区别" class="headerlink" title="mutation和action有什么区别"></a>mutation和action有什么区别</h4><ul><li>action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态</li><li>action 可以包含任意异步操作。mutation只能是同步操作</li><li>提交方式不同</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action 是用this.store.dispatch(&#x27;ACTION_NAME&#x27;,data)来提交。mutation是用this.$store.commit(&#x27;SET_NUMBER&#x27;,10)来提交复制代码</span><br></pre></td></tr></table></figure><ul><li>接收参数不同，mutation第一个参数是state，而action第一个参数是context，其包含了</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;    state,      // 等同于 `store.state`，若在模块中则为局部状态    rootState,  // 等同于 `store.state`，只存在于模块中    commit,     // 等同于 `store.commit`    dispatch,   // 等同于 `store.dispatch`    getters,    // 等同于 `store.getters`    rootGetters // 等同于 `store.getters`，只存在于模块中&#125;复制代码</span><br></pre></td></tr></table></figure><h4 id="在v-model上怎么用Vuex中state的值？"><a href="#在v-model上怎么用Vuex中state的值？" class="headerlink" title="在v-model上怎么用Vuex中state的值？"></a>在v-model上怎么用Vuex中state的值？</h4><p>需要通过computed计算属性来转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;message&quot;&gt;// ...computed: &#123;    message: &#123;        get () &#123;            return this.$store.state.message        &#125;,        set (value) &#123;            this.$store.commit(&#x27;updateMessage&#x27;, value)        &#125;    &#125;&#125;复制代码</span><br></pre></td></tr></table></figure><h3 id="路由页面管理（vue-router）"><a href="#路由页面管理（vue-router）" class="headerlink" title="路由页面管理（vue-router）"></a>路由页面管理（vue-router）</h3><h4 id="什么是vue-router"><a href="#什么是vue-router" class="headerlink" title="什么是vue-router"></a>什么是vue-router</h4><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p><ul><li>嵌套的路由/视图表</li><li>模块化的、基于组件的路由配置</li><li>路由参数、查询、通配符</li><li>基于 Vue.js 过渡系统的视图过渡效果</li><li>细粒度的导航控制</li><li>带有自动激活的 CSS class 的链接</li><li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li><li>自定义的滚动条行为</li></ul><h4 id="怎么使用vue-router"><a href="#怎么使用vue-router" class="headerlink" title="怎么使用vue-router"></a>怎么使用vue-router</h4><p>第一步安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router -S</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>第二步在main.js中使用Vue Router组件</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/14/1734d65dc240568e~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>第三步配置路由</p><ul><li>定义 (路由) 组件</li></ul><p>路由组件可以是直接定义，也可以是导入已经定义好的组件。这里导入已经定义好的组件。如下</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/14/1734d65dc2668cc8~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ul><li>定义路由（路由对象数组）</li></ul><p>定义路由对象数组。对象的path是自定义的路径（即使用这个路径可以找到对应的组件），component是指该路由对应的组件。如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/14/1734d65dc3da62ed~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ul><li>实例化Vue Router对象</li></ul><p>调用Vue Router的构造方法创建一个Vue Router的实例对象，将上一步定义的路由对象数组作为参数对象的值传入。如下</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/14/1734d65dc48e8bf4~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ul><li>挂载根实例</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/14/1734d65dcb5f42d7~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>第四步在App.vue中使用路由</p><p>在App.vue中使用标签来显示路由对应的组件，使用标签指定当点击时显示的对应的组件，to属性就是指定组件对应的路由。如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/14/1734d65dc512c1e6~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h4 id="怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"><a href="#怎么定义vue-router的动态路由？怎么获取传过来的动态参数？" class="headerlink" title="怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"></a>怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</h4><p>在router目录下的index.js文件中，对path属性加上/:id。使用router对象的params.id获取动态参数</p><h4 id="vue-router的导航钩子"><a href="#vue-router的导航钩子" class="headerlink" title="vue-router的导航钩子"></a>vue-router的导航钩子</h4><p>常用的是router.beforeEach(to,from,next)，在跳转前进行权限判断。一共有三种：</p><ul><li>全局导航钩子：router.beforeEach(to,from,next)</li><li>组件内的钩子</li><li>单独路由独享组件</li></ul><h4 id="vue路由传参"><a href="#vue路由传参" class="headerlink" title="vue路由传参"></a>vue路由传参</h4><blockquote><p>使用query方法传入的参数使用this.$route.query接受</p></blockquote><blockquote><p>使用params方式传入的参数使用this.$route.params接受</p></blockquote><h4 id="router和route的区别"><a href="#router和route的区别" class="headerlink" title="router和route的区别"></a>router和route的区别</h4><blockquote><p>route为当前router跳转对象里面可以获取name、path、query、params等</p></blockquote><blockquote><p>router为VueRouter实例，想要导航到不同URL，则使用router.push方法</p></blockquote><h4 id="路由-TypeError-Cannot-read-property-‘matched’-of-undefined-的错误问题"><a href="#路由-TypeError-Cannot-read-property-‘matched’-of-undefined-的错误问题" class="headerlink" title="路由 TypeError: Cannot read property ‘matched’ of undefined 的错误问题"></a>路由 TypeError: Cannot read property ‘matched’ of undefined 的错误问题</h4><p>找到入口文件main.js里的new Vue()，必须使用router名，不能把router改成Router或者其他的别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 引入路由</span><br><span class="line">import router from &#x27;./routers/router.js&#x27;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    router,    // 这个名字必须使用router</span><br><span class="line">    render: h =&gt; h(App)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="路由按需加载"><a href="#路由按需加载" class="headerlink" title="路由按需加载"></a>路由按需加载</h4><p>随着项目功能模块的增加，引入的文件数量剧增。如果不做任何处理，那么首屏加载会相当的缓慢，这个时候，路由按需加载就闪亮登场了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">webpack&lt; 2.4 时</span><br><span class="line">&#123; </span><br><span class="line">    path:&#x27;/&#x27;, </span><br><span class="line">    name:&#x27;home&#x27;,</span><br><span class="line">    components:resolve=&gt;require([&#x27;@/components/home&#x27;],resolve)</span><br><span class="line">&#125; </span><br><span class="line">webpack&gt; 2.4 时</span><br><span class="line">&#123; </span><br><span class="line">    path:&#x27;/&#x27;, </span><br><span class="line">    name:&#x27;home&#x27;, </span><br><span class="line">    components:()=&gt;import(&#x27;@/components/home&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>import()方法是由es6提出的，动态加载返回一个Promise对象，then方法的参数是加载到的模块。类似于Node.js的require方法，主要import()方法是异步加载的。</p><h4 id="Vue里面router-link在电脑上有用，在安卓上没反应怎么解决"><a href="#Vue里面router-link在电脑上有用，在安卓上没反应怎么解决" class="headerlink" title="Vue里面router-link在电脑上有用，在安卓上没反应怎么解决"></a>Vue里面router-link在电脑上有用，在安卓上没反应怎么解决</h4><p>Vue路由在Android机上有问题，babel问题，安装babel polypill插件解决</p><h4 id="Vue2中注册在router-link上事件无效解决方法"><a href="#Vue2中注册在router-link上事件无效解决方法" class="headerlink" title="Vue2中注册在router-link上事件无效解决方法"></a>Vue2中注册在router-link上事件无效解决方法</h4><p>使用@click.native。原因：router-link会阻止click事件，.native指直接监听一个原生事件</p><h4 id="RouterLink在IE和Firefox中不起作用（路由不跳转）的问题"><a href="#RouterLink在IE和Firefox中不起作用（路由不跳转）的问题" class="headerlink" title="RouterLink在IE和Firefox中不起作用（路由不跳转）的问题"></a>RouterLink在IE和Firefox中不起作用（路由不跳转）的问题</h4><ul><li>只用a标签，不使用button标签</li><li>使用button标签和Router.navigate方法</li></ul><h3 id="网络请求-axios"><a href="#网络请求-axios" class="headerlink" title="网络请求(axios)"></a>网络请求(axios)</h3><p>这个模块请看我的另一篇文章，此处不再整理（我太懒了）</p><p><a href="https://juejin.cn/post/6847009771606769677">学会了axios封装，世界都是你的</a></p><h3 id="视频播放-video-js"><a href="#视频播放-video-js" class="headerlink" title="视频播放(video.js)"></a>视频播放(video.js)</h3><p>这个模块请看我的另一篇文章，此处不再整理（我太懒了）</p><p><a href="https://juejin.cn/post/6850037269227634702">手把手从零开始—封装一个vue视频播放器组件</a></p><h3 id="vue常用ui库"><a href="#vue常用ui库" class="headerlink" title="vue常用ui库"></a>vue常用ui库</h3><h4 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h4><ul><li>mint-ui （<a href="http://mint-ui.github.io/#!/zh-cn%EF%BC%89">http://mint-ui.github.io/#!/zh-cn）</a></li><li>Vant（<a href="https://youzan.github.io/vant/#/zh-CN/home%EF%BC%89">https://youzan.github.io/vant/#/zh-CN/home）</a></li><li>VUX (<a href="https://vux.li/">https://vux.li/</a>)</li></ul><h4 id="pc端"><a href="#pc端" class="headerlink" title="pc端"></a>pc端</h4><ul><li>element-ui（<a href="https://element.eleme.cn/2.13/#/zh-CN/component/installation%EF%BC%89">https://element.eleme.cn/2.13/#/zh-CN/component/installation）</a></li><li>Ant Design of Vue（<a href="https://www.antdv.com/docs/vue/introduce-cn/%EF%BC%89">https://www.antdv.com/docs/vue/introduce-cn/）</a></li><li>Avue (<a href="https://avuejs.com/">https://avuejs.com/</a>)</li></ul><h2 id="常用webpack配置"><a href="#常用webpack配置" class="headerlink" title="常用webpack配置"></a>常用webpack配置</h2><h3 id="vue-lic3脚手架（vue-config-js）"><a href="#vue-lic3脚手架（vue-config-js）" class="headerlink" title="vue-lic3脚手架（vue.config.js）"></a>vue-lic3脚手架（vue.config.js）</h3><h4 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h4><p>类型：String</p><p>默认：’/‘</p><p>部署应用包时的基本 URL。默认情况下，Vue CLI会假设你的应用是被部署在一个域名的根路径上，例如<a href="https://www.my-app.com/%E3%80%82%E5%A6%82%E6%9E%9C%E5%BA%94%E7%94%A8%E8%A2%AB%E9%83%A8%E7%BD%B2%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%AD%90%E8%B7%AF%E5%BE%84%E4%B8%8A%EF%BC%8C%E4%BD%A0%E5%B0%B1%E9%9C%80%E8%A6%81%E7%94%A8%E8%BF%99%E4%B8%AA%E9%80%89%E9%A1%B9%E6%8C%87%E5%AE%9A%E8%BF%99%E4%B8%AA%E5%AD%90%E8%B7%AF%E5%BE%84%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E8%A2%AB%E9%83%A8%E7%BD%B2%E5%9C%A8https://www.my-app.com/my-app/%EF%BC%8C%E5%88%99%E8%AE%BE%E7%BD%AEpublicPath%E4%B8%BA/my-app/">https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在https://www.my-app.com/my-app/，则设置publicPath为/my-app/</a></p><p>这个值也可以被设置为空字符串 (‘’) 或是相对路径 (‘./‘)，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似 Cordova hybrid 应用的文件系统中。</p><h4 id="productionSourceMap"><a href="#productionSourceMap" class="headerlink" title="productionSourceMap"></a>productionSourceMap</h4><p>类型：boolean</p><p>moren：true</p><p>不允许打包时生成项目来源映射文件，在生产环境下可以显著的减少包的体积</p><blockquote><p>注 Source map的作用：针对打包后的代码进行的处理，就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便</p></blockquote><h4 id="assetsDir"><a href="#assetsDir" class="headerlink" title="assetsDir"></a>assetsDir</h4><p>放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录,默认是’’,</p><h4 id="indexPath"><a href="#indexPath" class="headerlink" title="indexPath"></a>indexPath</h4><p>指定生成的 index.html 的输出路径(相对于outputDir)。也可以是一个绝对路径。默认是’index.html’</p><h4 id="lintOnSave"><a href="#lintOnSave" class="headerlink" title="lintOnSave"></a>lintOnSave</h4><p>是否在每次保存时使用eslint检查，这个对语法的要求比较严格，对自己有要求的同学可以使用</p><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">css: &#123;    //是否启用css分离插件，默认是true，如果不启用css样式分离插件，打包出来的css是通过内联样式的方式注入至dom中的，    extract: true,    sourceMap: false,//效果同上    modules: false,// 为所有的 CSS 及其预处理文件开启 CSS Modules。    // 这个选项不会影响 `*.vue` 文件。  &#125;,复制代码</span><br></pre></td></tr></table></figure><h4 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h4><p>本地开发服务器配置，此处直接贴上我常用的配置，以注释的方式介绍</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123; </span><br><span class="line">    //配置开发服务器</span><br><span class="line">    host: &quot;0.0.0.0&quot;,</span><br><span class="line">    //是否启用热加载，就是每次更新代码，是否需要重新刷新浏览器才能看到新代码效果</span><br><span class="line">    hot: true,</span><br><span class="line">    //服务启动端口</span><br><span class="line">    port: &quot;8080&quot;,</span><br><span class="line">    //是否自动打开浏览器默认为false</span><br><span class="line">    open: false,</span><br><span class="line">    //配置http代理</span><br><span class="line">    proxy: &#123; </span><br><span class="line">      &quot;/api&quot;: &#123; //如果ajax请求的地址是http://192.168.0.118:9999/api1那么你就可以在jajx中使用/api/api1路径,其请求路径会解析</span><br><span class="line">        // http://192.168.0.118:9999/api1，当然你在浏览器上开到的还是http://localhost:8080/api/api1;</span><br><span class="line">        target: &quot;http://192.168.0.118:9999&quot;,</span><br><span class="line">        //是否允许跨域，这里是在开发环境会起作用，但在生产环境下，还是由后台去处理，所以不必太在意</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">            //把多余的路径置为&#x27;&#x27;</span><br><span class="line">          &quot;api&quot;: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;/api2&quot;: &#123;//可以配置多个代理，匹配上那个就使用哪种解析方式</span><br><span class="line">        target: &quot;http://api2&quot;,</span><br><span class="line">        // ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="pluginOptions"><a href="#pluginOptions" class="headerlink" title="pluginOptions"></a>pluginOptions</h4><p>这是一个不进行任何 schema 验证的对象，因此它可以用来传递任何第三方插件选项，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    //定义一个全局的less文件，把公共样式变量放入其中，这样每次使用的时候就不用重新引用了</span><br><span class="line">    &#x27;style-resources-loader&#x27;: &#123;</span><br><span class="line">      preProcessor: &#x27;less&#x27;,</span><br><span class="line">      patterns: [</span><br><span class="line">        &#x27;./src/assets/public.less&#x27;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="chainWebpack"><a href="#chainWebpack" class="headerlink" title="chainWebpack"></a>chainWebpack</h4><p>是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chainWebpack(config) &#123; </span><br><span class="line">//添加一个路径别名 假设有在assets/img/menu/目录下有十张图片，如果全路径require(&quot;/assets/img/menu/img1.png&quot;)</span><br><span class="line">//去引入在不同的层级下实在是太不方便了，这时候向下方一样定义一个路劲别名就很实用了</span><br><span class="line">    config.resolve.alias</span><br><span class="line">      //添加多个别名支持链式调用</span><br><span class="line">      .set(&quot;assets&quot;, path.join(__dirname, &quot;/src/assets&quot;))</span><br><span class="line">      .set(&quot;img&quot;, path.join(__dirname, &quot;/src/assets/img/menu&quot;))</span><br><span class="line">      //引入图片时只需require(&quot;img/img1.png&quot;);即可</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>参考：</p><p>1、Vue常见问题总结 <a href="https://blog.csdn.net/qq_27674439/article/details/99449197">https://blog.csdn.net/qq_27674439/article/details/99449197</a></p><p>2、vue常见面试题 <a href="https://zhuanlan.zhihu.com/p/92407628">https://zhuanlan.zhihu.com/p/92407628</a></p><p>3、vuex官网 <a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a></p><p>4、Vuex面试题汇总 <a href="https://juejin.cn/post/6844903993374670855">https://juejin.cn/post/6844903993374670855</a></p><p>5、Vue CLI官网 <a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></p><p>历史好文推荐：</p><p>1、<a href="https://juejin.cn/post/6850418118695583758">【万字长文】史上最强css、html总结~看完涨薪不再是梦</a></p><p>2、<a href="https://juejin.cn/post/6854573211451932685">【万字长文】最全JavaScript基础总结~建议收藏 </a></p><p>3、<a href="https://juejin.cn/post/6847902222882340872">Event Loop我知道，宏任务微任务是什么鬼？</a></p><p>4、<a href="https://juejin.cn/post/6847009771493523464">锋利码农武器之vscode</a></p><p>5、<a href="https://juejin.cn/post/6847009771371888653">面试宝典带你走上人生巅峰</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS如何优雅的获取浮点数的整数和小数部分</title>
      <link href="/2022/01/08/JS%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%8E%B7%E5%8F%96%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%95%B4%E6%95%B0%E5%92%8C%E5%B0%8F%E6%95%B0%E9%83%A8%E5%88%86/"/>
      <url>/2022/01/08/JS%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%8E%B7%E5%8F%96%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%95%B4%E6%95%B0%E5%92%8C%E5%B0%8F%E6%95%B0%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h3 id="1-取整数"><a href="#1-取整数" class="headerlink" title="1.取整数"></a>1.取整数</h3><p>1.parseInt</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">3.75</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(num)); <span class="comment">// 3</span></span><br><span class="line">num = -<span class="number">3.75</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(num)); <span class="comment">// -3</span></span><br></pre></td></tr></table></figure><p>用parseInt取整数，结果是没问题的，但是如果<strong>严格来说</strong>，其实<strong>parseInt并不是设计用来取整数的</strong>。</p><blockquote><p><strong>👉🏻 知识点：</strong><code>parseInt(string, radix)`` </code>这个方法是一个将字符串转换为整数的方法，它有两个参数，第一个参数表示要转换的字符串，如果参数不是一个字符串，则将其转换为字符串。第二个参数是基数即进制，默认为10。</p></blockquote><p>所以用 parseInt 方法取整数，有<strong>两个不好的地方</strong>，一是 parseInt 这个函数名，看起来就是将字符串转整数的，用在这里不是很适合，另一个是转字符串有点多此一举，而且肯定会带来性能开销，所以使用 parseInt 虽然方便，但不是最好的办法。</p><p>2.Math方法</p><p>其中 Math.round 是四舍五入的，Math.ceil 是向上取整，Math.floor 是向下取整。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trunc</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Math</span>.floor(num) <span class="comment">//如果小于0 向上取整</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.ceil(num) <span class="comment">//向下取整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.位操作</p><p>使用位操作方法，在运算过程中会把操作数转为成32位整数，如此，运算后的结果就是整数部分了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">3.75</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num | <span class="number">0</span>); <span class="comment">// 3</span></span><br><span class="line">num = -num;</span><br><span class="line"><span class="built_in">console</span>.log(num | <span class="number">0</span>); <span class="comment">// -3</span></span><br></pre></td></tr></table></figure><p>但是这样做也有缺陷</p><blockquote><p>👉🏻 <strong>冷知识</strong>：因为bitwise操作将操作数转为Int32，所以它不能处理超过32位的数值取整，而JavaScript有效整数的范围是53位。</p></blockquote><p>当数值范围超过32位时，它将不能对数值取整，而JavaScript有效整数的范围是53位。</p><p>那么用“|”有什么<strong>好处</strong>呢？如果考虑js文件大小，那么<strong>a|0</strong>与其他方式比较，是最短的方式，所以如果要考虑压缩代码的大小，且明确知道数值范围不会超过32位整数的时候，可以考虑使用这个技巧。</p><h3 id="2-取小数"><a href="#2-取小数" class="headerlink" title="2.取小数"></a>2.取小数</h3><p>1.parseInt+split</p><p>将数值转换成2字符串后切割并转换回数值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">12.76</span></span><br><span class="line"><span class="keyword">const</span> integer = <span class="built_in">parseInt</span>(num.toString().split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">const</span> decimal = <span class="built_in">parseInt</span>(num.toString().split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>])<span class="comment">//取小数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;integer&#125;</span>.<span class="subst">$&#123;decimal&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>2.Math.trunc()</p><p>先用<code>Math.trunc(num)</code>取整，然后再与原数相减，就得到了小数部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fract</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num - <span class="built_in">Math</span>.trunc(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fract(<span class="number">3.75</span>)); <span class="comment">// 0.75</span></span><br><span class="line"><span class="built_in">console</span>.log(fract(-<span class="number">3.75</span>)); <span class="comment">// -0.75</span></span><br></pre></td></tr></table></figure><p>3.取模运算</p><blockquote><p><strong>👉🏻 知识点：</strong> JavaScript的取模运算%并不限于整数运算，可以对浮点数取模。</p></blockquote><p>所以，直接将原数对1取模，即可获得小数部分！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">3.75</span> % <span class="number">1</span>); <span class="comment">// 0.75</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">3.75</span> % <span class="number">1</span>); <span class="comment">// -0.75</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
