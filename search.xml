<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试知识整理</title>
      <link href="/2022/03/13/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2022/03/13/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="面试复习"><a href="#面试复习" class="headerlink" title="面试复习"></a>面试复习</h1><h2 id="1-JavaScript-基础"><a href="#1-JavaScript-基础" class="headerlink" title="1.JavaScript 基础"></a>1.JavaScript 基础</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132100087.png" alt="image-20220308142823940"></p><h3 id="1-执行上下文-作用域-闭包"><a href="#1-执行上下文-作用域-闭包" class="headerlink" title="1.执行上下文/作用域/闭包"></a>1.执行上下文/作用域/闭包</h3><h4 id="1-什么是执行上下文"><a href="#1-什么是执行上下文" class="headerlink" title="1.什么是执行上下文?"></a>1.什么是执行上下文?</h4><p>执行上下文是评估和执行JavaScript代码环境的抽象概念。每当JavaScript代码在运行时，他都是在执行上下文中运行。</p><hr><p><strong>执行上下文的类型</strong></p><p>JavaScript共有<strong>三种</strong>执行上下文类型</p><ul><li><strong>全局执行上下文</strong><ul><li>这是基础的上下文,任何不在函数内部的代码都在全局上下文中.他会执行两件事:创建一个全局的window对象(浏览器环境的情况下),并且设置this的值等于这个全局对象。一个程序中只会有一个全局执行上下文</li></ul></li><li><strong>函数执行上下文</strong><ul><li>每当函数被调用时，都会为该函数创建一个新的执行上下文。每个函数都有他自己的执行上下文，只不过是在函数被调用时才被创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，他会按定义的瞬狙执行一系列步骤</li></ul></li><li><strong>Eval函数执行上下文</strong><ul><li>执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文</li></ul></li></ul><hr><p><strong>执行上下文栈</strong></p><p>执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。</p><p>当JavaScript引擎第一次遇到你的脚本时，他会创建一个全局的执行上下文并且压入当前执行栈。<strong>每当引擎遇到一个函数调用，他会为该函数创建一个新的执行上下文并压入栈的顶部.</strong></p><p>引擎会执行那些执行上下文位于栈顶的函数.<strong>每当函数执行结束之后，最上层的执行上下文从栈中弹出</strong>，控制流程到达当前栈中的下一个上下文</p><p><strong>一旦所有代码执行完毕，JavaScript引擎从当前栈中移除全局执行上下文</strong></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132100915.png" alt="image-20220308144717269"></p><hr><p><strong>怎么创建执行上下文?</strong></p><p>创建执行上下文有两个阶段:</p><ol><li><strong>创建阶段</strong></li><li><strong>执行阶段</strong></li></ol><hr><p><strong>创建阶段</strong></p><p>在JavaScript代码执行前，执行上下文将经历创建阶段。在创建阶段将会发生三件事:</p><ol><li><strong>this</strong>值的绑定</li><li>创建<strong>词法环境</strong></li><li>创建<strong>变量环境</strong></li></ol><p>所以执行上下文在概念上表示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext = &#123;</span><br><span class="line">  ThisBinding = &lt;this value&gt;,</span><br><span class="line">  LexicalEnvironment = &#123; ... &#125;,</span><br><span class="line">  VariableEnvironment = &#123; ... &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>This绑定:</strong></p><p>在全局执行上下文中,<code>this</code>的值指向全局对象(在浏览器中,全局对象为<code>window</code>’)</p><p>在函数执行上下文中,this的值取决于该函数是如何被调用的.如果他被一个引用类型对象调用,那么this会被设置成那个对象,否则<code>this</code>的值被设置成全局对象或者<code>undefined</code>(严格模式)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let foo = &#123;</span><br><span class="line">  baz: function() &#123;</span><br><span class="line">  console.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.baz();   <span class="comment">// &#x27;this&#x27; 引用 &#x27;foo&#x27;, 因为 &#x27;baz&#x27; 被</span></span><br><span class="line">             <span class="comment">// 对象 &#x27;foo&#x27; 调用</span></span><br><span class="line"></span><br><span class="line">let bar = foo.baz;</span><br><span class="line"></span><br><span class="line">bar();       <span class="comment">// &#x27;this&#x27; 指向全局 window 对象，因为</span></span><br><span class="line">             <span class="comment">// 没有指定引用对象</span></span><br></pre></td></tr></table></figure><p><strong>词法环境</strong></p><p><a href="https://link.juejin.cn/?target=http://ecma-international.org/ecma-262/6.0/">官方的 ES6</a> 文档把词法环境定义为</p><blockquote><p><strong>词法环境</strong>是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义<strong>标识符</strong>和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用<strong>外部</strong>词法环境的空值组成。</p></blockquote><p>词法环境是一种持有<strong>变量符-变量映射</strong>的结构(标识符指的是变量/函数的名字,而变量是对实际对象或原始数据的引用)</p><p>在词法环境的内部有两个组件:1.<strong>环境记录器</strong>和2.一个<strong>外部环境的引用</strong></p><p>1.<strong>环境记录器</strong>是存储变量和函数声明的实际位置</p><p>2.<strong>外部环境的引用</strong>意味着它可以访问其父级词法环境(作用域)</p><p><strong>词法环境</strong>有两种类型: <strong>全局环境</strong>和<strong>函数环境</strong></p><ul><li><p><strong>全局环境</strong>(在全局执行上下文中)是没有外部环境引用的词法环境,全局环境的外部环境引用是<strong>null</strong>，</p><p>它拥有创建的Object/Array等,在环境记录器内的原型函数(关联全局对象,比如window对象)还有任何用户定义的全局变量,并且<code>this</code>的值指向全局对象</p></li><li><p>在<strong>函数环境</strong>中，函数内部用户定义的变量存储在<strong>环境记录器</strong>中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。</p></li></ul><p>环境记录器也有两种类型:</p><ol><li><strong>声明式环境记录器</strong>，用来存储变量、函数和参数</li><li><strong>对象环境记录器</strong>,用来定义出现在<strong>全局上下文</strong>中的变量和函数关系</li></ol><p>由上不难得知</p><ul><li>在<strong>全局环境</strong>中,环境记录器是对象环境记录器</li><li>在<strong>函数环境</strong>中,环境记录器是声明式环境记录器</li></ul><p><strong>注意 :</strong> 对于<strong>函数环境</strong>，<strong>声明式环境记录器</strong>还包含了一个传递给函数的 <code>arguments</code> 对象（此对象存储索引和参数的映射）和传递给函数的参数的 <strong>length</strong>。</p><p>抽象地讲，词法环境在伪代码中看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;Global or outer function environment reference&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>变量环境</strong></p><p>变量环境其实也是一个<strong>词法环境</strong>,其环境记录器中持有变量声明语句在执行上下文中创建的绑定关系</p><p>变量环境有着词法环境的所有属性</p><p>在ES6中,词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量(<code>let</code>和<code>const</code>)绑定,而后者只用来存储<code>var</code>变量绑定</p><p>我们看点样例代码来理解上面的概念：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">e, f</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> g = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">return</span> e * f * g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = multiply(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行上下文看起来像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">ThisBinding</span>: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      a: &lt; uninitialized &gt;,</span><br><span class="line">      b: &lt; uninitialized &gt;,</span><br><span class="line">      multiply: &lt; func &gt;</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      c: undefined,</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  ThisBinding: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      Arguments: &#123;0: 20, 1: 30, length: 2&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      g: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能你已经注意到 <code>let</code> 和 <code>const</code> 定义的变量并没有关联任何值，但 <code>var</code> 定义的变量被设成了 <code>undefined</code>。</p><p>这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 <code>undefined</code>（<code>var</code> 情况下），或者未初始化（<code>let</code> 和 <code>const</code> 情况下）。</p><p>这就是为什么你可以在声明之前访问 <code>var</code> 定义的变量（虽然是 <code>undefined</code>），但是在声明之前访问 <code>let</code> 和 <code>const</code> 的变量会得到一个引用错误。</p><p>这就是我们说的<strong>变量声明提升</strong>。</p><hr><p><strong>执行阶段</strong></p><p><strong>在此阶段完成对所有存储的变量的分配,最后执行代码.</strong></p><p><strong>注意:</strong> 在执行阶段,如果JavaScript引擎不能再源码中声明的实际位置找到<code>let</code>变量的值，那么他就会被赋值为<code>undefined</code></p><hr><hr><h4 id="2-作用域-Scope"><a href="#2-作用域-Scope" class="headerlink" title="2.作用域(Scope)"></a>2.作用域(Scope)</h4><p><strong>什么是作用域?</strong></p><p><strong>作用域是指程序源代码中定义变量的区域。</strong></p><p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p><p>JavaScript 采用<strong>词法作用域</strong>(lexical scoping)，也就是静态作用域。</p><p>我们可以这样理解：<strong>作用域就是一个独立的地盘，让变量不会外泄、暴露出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong></p><p>ES6之前,JavaScript只有<strong>全局作用域</strong>和<strong>函数作用域</strong>,ES6之后，新增了<strong>块级作用域</strong>，可以通过<code>let</code>和<code>const</code>来创建</p><hr><p><strong>全局作用域和函数作用域</strong></p><p>**在代码中任何地方都能访问到的对象拥有全局作用域,**以下几种情况拥有全局作用域:</p><ul><li>最外层函数和在最外层函数外定义的变量拥有全局作用域</li><li>所有未定义直接赋值的变量默认为全局变量，拥有全局作用域</li><li>所有window对象的属性拥有全局作用域</li></ul><p>全局作用域的<strong>弊端</strong>:容易引发命名冲突，污染全局命名空间</p><hr><p><strong>函数作用域</strong></p><p><strong>在函数内部声明的变量</strong>拥有函数作用域,一般只能在固定的代码片段内可以访问到.</p><hr><p>作用域是分层的,内层作用域可以访问外层作用域的变量,反之则不行</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132100037.png" alt="image-20220308172822751"></p><p>值得注意的是：<strong>块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// &#x27;if&#x27; 条件语句块不会创建一个新的作用域</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;Hammad&#x27;</span>; <span class="comment">// name 依然在全局作用域中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// logs &#x27;Hammad&#x27;</span></span><br></pre></td></tr></table></figure><hr><p><strong>块级作用域</strong></p><p>块级作用域可以通过<code>let</code>和<code>const</code>声明,所声明的变量在指定块作用域·之外无法被访问。</p><p>块级作用域在如下情况被创建:</p><ol><li>在一个函数内部</li><li>在一个代码块内部(‘**{}**’)</li></ol><p>块级作用域有以下几个特点:</p><ul><li>声明变量不会提升的代码块顶部</li><li>禁止重复声明</li></ul><hr><p><strong>作用域链</strong></p><p>在JavaScript中,函数、块、模块都可以形成作用域,他们之间可以相互嵌套、作用域之间会形成引用关系，这条链叫做作用域链</p><p><strong>作用域链的创建和变化</strong></p><p><strong>函数创建时:</strong></p><p>JavaScript中使用的是词法作用域,<strong>函数的作用域在函数定义的时候就已经决定了</strong></p><p>函数有一个内部属性[[scope]]，当函数创建的时候,就会保存所有父变量对象到其中,可以理解为[[scope]]就是所有父变量对象的层级链,但是注意:[[scope]]并不代表完整的作用域链</p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数创建时，各自的[[scope]]为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">    fooContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><strong>函数被激活时:</strong></p><p>当函数被激活时,进入函数上下文,创建VO/AO后就会将活动对象添加到作用域的前端</p><p>这时候执行上下文的作用域链,我们命名为Scope</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure><p>至此,<strong>作用域链创建完毕</strong></p><hr><h4 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3.闭包"></a>3.闭包</h4><p><strong>什么是闭包?</strong></p><p>闭包就是同时含有对函数对象以及作用域对象引用的对象,实际上所有JavaScript对象都是闭包.</p><p><strong>本质</strong>:在一个函数内部创建另一个函数</p><p><strong>只要存在函数嵌套,并且内部函数调用了外部函数的属性,就产生了闭包.</strong></p><p>闭包的特性:</p><ul><li>函数嵌套函数</li><li>函数内部引用函数外部的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ul><hr><p><strong>闭包是什么时候被创建的？</strong></p><p>因为所有JavaScript对象都是闭包,所以当你定义一个函数时.就产生了闭包</p><hr><p><strong>闭包是什么时候被销毁的?</strong></p><p>当他不被任何其他的对象引用的时候，闭包就被销毁</p><hr><p><strong>闭包的好处</strong>:</p><ul><li>保护函数内的变量安全,实现封装,防止变量流入其他环境发生命名冲突</li><li>在内存中维持一个变量，延长变量的生命周期</li><li>匿名自执行函数可以减少内存消耗</li></ul><hr><p><strong>闭包的缺点:</strong></p><ul><li>被引用的私有变量不能被销毁，增大了内存的消耗，造成内存泄露</li><li>闭包涉及跨域访问，会导致性能损失</li></ul><hr><p><strong>闭包的作用</strong></p><ul><li>使得函数内部的变量在函数执行完之后，仍然存活在内存中(延长了局部变量的生命周期)</li><li>让函数外部可以操作到函数内部的数据</li></ul><hr><p><strong>闭包的原理</strong></p><p>当一个函数返回后，没有其他对象会保存对其的引用。所以，它就可能被<code>垃圾回收器</code>回收。</p><p>函数对象中总是有一个<code>[[scope]]</code>属性，保存着该函数被定义的时候所能够直接访问的作用域对象。所以，当我们在定义嵌套的函数的时候，这个嵌套的函数的<code>[[scope]]</code>就会引用外围函数（Outer function）的当前作用域对象。</p><p>如果我们将这个嵌套函数返回,并被另一个标识符所引用的话,那么这个嵌套函数及其[[scope]]所引用的作用作用域对象就不会被垃圾回收器所销毁,这个对象就会一直存活在内存中,我们可以通过这个作用于对象获取到外部函数的属性和值。</p><p>这就是闭包的原理</p><hr><h3 id="2-this-call-apply-bind"><a href="#2-this-call-apply-bind" class="headerlink" title="2.this/call/apply/bind"></a>2.this/call/apply/bind</h3><h4 id="1-this的指向"><a href="#1-this的指向" class="headerlink" title="1.this的指向"></a>1.this的指向</h4><blockquote><p>函数的this是在函数调用时才绑定的,它的指向完全取决于函数的调用位置(也就是函数的调用方法),为了搞清楚<code>this</code>的指向是什么，必须知道相关函数是如何调用的</p></blockquote><p><strong>在全局上下文中:</strong></p><p>非严格模式和严格模式中this都指向顶层对象(在浏览器中是<code>window</code>)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span> === <span class="built_in">window</span> <span class="comment">// true</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="built_in">this</span> === <span class="built_in">window</span>;</span><br><span class="line"><span class="built_in">this</span>.name = <span class="string">&#x27;若川&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// 若川</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>普通函数调用模式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 非严格模式</span><br><span class="line">var name = &#x27;window&#x27;;</span><br><span class="line">var doSth = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">doSth(); // &#x27;window&#x27;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>你可能会误以为<code>window.doSth()</code>是调用的，所以是指向<code>window</code>。虽然本例中<code>window.doSth</code>确实等于<code>doSth</code>。<code>name</code>等于<code>window.name</code>。上面代码中这是因为在<code>ES5</code>中，全局变量是挂载在顶层对象（浏览器是<code>window</code>）中。 事实上，并不是如此。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 非严格模式</span><br><span class="line">let name2 = &#x27;window2&#x27;;</span><br><span class="line">let doSth2 = function()&#123;</span><br><span class="line">    console.log(this === window);</span><br><span class="line">    console.log(this.name2);</span><br><span class="line">&#125;</span><br><span class="line">doSth2() // true, undefined</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个例子中<code>let</code>没有给顶层对象中（浏览器是window）添加属性，<code>window.name2和window.doSth</code>都是<code>undefined</code>。</p><p>严格模式中，普通函数中的<code>this</code>则表现不同，表现为<code>undefined</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 严格模式</span><br><span class="line">&#x27;use strict&#x27;</span><br><span class="line">var name = &#x27;window&#x27;;</span><br><span class="line">var doSth = function()&#123;</span><br><span class="line">    console.log(typeof this === &#x27;undefined&#x27;);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">doSth(); // true，// 报错，因为this是undefined</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>看过的《你不知道的<code>JavaScript</code>》上卷的读者，应该知道书上将这种叫做默认绑定。 对<code>call</code>，<code>apply</code>熟悉的读者会类比为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSth.call(undefined);</span><br><span class="line">doSth.apply(undefined);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>效果是一样的，<code>call</code>，<code>apply</code>作用之一就是用来修改函数中的<code>this</code>指向为第一个参数的。 第一个参数是<code>undefined</code>或者<code>null</code>，非严格模式下，是指向<code>window</code>。严格模式下，就是指向第一个参数。后文详细解释。<br> 经常有这类代码（回调函数），其实也是普通函数调用模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;若川&#x27;;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;, 0);</span><br><span class="line">// 语法</span><br><span class="line">setTimeout(fn | code, 0, arg1, arg2, ...)</span><br><span class="line">// 也可以是一串代码。也可以传递其他函数</span><br><span class="line">// 类比 setTimeout函数内部调用fn或者执行代码`code`。</span><br><span class="line">fn.call(undefined, arg1, arg2, ...);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>对象中的函数（方法）调用模式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;window&#x27;;</span><br><span class="line">var doSth = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var student = &#123;</span><br><span class="line">    name: &#x27;若川&#x27;,</span><br><span class="line">    doSth: doSth,</span><br><span class="line">    other: &#123;</span><br><span class="line">        name: &#x27;other&#x27;,</span><br><span class="line">        doSth: doSth,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">student.doSth(); // &#x27;若川&#x27;</span><br><span class="line">student.other.doSth(); // &#x27;other&#x27;</span><br><span class="line">// 用call类比则为：</span><br><span class="line">student.doSth.call(student);</span><br><span class="line">// 用call类比则为：</span><br><span class="line">student.other.doSth.call(student.other);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>但往往会有以下场景，把对象中的函数赋值成一个变量了。 这样其实又变成普通函数了，所以使用普通函数的规则（默认绑定）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var studentDoSth = student.doSth;</span><br><span class="line">studentDoSth(); // &#x27;window&#x27;</span><br><span class="line">// 用call类比则为：</span><br><span class="line">studentDoSth.call(undefined);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong><code>call、apply、bind</code> 调用模式</strong></p><p>上文提到<code>call</code>、<code>apply</code>，这里详细解读一下。先通过<code>MDN</code>认识下<code>call</code>和<code>apply</code> <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">MDN 文档：Function.prototype.call()</a><br> <strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>thisArg</strong><br> 在<code>fun</code>函数运行时指定的<code>this</code>值。需要注意的是，指定的<code>this</code>值并不一定是该函数执行时真正的<code>this</code>值，如果这个函数处于<strong>非严格模式</strong>下，则指定为<code>null</code>和<code>undefined</code>的<code>this</code>值会自动指向全局对象(浏览器中就是<code>window</code>对象)，同时值为原始值(数字，字符串，布尔值)的<code>this</code>会指向该原始值的自动包装对象。<br> <strong>arg1, arg2, …</strong><br> 指定的参数列表<br> <strong>返回值</strong><br> 返回值是你调用的方法的返回值，若该方法没有返回值，则返回<code>undefined</code>。<br> <code>apply</code>和<code>call</code>类似。只是参数不一样。它的参数是数组（或者类数组）。</p><p>根据参数<code>thisArg</code>的描述，可以知道，<code>call</code>就是改变函数中的<code>this</code>指向为<code>thisArg</code>，并且执行这个函数，这也就使<code>JS</code>灵活很多。严格模式下，<code>thisArg</code>是原始值是值类型，也就是原始值。不会被包装成对象。举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var doSth = function(name)&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(name);</span><br><span class="line">&#125;</span><br><span class="line">doSth.call(2, &#x27;若川&#x27;); // Number&#123;2&#125;, &#x27;若川&#x27;</span><br><span class="line">var doSth2 = function(name)&#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(name);</span><br><span class="line">&#125;</span><br><span class="line">doSth2.call(2, &#x27;若川&#x27;); // 2, &#x27;若川&#x27;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>虽然一般不会把<code>thisArg</code>参数写成值类型。但还是需要知道这个知识。 之前写过一篇文章：<a href="https://juejin.cn/post/6844903728147857415">面试官问：能否模拟实现<code>JS</code>的<code>call</code>和<code>apply</code>方法</a> 就是利用对象上的函数<code>this</code>指向这个对象，来模拟实现<code>call</code>和<code>apply</code>的。感兴趣的读者思考如何实现，再去看看笔者的实现。</p><p><code>bind</code>和<code>call</code>和<code>apply</code>类似，第一个参数也是修改<code>this</code>指向，只不过返回值是新函数，新函数也能当做构造函数（<code>new</code>）调用。 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">MDN Function.prototype.bind</a></p><blockquote><p><code>bind()</code>方法创建一个新的函数， 当这个新函数被调用时<code>this</code>键值为其提供的值，其参数列表前几项值为创建时指定的参数序列。</p></blockquote><p><strong>语法：</strong> fun.bind(thisArg[, arg1[, arg2[, …]]])<br> <strong>参数：</strong> <strong>thisArg</strong> 调用绑定函数时作为this参数传递给目标函数的值。 如果使用<code>new</code>运算符构造绑定函数，则忽略该值。当使用<code>bind</code>在<code>setTimeout</code>中创建一个函数（作为回调提供）时，作为<code>thisArg</code>传递的任何原始值都将转换为<code>object</code>。如果没有提供绑定的参数，则执行作用域的<code>this</code>被视为新函数的<code>thisArg</code>。 <strong>arg1, arg2, …</strong> 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 <strong>返回值</strong> 返回由指定的<code>this</code>值和初始化参数改造的原函数拷贝。</p><p><strong>构造函数调用模式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Student(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    console.log(this); // &#123;name: &#x27;若川&#x27;&#125;</span><br><span class="line">    // 相当于返回了</span><br><span class="line">    // return this;</span><br><span class="line">&#125;</span><br><span class="line">var result = new Student(&#x27;若川&#x27;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>使用<code>new</code>操作符调用函数，会自动执行以下步骤。</p><blockquote><ol><li>创建了一个全新的对象。</li><li>这个对象会被执行<code>[[Prototype]]</code>（也就是<code>__proto__</code>）链接。</li><li>生成的新对象会绑定到函数调用的<code>this</code>。</li><li>通过<code>new</code>创建的每个对象将最终被<code>[[Prototype]]</code>链接到这个函数的<code>prototype</code>对象上。</li><li>如果函数没有返回对象类型<code>Object</code>(包含<code>Functoin</code>, <code>Array</code>, <code>Date</code>, <code>RegExg</code>, <code>Error</code>)，那么<code>new</code>表达式中的函数调用会自动返回这个新的对象。</li></ol></blockquote><p>由此可以知道：<code>new</code>操作符调用时，<code>this</code>指向生成的新对象。 <strong>特别提醒一下，<code>new</code>调用时的返回值，如果没有显式返回对象或者函数，才是返回生成的新对象</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Student(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    // return function f()&#123;&#125;;</span><br><span class="line">    // return &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">var result = new Student(&#x27;若川&#x27;);</span><br><span class="line">console.log(result); &#123;name: &#x27;若川&#x27;&#125;</span><br><span class="line">// 如果返回函数f，则result是函数f，如果是对象&#123;&#125;，则result是对象&#123;&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>很多人或者文章都忽略了这一点，直接简单用<code>typeof</code>判断对象。虽然实际使用时不会显示返回，但面试官会问到。</p><hr><p><strong>总结</strong></p><p>如果要判断一个运行中的函数的this绑定，就需要找到这个函数的直接调用位置.找到之后就可以顺序应用下面这四条规则来判断this的指向</p><ol><li><strong>普通函数调用</strong>:在严格模式下绑定到<code>undefined</code>,否则绑定到全局对象</li><li><strong>构造函数形式调用</strong>:绑定到新创建的实例对象</li><li><strong>对象上的函数调用</strong>:帮到到那个对象</li><li><strong>call、apply、bind调用</strong>:在非严格模式下,this为函数传入的第一个参数,如果第一个参数为<code>null</code>或者<code>undefined</code>，<code>this</code>会指向全局对象(浏览器中就是window对象)</li></ol><p><strong>箭头函数的this</strong>:不会使用上文的四条标准的绑定规则,而是<strong>根据当前的词法作用域来决定this。</strong></p><p>箭头函数没有自己的this、super、argument和new.target绑定,所以<strong>必须通过查找作用域链来决定其值</strong>.<strong>如果箭头函数被非箭头函数包含,则this绑定的是最近一层非箭头函数的this,否则this的值会被设置位全局对象.</strong></p><hr><h4 id="2-call"><a href="#2-call" class="headerlink" title="2.call"></a>2.call</h4><blockquote><p>call()方法的作用是在使用<strong>一个指定的this值</strong>和<strong>若干个指定的参数值</strong>的前提下调用某个函数或方法</p></blockquote><p>举个栗子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>手写实现call方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.ts_call(obj,...args)&#123;</span><br><span class="line">    obj = obj || <span class="built_in">window</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(); <span class="comment">//创建一个唯一变量,防止属性名冲突</span></span><br><span class="line">    </span><br><span class="line">    obj[fn] = <span class="built_in">this</span>; <span class="comment">//将属性指定为目标函数</span></span><br><span class="line">    </span><br><span class="line">    obj[fn](...args);<span class="comment">//执行函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> obj[fn];<span class="comment">//执行后将这个属性删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我叫<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testobj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zzm&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">fn.cs_call(testobj2,<span class="number">18</span>)<span class="comment">//我叫zzm今年18岁了!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-apply"><a href="#3-apply" class="headerlink" title="3.apply"></a>3.apply</h4><blockquote><p>apply的方法与call类似,不同之处在于<strong>apply参数以数组的方式传递</strong>,所以call能实现的需求，用apply也同样可以</p></blockquote><p>手写实现apply方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.cs_apply(obj,arg)&#123;</span><br><span class="line">    obj = obj || <span class="built_in">window</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    </span><br><span class="line">    obj[fn] = <span class="built_in">this</span>;</span><br><span class="line">    </span><br><span class="line">    obj[fn](...args);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> obj[fn];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">age,hobby</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我叫<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>今年<span class="subst">$&#123;age&#125;</span>岁了我喜欢<span class="subst">$&#123;hobby&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testobj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zzm&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">fn.cs_apply(testobj2,[<span class="number">18</span>,<span class="string">&#x27;睡觉&#x27;</span>])<span class="comment">//我叫zzm今年18岁了我喜欢睡觉</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-bind"><a href="#4-bind" class="headerlink" title="4.bind"></a>4.bind</h4><blockquote><p>bind()函数会创建一个新函数(称之为绑定函数)</p></blockquote><ul><li>bind是ES5新增的一个方法</li><li>传参和call或apply类似</li><li>不会执行对应的函数，call或apply会自动执行对应的函数</li><li>返回对函数的引用</li></ul><p><strong>下面例子：</strong>当点击网页时，<code>EventClick</code>被触发执行，输出<code>JSLite.io p1 p2</code>, 说明<code>EventClick</code>中的<code>this</code>被<code>bind</code>改变成了<code>obj</code>对象。如果你将<code>EventClick.bind(obj,&#39;p1&#39;,&#39;p2&#39;)</code> 变成 <code>EventClick.call(obj,&#39;p1&#39;,&#39;p2&#39;)</code> 的话，页面会直接输出 <code>JSLite.io p1 p2</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;name:&#x27;JSLite.io&#x27;&#125;;</span><br><span class="line">/**</span><br><span class="line"> * 给document添加click事件监听，并绑定EventClick函数</span><br><span class="line"> * 通过bind方法设置EventClick的this为obj，并传递参数p1,p2</span><br><span class="line"> */</span><br><span class="line">document.addEventListener(&#x27;click&#x27;,EventClick.bind(obj,&#x27;p1&#x27;,&#x27;p2&#x27;),false);</span><br><span class="line">//当点击网页时触发并执行</span><br><span class="line">function EventClick(a,b)&#123;</span><br><span class="line">    console.log(</span><br><span class="line">            this.name, //JSLite.io</span><br><span class="line">            a, //p1</span><br><span class="line">            b  //p2</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">// JSLite.io p1 p2</span><br></pre></td></tr></table></figure><p>手写bind</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.cs_bind = <span class="function"><span class="keyword">function</span>(<span class="params">obj,...args</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    obj = obj || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    obj[fn] = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="function"><span class="keyword">function</span>(<span class="params">...innerArgs</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> <span class="keyword">instanceof</span> _this)&#123;<span class="comment">//当作构造函数使用</span></span><br><span class="line">            <span class="built_in">this</span>[fn] = _this;</span><br><span class="line">            <span class="built_in">this</span>[fn](...[...args,...innerArgs]);</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>[fn];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//没有当作构造函数使用</span></span><br><span class="line">            obj[fn](...[...args,...innerArgs])</span><br><span class="line">            <span class="keyword">delete</span> obj[fn];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.prototype = <span class="built_in">Object</span>.create(<span class="built_in">this</span>.prototype);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-原型-继承"><a href="#3-原型-继承" class="headerlink" title="3.原型/继承"></a>3.原型/继承</h3><h4 id="1-原型"><a href="#1-原型" class="headerlink" title="1.原型"></a>1.原型</h4><p><strong>原型链经典神图</strong></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131611904.png" alt="image-20220313161148825"></p><ul><li>function Foo 就是一个方法，比如JavaScript 中内置的 Array、String 等</li><li>function Object 就是一个 Object</li><li>function Function 就是 Function</li><li>以上都是 function，所以 <code>.__proto__</code>都是<code>Function.prototype</code></li><li>再次强调，String、Array、Number、Function、Object都是 function</li></ul><hr><p><strong>prototype的定义</strong></p><p>在规范里,prototype被定义为:<strong>给其他对象提供共享属性的对象</strong></p><p>也就是说prototype自己也是对象,只是被用来承担某个只能罢了</p><p><strong>prototype描述的是两个对象之间的某种关系(其中一个对象为另一个对象提供属性访问权限).所有对象都可以作为另一个对象的prototype来使用</strong></p><hr><p><strong>函数对象和普通对象</strong></p><p>在JavaScript中,<strong>万物皆对象</strong>,但是不同的对象是存在着差异性的.</p><p>在JavaScript中，我们将对象分为函数对象和普通对象,<strong>函数对象就是JavaScript用函数来模拟的类实现</strong>,<strong>Object</strong>和<strong>Function</strong>就是典型的函数对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> fun3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;console.log(name)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">const</span> obj3 = <span class="keyword">new</span> fun1();</span><br><span class="line"><span class="keyword">const</span> obj4 = <span class="keyword">new</span> <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fun1);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fun2);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fun3);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj1);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj2);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj3);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj4);<span class="comment">//object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码中，<code>obj1</code>，<code>obj2</code>，<code>obj3</code>，<code>obj4</code>都是普通对象，<code>fun1</code>，<code>fun2</code>，<code>fun3</code> 都是 <code>Function</code> 的实例，也就是函数对象。</p><p>总结:<strong>所有的Function的实例都是函数对象,其他的均为普通对象,包括Function实例的实例</strong></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131629020.webp" alt="img"></p><p><strong>JavaScript中万物皆对象,而对象皆出自构造函数</strong></p><p>对于<strong>Function</strong>对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">//true</span></span><br></pre></td></tr></table></figure><hr><p><strong>__ proto__</strong></p><p>首先我们需要明确:</p><ul><li><strong>__ proto__<strong>和</strong>constructor</strong>是<strong>对象</strong>独有的</li><li><strong>prototype</strong>属性是<strong>函数</strong>独有的</li></ul><p>但是在JavaScript中,函数也是一种特殊的对象,<strong>所以函数也拥有<code>__proto__</code>和 <code>constructor</code>属性</strong></p><p>结合上面我们介绍的 <code>Object</code> 和 <code>Function</code> 的关系，看一下代码和关系图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;…&#125;;</span><br><span class="line">let nealyang = new Person(); </span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131647800.webp" alt="__proto__"></p><p>再梳理上图关系之前，我们再来讲解下<code>__proto__</code>。</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131647353.webp" alt="img"></p><p>这里我们需要知道的是，<code>__proto__</code>是对象所独有的，并且<code>__proto__</code>是<strong>一个对象指向另一个对象</strong>，也就是他的原型对象。我们也可以理解为父类对象。它的作用就是当你在访问一个对象属性的时候，如果该对象内部不存在这个属性，那么就回去它的<code>__proto__</code>属性所指向的对象（父类对象）上查找，如果父类对象依旧不存在这个属性，那么就回去其父类的<code>__proto__</code>属性所指向的父类的父类上去查找。以此类推，知道找到 <code>null</code>。而这个查找的过程，也就构成了我们常说的<strong>原型链</strong>。</p><p><strong>原型链就是根据对象的__ proto __指向,一层一层连接起来的具有关联性的对象集合</strong></p><hr><p><strong>prototype</strong></p><p>prototype 被定义为：<strong>给其它对象提供共享属性的对象</strong>。<code>prototype</code> 自己也是对象，只是被用以承担某个职能罢了</p><p>所有对象都可以作为另一个对象的<strong>prototype</strong>使用</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131651653.webp" alt="img"></p><p><strong>任何函数在创建的时候，都会默认给该函数添加 <code>prototype</code> 属性.</strong></p><hr><p><strong>constructor</strong></p><p><strong>constructor</strong>属性也是对象所独有的,<strong>他是一个对象指向同一个函数，这个函数就是该对象的构造函数</strong></p><p>每个对象都有其对应的构造函数,它由本身或者继承而来.</p><p><strong>函数.prototype.constructor</strong>===<strong>该函数本身</strong></p><p><strong>constructor属性只有prototype对象才有</strong>,函数在创建的时候,JavaScript会同时创建一个该函数对应的prototype对象,<strong>而函数创建的对象.proto === 该函数.prototype</strong></p><p>通过函数创建的对象即使自己没有<code>constructor</code>属性，它也能通过<code>__proto__</code>找到对应的<code>constructor</code>，所以<strong>任何对象最终都可以找到其对应的构造函数。</strong></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131707239.webp" alt="img"></p><hr><p><strong>原型链</strong></p><p><strong>原型链就是根据对象的__ proto __指向,一层一层连接起来的具有关联性的对象集合</strong></p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131709481.webp" alt="img"></p><hr><p><strong>typeof</strong>&amp;&amp;<strong>instanceof</strong>原理</p><p><strong>typeof</strong></p><p>用于判断变量的类型,可以判断的类型有:<strong>number</strong>、<strong>undefined</strong>、<strong>String</strong>、<strong>Boolean</strong>、<strong>function</strong>、<strong>object</strong>、<strong>symbol</strong>，但是<strong>typeof在判断object时不能明确的告诉你属于哪一类object</strong></p><p>所以<strong>一般不用typeof来判断object的类型</strong></p><p>为什么<strong>typeof null</strong> 返回’<strong>object</strong>’？</p><p><strong>因为null代表的是空指针对象,所以typeof null 为object</strong></p><p>具体原因:在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 <code>null</code> 代表的是空指针（大多数平台下值为 0x00），因此，<code>null</code> 的类型标签是 0，<code>typeof null</code> 也因此返回 <code>&quot;object&quot;</code></p><hr><p><strong>instanceof</strong></p><p><code>instanceof</code> 运算符用来检测 <code>constructor.prototype</code> 是否存在于参数 <code>object</code> 的原型链上。与 <code>typeof</code> 方法不同的是，<code>instanceof</code> 方法要求开发者明确地确认对象为某特定类型。</p><p><strong>instanceof</strong>可以判断<strong>一个实例是否是其父类型或者祖先类型的实例。</strong></p><p><strong>instanceof</strong>是如何进行判断的?</p><ul><li>表达式**:A instanceof B**:如果B的显式原型(prototype)对象在A的原型链上,返回true,否则返回false</li></ul><p><strong>手写instanceof</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_instanceof</span>(<span class="params">child,father</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fp =  father.prototype   </span><br><span class="line">    <span class="keyword">let</span> cp = child.__proto__</span><br><span class="line">    <span class="keyword">while</span>(cp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cp.__proto__ === father.protype)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cp = cp.__proto__;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);<span class="comment">//false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);<span class="comment">//false </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Foo <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(Foo <span class="keyword">instanceof</span> Foo);<span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>为什么 <code>Object</code> 和 <code>Function</code> <code>instanceof</code> 自己等于 <code>true</code>，而其他类 <code>instanceof</code> 自己却又不等于 <code>true</code> 呢？如何解释？</strong></p><ul><li><p><code>Object instanceof Object</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了方便表述，首先区分左侧表达式和右侧表达式</span></span><br><span class="line">ObjectL = <span class="built_in">Object</span>, ObjectR = <span class="built_in">Object</span>; </span><br><span class="line"><span class="comment">// 下面根据规范逐步推演</span></span><br><span class="line">O = ObjectR.prototype = <span class="built_in">Object</span>.prototype </span><br><span class="line">L = ObjectL.__proto__ = <span class="built_in">Function</span>.prototype </span><br><span class="line"><span class="comment">// 第一次判断</span></span><br><span class="line">O != L </span><br><span class="line"><span class="comment">// 循环查找 L 是否还有 __proto__ </span></span><br><span class="line">L = <span class="built_in">Function</span>.prototype.__proto__ = <span class="built_in">Object</span>.prototype </span><br><span class="line"><span class="comment">// 第二次判断</span></span><br><span class="line">O == L </span><br><span class="line"><span class="comment">// 返回 true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>Function instanceof Function</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了方便表述，首先区分左侧表达式和右侧表达式</span></span><br><span class="line">FunctionL = <span class="built_in">Function</span>, FunctionR = <span class="built_in">Function</span>; </span><br><span class="line"><span class="comment">// 下面根据规范逐步推演</span></span><br><span class="line">O = FunctionR.prototype = <span class="built_in">Function</span>.prototype </span><br><span class="line">L = FunctionL.__proto__ = <span class="built_in">Function</span>.prototype </span><br><span class="line"><span class="comment">// 第一次判断</span></span><br><span class="line">O == L </span><br><span class="line"><span class="comment">// 返回 true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>Foo instanceof Foo</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了方便表述，首先区分左侧表达式和右侧表达式</span></span><br><span class="line">FooL = Foo, FooR = Foo; </span><br><span class="line"><span class="comment">// 下面根据规范逐步推演</span></span><br><span class="line">O = FooR.prototype = Foo.prototype </span><br><span class="line">L = FooL.__proto__ = <span class="built_in">Function</span>.prototype </span><br><span class="line"><span class="comment">// 第一次判断</span></span><br><span class="line">O != L </span><br><span class="line"><span class="comment">// 循环再次查找 L 是否还有 __proto__ </span></span><br><span class="line">L = <span class="built_in">Function</span>.prototype.__proto__ = <span class="built_in">Object</span>.prototype </span><br><span class="line"><span class="comment">// 第二次判断</span></span><br><span class="line">O != L </span><br><span class="line"><span class="comment">// 再次循环查找 L 是否还有 __proto__ </span></span><br><span class="line">L = <span class="built_in">Object</span>.prototype.__proto__ = <span class="literal">null</span> </span><br><span class="line"><span class="comment">// 第三次判断</span></span><br><span class="line">L == <span class="literal">null</span> </span><br><span class="line"><span class="comment">// 返回 false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><hr><hr><h4 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h4><p>在JavaScript中,有两类原型继承的方式:<strong>显式继承</strong>和<strong>隐式继承</strong></p><hr><h5 id="new"><a href="#new" class="headerlink" title="new"></a><strong>new</strong></h5><p><strong>new用来创建构造函数的实例对象</strong></p><p><strong>手写new</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn,...args</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    obj.__proto__ = fn.prototype;<span class="comment">//将obj的__proto__赋值为fn的prototype</span></span><br><span class="line">    fn.apply(obj,args);<span class="comment">//将构造函数的this指向这个对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h5 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a><strong>类式继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.superValue = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.superValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line"></span><br><span class="line">SubClass.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> SubClass();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( instance  <span class="keyword">instanceof</span> SuperClass);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log( instance  <span class="keyword">instanceof</span> SubClass);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(SubClass <span class="keyword">instanceof</span> SuperClass);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>虽然实现起来清晰简洁，但是这种继承方式有两个缺点：</p><ul><li>由于子类通过其原型prototype对父类实例化，继承了父类，所以说父类中如果共有属性是引用类型，就会在子类中被所有的实例所共享，因此一个子类的实例更改子类原型从父类构造函数中继承的共有属性就会直接影响到其他的子类</li><li>由于子类实现的继承是靠其原型prototype对父类进行实例化实现的，因此在创建父类的时候，是无法向父类传递参数的。因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化</li></ul><hr><h5 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a><strong>构造函数继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.books = [<span class="string">&#x27;js&#x27;</span>,<span class="string">&#x27;css&#x27;</span>];</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.showBooks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.books);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    SuperClass.call(<span class="built_in">this</span>,id)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> SubClass(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="keyword">new</span> SubClass(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">instance1.books.push(<span class="string">&#x27;html&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1)</span><br><span class="line"><span class="built_in">console</span>.log(instance2)</span><br><span class="line">instance1.showBooks();<span class="comment">//TypeError</span></span><br></pre></td></tr></table></figure><p><code>SuperClass.call(this,id)</code>当然就是构造函数继承的核心语句了.由于父类中给this绑定属性，因此子类自然也就继承父类的共有属性。由于这种类型的继承没有涉及到原型<code>prototype</code>，所以父类的原型方法自然不会被子类继承，而如果想被子类继承，就必须放到构造函数中，这样创建出来的每一个实例都会单独的拥有一份而不能共用，这样就违背了代码复用的原则，所以综合上述两种，我们提出了组合式继承方法</p><hr><h5 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a><strong>组合式继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name; </span><br><span class="line">  <span class="built_in">this</span>.books = [<span class="string">&#x27;Js&#x27;</span>,<span class="string">&#x27;CSS&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.getBooks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.books);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name,time</span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="built_in">this</span>,name);</span><br><span class="line">  <span class="built_in">this</span>.time = time;</span><br><span class="line">&#125;</span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line"></span><br><span class="line">SubClass.prototype.getTime = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我们就解决了之前说到的一些问题，但是是不是从代码看，还是有些不爽呢？至少这个<code>SuperClass</code>的构造函数执行了两遍就感觉非常的不妥.</p><h5 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a><strong>原型式继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//声明一个过渡对象</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">  <span class="comment">//过渡对象的原型继承父对象</span></span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="comment">//返回过渡对象的实例，该对象的原型继承了父对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型式继承大致的实现方式如上，是不是想到了我们<code>new</code>关键字模拟的实现？</p><p>其实这种方式和类式继承非常的相似，他只是对类式继承的一个封装，其中的过渡对象就相当于类式继承的子类，只不过在原型继承中作为一个普通的过渡对象存在，目的是为了创建要返回的新的实例对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">    name:&#x27;js book&#x27;,</span><br><span class="line">    likeBook:[&#x27;css Book&#x27;,&#x27;html book&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">var newBook = inheritObject(book);</span><br><span class="line">newBook.name = &#x27;ajax book&#x27;;</span><br><span class="line">newBook.likeBook.push(&#x27;react book&#x27;);</span><br><span class="line">var otherBook = inheritObject(book);</span><br><span class="line">otherBook.name = &#x27;canvas book&#x27;;</span><br><span class="line">otherBook.likeBook.push(&#x27;node book&#x27;);</span><br><span class="line">console.log(newBook,otherBook);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如上代码我们可以看出，原型式继承和类式继承一个样子，对于引用类型的变量，还是存在子类实例共享的情况。</p><p>所以，我们还有下面的寄生式继承</p><hr><h5 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a><strong>寄生式继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;js book&#x27;</span>,</span><br><span class="line">    <span class="attr">likeBook</span>:[<span class="string">&#x27;html book&#x27;</span>,<span class="string">&#x27;css book&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBook</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//通过原型方式创建新的对象</span></span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> inheritObject(obj);</span><br><span class="line">  <span class="comment">// 拓展新对象</span></span><br><span class="line">  o.getName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回拓展后的新对象</span></span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实寄生式继承就是对原型继承的拓展，一个二次封装的过程，这样新创建的对象不仅仅有父类的属性和方法，还新增了别的属性和方法。</p><h5 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a><strong>寄生组合式继承</strong></h5><p>回到之前的组合式继承，那时候我们将类式继承和构造函数继承组合使用，但是存在的问题就是子类不是父类的实例，而子类的原型是父类的实例，所以才有了寄生组合式继承</p><p>而寄生组合式继承是寄生式继承和构造函数继承的组合。但是这里寄生式继承有些特殊，这里他处理不是对象，而是类的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//声明一个过渡对象</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">  <span class="comment">//过渡对象的原型继承父对象</span></span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="comment">//返回过渡对象的实例，该对象的原型继承了父对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subClass,superClass</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 复制一份父类的原型副本到变量中</span></span><br><span class="line">  <span class="keyword">var</span> p = inheritObject(superClass.prototype);</span><br><span class="line">  <span class="comment">// 修正因为重写子类的原型导致子类的constructor属性被修改</span></span><br><span class="line">  p.constructor = subClass;</span><br><span class="line">  <span class="comment">// 设置子类原型</span></span><br><span class="line">  subClass.prototype = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>组合式继承中，通过构造函数继承的属性和方法都是没有问题的，所以这里我们主要探究通过寄生式继承重新继承父类的原型。</p><p>我们需要继承的仅仅是父类的原型，不用去调用父类的构造函数。换句话说，在构造函数继承中，我们已经调用了父类的构造函数。因此我们需要的就是父类的原型对象的一个副本，而这个副本我们可以通过原型继承拿到，但是这么直接赋值给子类会有问题，因为对父类原型对象复制得到的复制对象p中的<code>constructor</code>属性指向的不是<code>subClass</code>子类对象，因此在寄生式继承中要对复制对象p做一次增强，修复起<code>constructor</code>属性指向性不正确的问题，最后将得到的复制对象p赋值给子类原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.books=[<span class="string">&#x27;js book&#x27;</span>,<span class="string">&#x27;css book&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name,time</span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="built_in">this</span>,name);</span><br><span class="line">  <span class="built_in">this</span>.time = time;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubClass,SuperClass);</span><br><span class="line">SubClass.prototype.getTime = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubClass(<span class="string">&#x27;React&#x27;</span>,<span class="string">&#x27;2017/11/11&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubClass(<span class="string">&#x27;Js&#x27;</span>,<span class="string">&#x27;2018/22/33&#x27;</span>);</span><br><span class="line"></span><br><span class="line">instance1.books.push(<span class="string">&#x27;test book&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance1.books,instance2.books);</span><br><span class="line">instance2.getName();</span><br><span class="line">instance2.getTime();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131828871.webp" alt="img"></p><p>这种方式继承其实如上图所示，其中最大的改变就是子类原型中的处理，被赋予父类原型中的一个引用，这是一个对象，因此有一点你需要注意，就是子类在想添加原型方法必须通过prototype.来添加，否则直接赋予对象就会覆盖从父类原型继承的对象了.</p><h2 id="4-promise"><a href="#4-promise" class="headerlink" title="4.promise"></a>4.promise</h2><h4 id="1-什么是promise-它用来解决什么问题"><a href="#1-什么是promise-它用来解决什么问题" class="headerlink" title="1.什么是promise?它用来解决什么问题?"></a>1.<strong>什么是promise?它用来解决什么问题?</strong></h4><blockquote><p>Promise是异步编程的一种解决方案:从语法上讲，promise是一个对象,可以通过它获取异步操作的消息；从本意上讲，他是承诺，承诺他过一段时间会给你一个结果。promise有三种状态:<strong>pending</strong>(等待态)，<strong>fulfiled</strong>(成功态),<strong>rejected</strong>(失败态);<strong>状态一旦改变，就不会再改变</strong>(也就是说promise的操作是不可逆的)，<strong>创造promise实例后，他会立即执行</strong></p></blockquote><p>promise是用来解决两个问题:</p><ul><li><strong>回调地狱</strong>，减少多层回调嵌套</li><li><strong>异步执行</strong>(但是不能说promise是异步的)</li></ul><hr><h4 id="2-promise用法"><a href="#2-promise用法" class="headerlink" title="2.promise用法"></a>2.<strong>promise用法</strong></h4><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132032800.png" alt="image-20220313203224725"></p><h5 id="创建promise对象"><a href="#创建promise对象" class="headerlink" title="创建promise对象"></a><strong>创建promise对象</strong></h5><p>promise是一个<strong>构造函数</strong>，可以通过<strong>new</strong>来创建实例对象</p><p>Promise的构造函数接收<strong>一个参数</strong>:函数,并且这个函数需要传入<strong>两个参数</strong>:</p><ul><li><strong>resolve</strong>:异步操作执行成功后的回调函数</li><li><strong>reject</strong>:异步操作执行失败后的回调函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//做一些异步操作</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;执行完成&#x27;</span>);</span><br><span class="line">        resolve(<span class="string">&#x27;我是成功！！&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h5 id="then链式调用"><a href="#then链式调用" class="headerlink" title="then链式调用"></a><strong>then链式调用</strong></h5><p>promise可以通过链式调用来减少多层回调嵌套</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,rehect</span>) =&gt;</span>&#123;</span><br><span class="line">     resolve(<span class="string">&#x27;ok&#x27;</span>);          </span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h5 id="reject的用法"><a href="#reject的用法" class="headerlink" title="reject的用法"></a><strong>reject的用法</strong></h5><p>把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//做一些异步操作</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">10</span>); <span class="comment">//生成1-10的随机数</span></span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">5</span>)&#123;</span><br><span class="line">            resolve(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            reject(<span class="string">&#x27;数字太大了&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>,data);</span><br><span class="line">    &#125;,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected&#x27;</span>,err);</span><br><span class="line">    &#125;</span><br><span class="line">); </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132043346.webp" alt="img">或者<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16377e4fd8619228~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><hr><h5 id="catch的用法"><a href="#catch的用法" class="headerlink" title="catch的用法"></a><strong>catch的用法</strong></h5><p>catch的作用与then的第二个参数类似,用于捕获失败的回调,不过与后者不同的是，在链式调用时，如果代码出错了，他不会报错使js执行停止，而是会进入到catch方法中,并捕获到异常</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>,data);</span><br><span class="line">    <span class="built_in">console</span>.log(somedata); <span class="comment">//此处的somedata未定义</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;rejected&#x27;</span>,err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：</p><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132046474.webp" alt="img"></p><p>也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能</p><hr><h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a><strong>Promise.all()</strong></h5><p><strong>用法</strong>:接受一个<strong>数组</strong>参数，里面的值最终都返回Promise对象</p><p><strong>特点</strong>:谁执行<strong>慢</strong>,以谁为准执行回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">let</span> Promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">let</span> Promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([Promise1, Promise2, Promise3])</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="title">funciton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 三个都成功则成功  </span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 只要有失败，则失败 </span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>应用场景:<em>一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</em></p><hr><h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a><strong>Promise.race()</strong></h5><p><strong>用法</strong>:接受一个数组参数,里面的值最终都返回Promise对象</p><p><strong>特点</strong>:谁执行<strong>快</strong>，以谁为准执行回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// resolve(1);</span></span><br><span class="line">    reject(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([promise1,promise2,promise3])</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;data&quot;</span>,data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;err&quot;</span>,err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h5 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a><strong>Promise.any()</strong></h5><p><strong>注意</strong>:<strong>Promise.any()尚未被所有浏览器所支持</strong>,node环境下不能使用这个API</p><p><strong>用法</strong>:接受一个数组参数,里面的值最终都返回Promise对象</p><p><strong>特点</strong>:只要有一个promise执行成功,那么就返回那个成功的promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// resolve(1);</span></span><br><span class="line">    reject(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.any([promise1,promise2,promise3])</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;data&quot;</span>,data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;err&quot;</span>,err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端知识杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTML </tag>
            
            <tag> Http </tag>
            
            <tag> CSS </tag>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题整理</title>
      <link href="/2022/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2022/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、CSS问题"><a href="#一、CSS问题" class="headerlink" title="一、CSS问题"></a>一、CSS问题</h1><h4 id="1-flex布局"><a href="#1-flex布局" class="headerlink" title="1.flex布局"></a>1.flex布局</h4><blockquote><p>display:flex; 在父元素设置，子元素受弹性盒影响，默认排成一行，如果超出一行，按比例压缩 flex:1; 子元素设置，设置子元素如何分配父元素的空间，flex:1,子元素宽度占满整个父元素align-items:center 定义子元素在父容器中的对齐方式，center 垂直居中justify-content:center 设置子元素在父元素中居中，前提是子元素没有把父元素占满，让子元素水平居中。</p></blockquote><h4 id="2-css3的新特性"><a href="#2-css3的新特性" class="headerlink" title="2.css3的新特性"></a>2.css3的新特性</h4><blockquote><p>transtion transition-property 规定设置过渡效果的 CSS 属性的名称。</p></blockquote><blockquote><p>transition-duration 规定完成过渡效果需要多少秒或毫秒。</p></blockquote><blockquote><p>transition-timing-function 规定速度效果的速度曲线。</p></blockquote><blockquote><p>transition-delay 定义过渡效果何时开始。</p></blockquote><blockquote><p>animation属性可以像Flash制作动画一样，通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果。</p></blockquote><blockquote><p>ainimation实现动画效果主要由两部分组成：</p></blockquote><blockquote><p>通过类似Flash动画中的帧来声明一个动画；</p></blockquote><blockquote><p>在animation属性中调用关键帧声明的动画。</p></blockquote><blockquote><p>translate 3D建模效果</p></blockquote><h4 id="3-img中alt和title的区别"><a href="#3-img中alt和title的区别" class="headerlink" title="3.img中alt和title的区别"></a>3.img中alt和title的区别</h4><blockquote><p>图片中的 alt属性是在图片不能正常显示时出现的文本提示。alt有利于SEO优化</p></blockquote><blockquote><p>图片中的 title属性是在鼠标在移动到元素上的文本提示。</p></blockquote><h4 id="4-用纯CSS创建一个三角形"><a href="#4-用纯CSS创建一个三角形" class="headerlink" title="4.用纯CSS创建一个三角形"></a>4.用纯CSS创建一个三角形</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: 0;</span><br><span class="line">        height: 0;</span><br><span class="line">        border-top: 40px solid transparent;</span><br><span class="line">        border-left: 40px solid transparent;</span><br><span class="line">        border-right: 40px solid transparent;</span><br><span class="line">        border-bottom: 40px solid #ff0000;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="5-如何理解CSS的盒子模型？"><a href="#5-如何理解CSS的盒子模型？" class="headerlink" title="5.如何理解CSS的盒子模型？"></a>5.如何理解CSS的盒子模型？</h4><blockquote><p>标准盒子模型：宽度=内容的宽度（content）+ border + padding</p></blockquote><blockquote><p>低版本IE盒子模型：宽度=内容宽度（content+border+padding)</p></blockquote><h4 id="6-如何让一个div水平居中"><a href="#6-如何让一个div水平居中" class="headerlink" title="6.如何让一个div水平居中"></a>6.如何让一个div水平居中</h4><blockquote><p>已知宽度，block元素 ，添加添加margin:0 auto属性。</p></blockquote><blockquote><p>已知宽度，绝对定位的居中 ，上下左右都为0，margin:auto</p></blockquote><h4 id="7-如何让一个div水平垂直居中"><a href="#7-如何让一个div水平垂直居中" class="headerlink" title="7.如何让一个div水平垂直居中"></a>7.如何让一个div水平垂直居中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">position: relative / fixed; /* 相对定位或绝对定位均可 */</span><br><span class="line">width:500px;</span><br><span class="line">height:300px;</span><br><span class="line">top: 50%;</span><br><span class="line">left: 50%;</span><br><span class="line">margin-top:-150px;</span><br><span class="line">margin-left:-250px;</span><br><span class="line"> 外边距为自身宽高的一半 */</span><br><span class="line">background-color: pink; /* 方便看效果 */</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">display: flex;</span><br><span class="line">align-items: center; /* 垂直居中 */</span><br><span class="line">justify-content: center; /* 水平居中 */</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">.container div &#123;</span><br><span class="line">width: 100px; /* 可省 */</span><br><span class="line">height: 100px; /* 可省 */</span><br><span class="line">background-color: pink; /* 方便看效果 */</span><br><span class="line">&#125;  </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="8-如何清除浮动？"><a href="#8-如何清除浮动？" class="headerlink" title="8.如何清除浮动？"></a>8.如何清除浮动？</h4><blockquote><p>clear清除浮动（添加空div法）在浮动元素下方添加空div,并给该元素写css样式 {clear:both;height:0;overflow:hidden;}</p></blockquote><blockquote><p>给浮动元素父级设置高度</p></blockquote><blockquote><p>父级同时浮动（需要给父级同级元素添加浮动）</p></blockquote><blockquote><p>父级设置成inline-block，其margin: 0 auto居中方式失效</p></blockquote><blockquote><p>给父级添加overflow:hidden 清除浮动方法</p></blockquote><blockquote><p>万能清除法 after伪类 清浮动（现在主流方法，推荐使用）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">float_div:after&#123;</span><br><span class="line">content:&quot;.&quot;;</span><br><span class="line">clear:both;</span><br><span class="line">display:block;</span><br><span class="line">height:0;</span><br><span class="line">overflow:hidden;</span><br><span class="line">visibility:hidden;</span><br><span class="line">&#125;</span><br><span class="line">.float_div&#123;</span><br><span class="line">zoom:1</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="9-css3实现三栏布局，左右固定，中间自适应"><a href="#9-css3实现三栏布局，左右固定，中间自适应" class="headerlink" title="9.css3实现三栏布局，左右固定，中间自适应"></a>9.css3实现三栏布局，左右固定，中间自适应</h4><blockquote><p>圣杯布局/双飞翼布局</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> &lt;style&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        .middle,</span><br><span class="line">        .left,</span><br><span class="line">        .right &#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            float: left;</span><br><span class="line">            min-height: 130px;</span><br><span class="line">        &#125;</span><br><span class="line">        .container &#123;</span><br><span class="line">            padding: 0 220px 0 200px;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">        .left &#123;</span><br><span class="line">            margin-left: -100%;</span><br><span class="line">            left: -200px;</span><br><span class="line">            width: 200px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line">        .right &#123;</span><br><span class="line">            margin-left: -220px;</span><br><span class="line">            right: -220px;</span><br><span class="line">            width: 220px;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line">        .middle &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            background: blue;</span><br><span class="line">            word-break: break-all;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&#x27;container&#x27;&gt;</span><br><span class="line">        &lt;div class=&#x27;middle&#x27;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&#x27;left&#x27;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&#x27;right&#x27;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="10-display-none-和-visibility-hidden的区别"><a href="#10-display-none-和-visibility-hidden的区别" class="headerlink" title="10.display:none 和 visibility: hidden的区别"></a>10.display:none 和 visibility: hidden的区别</h4><blockquote><p>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</p></blockquote><blockquote><p>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p></blockquote><h4 id="11-CSS中-link-和-import-的区别是？"><a href="#11-CSS中-link-和-import-的区别是？" class="headerlink" title="11.CSS中 link 和@import 的区别是？"></a>11.CSS中 link 和@import 的区别是？</h4><blockquote><p>link属于HTML标签，而@import是CSS提供的页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载</p></blockquote><blockquote><p>import只在IE5以上才能识别，而link是HTML标签，无兼容问题</p></blockquote><blockquote><p>link方式的样式的权重 高于@import的权重.</p></blockquote><h4 id="12-position的absolute与fixed共同点与不同点"><a href="#12-position的absolute与fixed共同点与不同点" class="headerlink" title="12.position的absolute与fixed共同点与不同点"></a>12.position的absolute与fixed共同点与不同点</h4><blockquote><p>共同点： 改变行内元素的呈现方式，display被置为block 让元素脱离普通流，不占据空间 默认会覆盖到非定位元素上</p></blockquote><blockquote><p>不同点： absolute的”根元素“是可以设置的 fixed的”根元素“固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。</p></blockquote><h4 id="13-transition和animation的区别"><a href="#13-transition和animation的区别" class="headerlink" title="13..transition和animation的区别"></a>13..transition和animation的区别</h4><blockquote><p>Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性， 而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from …. to，而animation可以一帧一帧的。</p></blockquote><blockquote><p>transition 规定动画的名字  规定完成过渡效果需要多少秒或毫秒  规定速度效果  定义过渡效果何时开始 animation  指定要绑定到选择器的关键帧的名称</p></blockquote><h4 id="14-CSS优先级"><a href="#14-CSS优先级" class="headerlink" title="14.CSS优先级"></a>14.CSS优先级</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">不同级别：总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</span><br><span class="line">1.属性后面加!import 会覆盖页面内任何位置定义的元素样式</span><br><span class="line">2.作为style属性写在元素内的样式</span><br><span class="line">3.id选择器</span><br><span class="line">4.类选择器</span><br><span class="line">5.标签选择器</span><br><span class="line">6.通配符选择器（*）</span><br><span class="line">7.浏览器自定义或继承</span><br><span class="line">**同一级别：后写的会覆盖先写的**</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>css选择器的解析原则：选择器定位DOM元素是从右往左的方向，这样可以尽早的过滤掉一些不必要的样式规则和元素</p></blockquote><h4 id="15-雪碧图："><a href="#15-雪碧图：" class="headerlink" title="15.雪碧图："></a>15.雪碧图：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        多个图片集成在一个图片中的图</span><br><span class="line">使用雪碧图可以减少网络请求的次数，加快允许的速度</span><br><span class="line">通过background-position，去定位图片在屏幕的哪个位置</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h1 id="二、JS问题"><a href="#二、JS问题" class="headerlink" title="二、JS问题"></a>二、JS问题</h1><h4 id="1-typeof和instance-of-检测数据类型有什么区别？"><a href="#1-typeof和instance-of-检测数据类型有什么区别？" class="headerlink" title="1.typeof和instance of 检测数据类型有什么区别？"></a>1.typeof和instance of 检测数据类型有什么区别？</h4><blockquote><p>相同点： 都常用来判断一个变量是否为空，或者是什么类型的。</p></blockquote><blockquote><p>不同点： typeof        返回值是一个字符串，用来说明变量的数据类型 instanceof        用于判断一个变量是否属于某个对象的实例.</p></blockquote><h4 id="16-使元素消失的方法"><a href="#16-使元素消失的方法" class="headerlink" title="16.使元素消失的方法"></a>16.使元素消失的方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">visibility:hidden、display:none、z-index=-1、opacity：0</span><br><span class="line">1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发</span><br><span class="line">2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件</span><br><span class="line">3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="谈一谈深克隆和浅克隆？"><a href="#谈一谈深克隆和浅克隆？" class="headerlink" title=".谈一谈深克隆和浅克隆？"></a>.谈一谈深克隆和浅克隆？</h4><blockquote><p>浅克隆: 只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。</p></blockquote><blockquote><p>深克隆： 创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。 JSON.parse、JSON.stringify()</p></blockquote><h4 id="3-es6的新特性都有哪些？"><a href="#3-es6的新特性都有哪些？" class="headerlink" title="3.es6的新特性都有哪些？"></a>3.es6的新特性都有哪些？</h4><blockquote><p>let定义块级作用域变量 没有变量的提升，必须先声明后使用 let声明的变量，不能与前面的let，var，conset声明的变量重名</p></blockquote><blockquote><p>const 定义只读变量 const声明变量的同时必须赋值，const声明的变量必须初始化，一旦初始化完毕就不允许修改 const声明变量也是一个块级作用域变量 const声明的变量没有“变量的提升”，必须先声明后使用 const声明的变量不能与前面的let， var ， const声明的变量重 const定义的对象\数组中的属性值可以修改,基础数据类型不可以</p></blockquote><blockquote><p>ES6可以给形参函数设置默认值</p></blockquote><blockquote><p>在数组之前加上三个点（…）展开运算符</p></blockquote><blockquote><p>数组的解构赋值、对象的解构赋值</p></blockquote><blockquote><p>箭头函数的特点 箭头函数相当于匿名函数，是不能作为构造函数的，不能被new 箭头函数没有arguments实参集合,取而代之用…剩余运算符解决 箭头函数没有自己的this。他的this是继承当前上下文中的this 箭头函数没有函数原型 箭头函数不能当做Generator函数，不能使用yield关键字 不能使用call、apply、bind改变箭头函数中this指向 Set数据结构，数组去重</p></blockquote><h4 id="4-和-区别是什么？"><a href="#4-和-区别是什么？" class="headerlink" title="4.==和===区别是什么？"></a>4.==和===区别是什么？</h4><blockquote><p>=赋值</p></blockquote><blockquote><p>==返回一个布尔值；相等返回true，不相等返回false； 允许不同数据类型之间的比较； 如果是不同类型的数据进行，会默认进行数据类型之间的转换； 如果是对象数据类型的比较，比较的是空间地址</p></blockquote><blockquote><p>=== 只要数据类型不一样，就返回false；</p></blockquote><h4 id="5-常见的设计模式有哪些？"><a href="#5-常见的设计模式有哪些？" class="headerlink" title="5.常见的设计模式有哪些？"></a>5.常见的设计模式有哪些？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、js工厂模式</span><br><span class="line">2、js构造函数模式</span><br><span class="line">3、js原型模式</span><br><span class="line">4、构造函数+原型的js混合模式</span><br><span class="line">5、构造函数+原型的动态原型模式</span><br><span class="line">6、观察者模式</span><br><span class="line">7、发布订阅模式</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="6-call-bind-apply-的区别？"><a href="#6-call-bind-apply-的区别？" class="headerlink" title="6.call bind apply 的区别？"></a>6.call bind apply 的区别？</h4><blockquote><p>call() 和apply()的第一个参数相同，就是指定的对象。这个对象就是该函数的执行上下文。</p></blockquote><blockquote><p>call()和apply()的区别就在于，两者之间的参数。</p></blockquote><blockquote><p>call()在第一个参数之后的 后续所有参数就是传入该函数的值。</p></blockquote><blockquote><p>apply() 只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。 bind() 方法和前两者不同在于： bind() 方法会返回执行上下文被改变的函数而不会立即执行，而前两者是    直接执行该函数。他的参数和call()相同。</p></blockquote><h4 id="7-js继承方式有哪些？"><a href="#7-js继承方式有哪些？" class="headerlink" title="7.js继承方式有哪些？"></a>7.js继承方式有哪些？</h4><blockquote><p>原型链继承 核心： 将父类的实例作为子类的原型</p></blockquote><blockquote><p>构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类</p></blockquote><blockquote><p>实例继承 核心：为父类实例添加新特性，作为子类实例返回</p></blockquote><blockquote><p>拷贝继承</p></blockquote><blockquote><p>组合继承 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现    函数复用</p></blockquote><blockquote><p>寄生组合继承 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实    例方法/属性，避免的组合继承的缺点</p></blockquote><h4 id="8-你怎样看待闭包？"><a href="#8-你怎样看待闭包？" class="headerlink" title="8.你怎样看待闭包？"></a>8.你怎样看待闭包？</h4><blockquote><p>个人感觉，简单来说闭包就是在函数里面声明函数，本质上说就是在函数内部和函数外部搭建起一座桥梁，使得子函数可以访问父函数中所有的局部变量，但是反之不可以，这只是闭包的作用之一，另一个作用，则是保护变量不受外界污染，使其一直存在内存中，在工作中我们还是少使用闭包的好，因为闭包太消耗内存，不到万不得已的时候尽量不使用。</p></blockquote><h4 id="9-你是如何理解原型和原型链的？"><a href="#9-你是如何理解原型和原型链的？" class="headerlink" title="9.你是如何理解原型和原型链的？"></a>9.你是如何理解原型和原型链的？</h4><blockquote><p>把所有的对象共用的属性全部放在堆内存的一个对象（共用属性组成的对象），然后让每一个对象的 __proto__存储这个「共用属性组成的对象」的地址。而这个共用属性就是原型，原型出现的目的就是为了减少不必要的内存消耗。而原型链就是对象通过__proto__向当前实例所属类的原型上查找属性或方法的机制，如果找到Object的原型上还是没有找到想要的属性或者是方法则查找结束，最终会返回undefined</p></blockquote><h4 id="10-浏览器渲染的主要流程是什么"><a href="#10-浏览器渲染的主要流程是什么" class="headerlink" title="10.浏览器渲染的主要流程是什么?"></a>10.浏览器渲染的主要流程是什么?</h4><blockquote><p>将html代码按照深度优先遍历来生成DOM树。 css文件下载完后也会进行渲染，生成相应的CSSOM。 当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。 接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。 最后，通过Painting环节将所有的节点内容呈现到屏幕上。</p></blockquote><h4 id="11-从输入url地址到页面相应都发生了什么？"><a href="#11-从输入url地址到页面相应都发生了什么？" class="headerlink" title="11.从输入url地址到页面相应都发生了什么？"></a>11.从输入url地址到页面相应都发生了什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、浏览器的地址栏输入URL并按下回车。2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。3、DNS解析URL对应的IP。4、根据IP建立TCP连接（三次握手）。5、HTTP发起请求。6、服务器处理请求，浏览器接收HTTP响应。7、渲染页面，构建DOM树。8、关闭TCP连接（四次挥手）复制代码</span><br></pre></td></tr></table></figure><h4 id="12-session、cookie、localStorage的区别"><a href="#12-session、cookie、localStorage的区别" class="headerlink" title="12.session、cookie、localStorage的区别"></a>12.session、cookie、localStorage的区别</h4><blockquote><p>相同点 都是保存在浏览器端，且同源的。</p></blockquote><blockquote><p>不同点</p></blockquote><ul><li>cookie数据始终在同源的http请求中携带，即cookie在浏览器和服务器间来回传递。</li><li>而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li><li>cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。 存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据。</li><li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；</li><li>localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；</li><li>cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</li><li>localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li></ul><h4 id="13-js中跨域方法"><a href="#13-js中跨域方法" class="headerlink" title="13.js中跨域方法"></a>13.js中跨域方法</h4><blockquote><p>同源策略（协议+端口号+域名要相同）</p></blockquote><blockquote><p>1、jsonp跨域(只能解决get） 原理：动态创建一个script标签。利用script标签的src属性不受同源策略限制，因为所有的src属性和href属性都不受同源策略的限制，可以请求第三方服务器资源内容</p><blockquote><p>步骤： 1).去创建一个script标签 2).script的src属性设置接口地址 3).接口参数，必须要带一个自定义函数名，要不然后台无法返回数据 4).通过定义函数名去接受返回的数据</p></blockquote></blockquote><blockquote><p>2、document.domain 基础域名相同 子域名不同</p></blockquote><blockquote><p>3、window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name</p></blockquote><blockquote><p>4、服务器设置对CORS的支持 原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p></blockquote><blockquote><p>5、利用h5新特性window.postMessage()</p></blockquote><h4 id="14-前端有哪些页面优化方法"><a href="#14-前端有哪些页面优化方法" class="headerlink" title="14.前端有哪些页面优化方法?"></a>14.前端有哪些页面优化方法?</h4><ul><li>减少 HTTP请求数</li><li>从设计实现层面简化页面</li><li>合理设置 HTTP缓存</li><li>资源合并与压缩</li><li>合并 CSS图片，减少请求数的又一个好办法。</li><li>将外部脚本置底（将脚本内容在页面信息内容加载后再加载）</li><li>多图片网页使用图片懒加载。</li><li>在js中尽量减少闭包的使用</li><li>尽量合并css和js文件</li><li>尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片</li><li>减少对DOM的操作</li><li>在JS中避免“嵌套循环”和 “死循环”</li><li>尽可能使用事件委托（事件代理）来处理事件绑定的操作</li></ul><h4 id="15-Ajax的四个步骤"><a href="#15-Ajax的四个步骤" class="headerlink" title="15.Ajax的四个步骤"></a>15.Ajax的四个步骤</h4><blockquote><p>1.创建ajax实例</p></blockquote><blockquote><p>2.执行open 确定要访问的链接 以及同步异步</p></blockquote><blockquote><p>3.监听请求状态</p></blockquote><blockquote><p>4.发送请求</p></blockquote><h4 id="16-数组去重的方法"><a href="#16-数组去重的方法" class="headerlink" title="16.数组去重的方法"></a>16.数组去重的方法</h4><blockquote><p>ES6的set对象 先将原数组排序，在与相邻的进行比较，如果不同则存入新数组</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function unique(arr)&#123;    var arr2 = arr.sort();    var res = [arr2[0]];    for(var i=1;i&lt;arr2.length;i++)&#123;        if(arr2[i] !== res[res.length-1])&#123;        res.push(arr2[i]);    &#125;&#125;return res;&#125;利用下标查询 function unique(arr)&#123;    var newArr = [arr[0]];    for(var i=1;i&lt;arr.length;i++)&#123;        if(newArr.indexOf(arr[i]) == -1)&#123;        newArr.push(arr[i]);    &#125;&#125;return newArr;&#125;复制代码</span><br></pre></td></tr></table></figure><h4 id="17-ajax中get和post请求的区别"><a href="#17-ajax中get和post请求的区别" class="headerlink" title="17.ajax中get和post请求的区别"></a>17.ajax中get和post请求的区别</h4><ul><li>get 一般用于获取数据</li><li>get请求如果需要传递参数，那么会默认将参数拼接到url的后面；然后发送给服务器；</li><li>get请求传递参数大小是有限制的；是浏览器的地址栏有大小限制；</li><li>get安全性较低</li><li>get 一般会走缓存，为了防止走缓存，给url后面每次拼的参数不同；放在?后面，一般用个时间戳</li><li>post 一般用于发送数据</li><li>post传递参数，需要把参数放进请求体中，发送给服务器；</li><li>post请求参数放进了请求体中，对大小没有要求；</li><li>post安全性比较高；</li><li>post请求不会走缓存；</li><li></li></ul><h4 id="18-ajax的状态码"><a href="#18-ajax的状态码" class="headerlink" title="18.ajax的状态码"></a>18.ajax的状态码</h4><blockquote><p>2开头</p></blockquote><ul><li>200 : 代表请求成功；</li></ul><blockquote><p>3开头</p></blockquote><ul><li>301 : 永久重定向；</li><li>302: 临时转移</li><li>304 : 读取缓存 [表示浏览器端有缓存，并且服务端未更新，不再向服务端请求资源]</li><li>307:临时重定向</li></ul><blockquote><p>以4开头的都是客户端的问题；</p></blockquote><ul><li>400 :数据/格式错误</li><li>401: 权限不够；（身份不合格，访问网站的时候，登录和不登录是不一样的）</li><li>404 : 路径错误，找不到文件</li></ul><blockquote><p>以5开头都是服务端的问题</p></blockquote><ul><li>500 : 服务器的问题</li><li>503: 超负荷；</li></ul><h4 id="19-移动端的兼容问题"><a href="#19-移动端的兼容问题" class="headerlink" title="19.移动端的兼容问题"></a>19.移动端的兼容问题</h4><ul><li><p>给移动端添加点击事件会有300S的延迟 如果用点击事件，需要引一个fastclick.js文件，解决300s的延迟 一般在移动端用ontouchstart、ontouchmove、ontouchend</p></li><li><p>移动端点透问题,touchstart 早于 touchend 早于click,click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上 尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。 用fastclick，<a href="https://link.juejin.cn/?target=https://github.com/ftlabs/fastclick">github.com/ftlabs/fast…</a> 用preventDefault阻止a标签的click 消除 IE10 里面的那个叉号 input:-ms-clear{display:none;}</p></li><li><p>设置缓存 手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。</p></li><li><p>圆角BUG 某些Android手机圆角失效 background-clip: padding-box; 防止手机中网页放大和缩小 这点是最基本的，做为手机网站开发者来说应该都知道的，就是设置meta中的viewport</p></li><li><p>设置用户截止缩放，一般写视口的时候就已经写好了。</p></li><li></li></ul><h4 id="20-JS中同步和异步-以及js的事件流"><a href="#20-JS中同步和异步-以及js的事件流" class="headerlink" title="20.JS中同步和异步,以及js的事件流"></a>20.JS中同步和异步,以及js的事件流</h4><blockquote><p>同步：在同一时间内做一件事情</p></blockquote><blockquote><p>异步：在同一时间内做多个事情 JS是单线程的，每次只能做一件事情，JS运行在浏览器中，浏览器是多线程的，可以在同一时间执行多个任务。</p></blockquote><h4 id="21-JS中常见的异步任务"><a href="#21-JS中常见的异步任务" class="headerlink" title="21.JS中常见的异步任务"></a>21.JS中常见的异步任务</h4><blockquote><p>定时器、ajax、事件绑定、回调函数、async await、promise</p></blockquote><h4 id="22-TCP的三次握手和四次挥手"><a href="#22-TCP的三次握手和四次挥手" class="headerlink" title="22.TCP的三次握手和四次挥手"></a>22.TCP的三次握手和四次挥手</h4><blockquote><p>三次握手</p></blockquote><ul><li>第一次握手：客户端发送一个SYN码给服务器，要求建立数据连接；</li><li>第二次握手： 服务器SYN和自己处理一个SYN（标志）；叫SYN+ACK（确认包）；发送给客户端，可以建立连接</li><li>第三次握手： 客户端再次发送ACK向服务器，服务器验证ACK没有问题，则建立起连接；</li></ul><blockquote><p>四次挥手</p></blockquote><ul><li>第一次挥手： 客户端发送FIN(结束)报文，通知服务器数据已经传输完毕；</li><li>第二次挥手: 服务器接收到之后，通知客户端我收到了SYN,发送ACK(确认)给客户端，数据还没有传输完成</li><li>第三次挥手： 服务器已经传输完毕，再次发送FIN通知客户端，数据已经传输完毕</li><li>第四次挥手： 客户端再次发送ACK,进入TIME_WAIT状态；服务器和客户端关闭连接；</li></ul><h4 id="23-为什么建立连接是三次握手，而断开连接是四次挥手呢"><a href="#23-为什么建立连接是三次握手，而断开连接是四次挥手呢" class="headerlink" title="23.为什么建立连接是三次握手，而断开连接是四次挥手呢?"></a>23.为什么建立连接是三次握手，而断开连接是四次挥手呢?</h4><blockquote><blockquote><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p></blockquote></blockquote><h4 id="24-DOM-diff原理"><a href="#24-DOM-diff原理" class="headerlink" title="24.DOM diff原理"></a>24.DOM diff原理</h4><blockquote><ul><li>如果元素类型发生变化，直接替换</li><li>如果是文本，则比较文本里面的内容，是否有差异，如果是元素就需要比较当前元素的属性是否相等,会先比较key， 在比较类型 为什么 react中循环 建议不要使用索引 ,如果纯为了展示 那可以使用索引</li></ul></blockquote><h4 id="25-作用域"><a href="#25-作用域" class="headerlink" title="25.作用域"></a>25.作用域</h4><blockquote><p>全局作用域</p></blockquote><ul><li>浏览器打开一个页面时，浏览器会给JS代码提供一个全局的运行环境，那么这个环境就是全局作用域 一个页面只有一个全局作用域，全局作用域下有一个window对象 window是全局作用域下的最大的一个内置对象（全局作用域下定义的变量和函数都会存储在window下） 如果是全局变量，都会给window新增一个键值对；属性名就是变量名，属性值就是变量所存储的值 如果变量只被var过，那么存储值是undefined 在私有作用域中是可以获取到全局变量的，但是在全局作用域中不能获取私有变量</li></ul><blockquote><p>私有作用域</p></blockquote><ul><li>函数执行会形成一个新的私有的作用域（执行多次，形成多个私有作用域） 私有作用域在全局作用域中形成，具有包含的关系； 在一个全局作用域中，可以有很多个私有作用域 在私有作用域下定义的变量都是私有变量 形参也是私有变量 函数体中通过function定义的函数也是私有的，在全局作用域不能使用；</li></ul><blockquote><p>块级作用域</p></blockquote><ul><li>es6中新引入的一种作用域 在js中常见到的if{}、for{}、while{}、try{}、catch{}、switch case{}都是块级作用域 var obj = {} //对象的大括号不是块级作用域 块级作用域中的同一变量不能被重复声明（块级下var和function不能重名，否则会报错） 作用域链</li></ul><blockquote><p>上级作用域</p></blockquote><ul><li>函数在哪里定义，他的上一级作用域就是哪，和函数在哪个作用域下执行没有关系 作用域链：当获取变量所对应的值时，首先看变量是否是私有变量，如果不是私有变量，要继续向上一级作用域中查找，如果上一级也没有，那么会继续向上一级查找，直到找到全局作用域为止；如果全局作用域也没有，则会报错；这样一级一级向上查找，就会形成作用域链 当前作用域没有的，则会继续向上一级作用域查找 当前函数的上一级作用域跟函数在哪个作用域下执行没有关系，只跟函数在哪定义有关（重点）</li></ul><h4 id="26-Promise处理异步"><a href="#26-Promise处理异步" class="headerlink" title="26.Promise处理异步"></a>26.Promise处理异步</h4><blockquote><p>他是ES6中新增加的一个类（new Promise）,目的是为了管理JS中的异步编程的，所以把他称为“Promise设计模式” new Promise 经历三个状态：padding(准备状态：初始化成功、开始执行异步的任务)、fullfilled(成功状态)、rejected(失败状态)== Promise本身是同步编程的，他可以管理异步操作的（重点），new Promise的时候，会把传递的函数立即执行 Promise函数天生有两个参数，resolve(当异步操作执行成功，执行resolve方法),rejected(当异步操作失败，执行reject方法) then()方法中有两个函数，第一个传递的函数是resolve,第二个传递的函数是reject ajax中false代表同步，true代表异步，如果使用异步，不等ajax彻底完成</p></blockquote><h4 id="27-map和forEach的区别"><a href="#27-map和forEach的区别" class="headerlink" title="27.map和forEach的区别"></a>27.map和forEach的区别</h4><blockquote><p>相同点</p></blockquote><ul><li>都是循环遍历数组中的每一项 forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组），需要用哪个的时候就写哪个 匿名函数中的this都是指向window 只能遍历数组</li></ul><blockquote><p>不同点</p></blockquote><ul><li>map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。(原数组进行处理之后对应的一个新的数组。) map()方法不会改变原始数组 map()方法不会对空数组进行检测 forEach()方法用于调用数组的每个元素，将元素传给回调函数.(没有return，返回值是undefined）</li></ul><blockquote><blockquote><p><strong>注意</strong>：forEach对于空数组是不会调用回调函数的。</p></blockquote></blockquote><h4 id="28-async-await函数"><a href="#28-async-await函数" class="headerlink" title="28.async await函数"></a>28.async await函数</h4><blockquote><p>async/await函数是异步代码的新方式</p></blockquote><blockquote><p>async/await是基于promise实现的</p></blockquote><blockquote><p>async/await使异步代码更像同步代码</p></blockquote><blockquote><p>await 只能在async函数中使用，不能再普通函数中使用，要成对出现</p></blockquote><blockquote><p>默认返回一个promise实例，不能被改变</p></blockquote><blockquote><p>await下面的代码是异步，后面的代码是同步的</p></blockquote><h4 id="29-this指向"><a href="#29-this指向" class="headerlink" title="29.this指向"></a>29.this指向</h4><blockquote><ul><li>全局作用域下的this指向window</li><li>如果给元素的事件行为绑定函数，那么函数中的this指向当前被绑定的那个元素</li><li>函数中的this，要看函数执行前有没有 . , 有 . 的话，点前面是谁，this就指向谁，如果没有点，指向window</li><li>自执行函数中的this永远指向window</li><li>定时器中函数的this指向window</li><li>构造函数中的this指向当前的实例</li><li>call、apply、bind可以改变函数的this指向</li><li>箭头函数中没有this，如果输出this，就会输出箭头函数定义时所在的作用域中的this</li></ul></blockquote><h4 id="30-原型"><a href="#30-原型" class="headerlink" title="30.原型"></a>30.原型</h4><blockquote><blockquote><p>所有的函数数据类型都天生自带一个prototype属性，该属性的属性值是一个对象 prototype的属性值中天生自带一个constructor属性，其constructor属性值指向当前原型所属的类 所有的对象数据类型，都天生自带一个_proto_属性，该属性的属性值指向当前实例所属类的原型</p></blockquote></blockquote><h4 id="31-异步回调（如何解决回调地狱）"><a href="#31-异步回调（如何解决回调地狱）" class="headerlink" title="31.异步回调（如何解决回调地狱）"></a>31.异步回调（如何解决回调地狱）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise、generator、async/awaitpromise： 1.是一个对象，用来传递异步操作的信息。代表着某个未来才会知道结果的时间，并未这个事件提供统一的api，供进异步处理  2.有了这个对象，就可以让异步操作以同步的操作的流程来表达出来，避免层层嵌套的回调地狱  3.promise代表一个异步状态，有三个状态pending（进行中），Resolve(以完成），Reject（失败）  4.一旦状态改变，就不会在变。任何时候都可以得到结果。从进行中变为以完成或者失败promise.all() 里面状态都改变，那就会输出，得到一个数组promise.race() 里面只有一个状态变为rejected或者fulfilled即输出promis.finally()不管指定不管Promise对象最后状态如何，都会执行的操作（本质上还是then方法的特例）复制代码</span><br></pre></td></tr></table></figure><h4 id="32-前端事件流"><a href="#32-前端事件流" class="headerlink" title="32.前端事件流"></a>32.前端事件流</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件流描述的是从页面中接受事件的顺序，事件 捕获阶段 处于目标阶段 事件冒泡阶段 addeventListener 最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。  1、事件捕获阶段：实际目标div在捕获阶段不会接受事件，也就是在捕获阶段，事件从document到&lt;html&gt;再到&lt;body&gt;就停止了。      2、处于目标阶段：事件在div发生并处理，但是事件处理会被看成是冒泡阶段的一部分。      3、冒泡阶段：事件又传播回文档   阻止冒泡事件event.stopPropagation()  function stopBubble(e) &#123;    if (e &amp;&amp; e.stopPropagation) &#123; // 如果提供了事件对象event 这说明不是IE浏览器      e.stopPropagation()    &#125; else &#123;      window.event.cancelBubble = true //IE方式阻止冒泡          &#125;     &#125;   阻止默认行为event.preventDefault() function stopDefault(e) &#123;    if (e &amp;&amp; e.preventDefault) &#123;      e.preventDefault()    &#125; else &#123;      // IE浏览器阻止函数器默认动作的行为      window.event.returnValue = false    &#125;  &#125;复制代码</span><br></pre></td></tr></table></figure><h4 id="33-事件如何先捕获后冒泡？"><a href="#33-事件如何先捕获后冒泡？" class="headerlink" title="33.事件如何先捕获后冒泡？"></a>33.事件如何先捕获后冒泡？</h4><blockquote><p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果， 对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。</p></blockquote><ul><li>哪些事件不支持冒泡事件：鼠标事件：mouserleave  mouseenter 焦点事件：blur focus UI事件：scroll resize</li></ul><h4 id="34-如何判断一个变量是对象还是数组（prototype-toString-call-）。"><a href="#34-如何判断一个变量是对象还是数组（prototype-toString-call-）。" class="headerlink" title="34. 如何判断一个变量是对象还是数组（prototype.toString.call()）。"></a>34. 如何判断一个变量是对象还是数组（prototype.toString.call()）。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。复制代码</span><br></pre></td></tr></table></figure><blockquote><p>typeOf()是判断基本类型的Boolean,Number，symbol, undefined, String。 对于引用类型：除function，都返回object   null返回object。</p></blockquote><blockquote><p>installOf() 用来判断A是否是B的实例，installof检查的是原型。</p></blockquote><blockquote><p>toString() 是Object的原型方法，对于 Object 对象，直接调用 toString()  就能返回 [Object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p></blockquote><blockquote><p>hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。</p></blockquote><blockquote><p>isProperty()方法测试一个对象是否存在另一个对象的原型链上。</p></blockquote><h4 id="35-setTimeout-和-setInterval的机制"><a href="#35-setTimeout-和-setInterval的机制" class="headerlink" title="35.setTimeout 和 setInterval的机制"></a>35.setTimeout 和 setInterval的机制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为js是单线程的。浏览器遇到etTimeout 和 setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码复制代码</span><br></pre></td></tr></table></figure><h4 id="36-splice和slice、map和forEach、-filter-、reduce-的区别"><a href="#36-splice和slice、map和forEach、-filter-、reduce-的区别" class="headerlink" title="36.splice和slice、map和forEach、 filter()、reduce()的区别"></a>36.splice和slice、map和forEach、 filter()、reduce()的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.slice(start,end):方法可以从已有数组中返回选定的元素，返回一个新数组， 包含从start到end（不包含该元素）的数组方法注意：该方法不会更新原数组，而是返回一个子数组 2.splice():该方法想或者从数组中添加或删除项目，返回被删除的项目。（该方法会改变原数组）splice(index, howmany,item1,...itemx)·index参数：必须，整数规定添加或删除的位置，使用负数，从数组尾部规定位置·howmany参数：必须，要删除的数量，·item1..itemx:可选，向数组添加新项目3.map()：会返回一个全新的数组。使用于改变数据值的时候。会分配内存存储空间数组并返回，forEach（）不会返回数据4.forEach(): 不会返回任何有价值的东西，并且不打算改变数据，单纯的只是想用数据做一些事情，他允许callback更改原始数组的元素5.reduce(): 方法接收一个函数作为累加器，数组中的每一个值（从左到右）开始缩减，最终计算一个值，不会改变原数组的值6.filter(): 方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。它里面通过function去做处理复制代码</span><br></pre></td></tr></table></figure><h1 id="VUE问题"><a href="#VUE问题" class="headerlink" title="VUE问题"></a>VUE问题</h1><h4 id="1-聊聊对vue的理解"><a href="#1-聊聊对vue的理解" class="headerlink" title="1.聊聊对vue的理解"></a>1.聊聊对vue的理解</h4><blockquote><p>vue是一个渐进式的JS框架。他易用，灵活，高效； 可以把一个页面分隔成多个组件；当其他页面有类似功能时，直接让封装的组件进行复用； 他是构建用户界面的声明式框架，只关心图层；不关心具体是如何实现的</p></blockquote><h4 id="2-V-model的原理是什么？"><a href="#2-V-model的原理是什么？" class="headerlink" title="2.V-model的原理是什么？"></a>2.V-model的原理是什么？</h4><blockquote><p>Vue的双向数据绑定是由数据劫持结合发布者订阅者实现的。 数据劫持是通过Object.defineProperty()来劫持对象数据的setter和getter操作。 在数据变动时作你想做的事</p><ul><li>原理 通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化-&gt;视图更新 在初始化vue实例时，遍历data这个对象，给每一个键值对利用Object.definedProperty对data的键值对新增get和set方法，利用了事件监听DOM的机制，让视图去改变数据</li></ul></blockquote><h4 id="3-谈谈对生命周期的理解"><a href="#3-谈谈对生命周期的理解" class="headerlink" title="3.谈谈对生命周期的理解"></a>3.谈谈对生命周期的理解</h4><ul><li>beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。</li><li>created阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有</li><li>beforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点</li><li>mounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点</li><li>beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</li><li>updated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环</li><li>beforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件</li><li>destroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁</li></ul><h4 id="4-VUE和REACT有什么区别？"><a href="#4-VUE和REACT有什么区别？" class="headerlink" title="4.VUE和REACT有什么区别？"></a>4.VUE和REACT有什么区别？</h4><blockquote><p>react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；</p></blockquote><blockquote><p>vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。</p></blockquote><h4 id="5-vuex的流程"><a href="#5-vuex的流程" class="headerlink" title="5.vuex的流程"></a>5.vuex的流程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">页面通过mapAction异步提交事件到action。action通过commit把对应参数同步提交到mutation。mutation会修改state中对于的值。 最后通过getter把对应值跑出去，在页面的计算属性中通过mapGetter来动态获取state中的值复制代码</span><br></pre></td></tr></table></figure><h4 id="6-vuex有哪几种状态和属性"><a href="#6-vuex有哪几种状态和属性" class="headerlink" title="6.vuex有哪几种状态和属性"></a>6.vuex有哪几种状态和属性</h4><blockquote><ul><li>state中保存着共有数据，数据是响应式的</li><li>getter可以对state进行计算操作，主要用来过滤一些数据，可以在多组件之间复用</li><li>mutations定义的方法动态修改state中的数据，通过commit提交方法，方法必须是同步的</li><li>actions将mutations里面处理数据的方法变成异步的，就是异步操作数据，通store.dispatch来分发actions，把异步的方法写在actions中，通过commit提交mutations，进行修改数据。</li><li>modules：模块化vuex</li></ul></blockquote><h4 id="7-vue路由的两种模式"><a href="#7-vue路由的两种模式" class="headerlink" title="7.vue路由的两种模式"></a>7.vue路由的两种模式</h4><blockquote><ul><li>hash ——即地址栏URL中的#符号（此hsah 不是密码学里的散列运算） hash 虽然出现URL中，但不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。</li><li>history ——利用了HTML5 History Interface 中新增的pushState() 和replaceState() 方法</li></ul><p>这两个方法应用于浏览器的历史记录站，在当前已有的back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改是，虽然改变了当前的URL，但你浏览器不会立即向后端发送请求。</p></blockquote><h4 id="8-vue中-key-值的作用"><a href="#8-vue中-key-值的作用" class="headerlink" title="8.vue中 key 值的作用"></a>8.vue中 key 值的作用</h4><blockquote><p>当 Vue.js 用v-for正在更新已渲染过的元素列表时，它默认用“就地复用”策略。 如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p></blockquote><blockquote><p>key的作用主要是为了高效的更新虚拟DOM。</p></blockquote><h4 id="9-route和-router的区别"><a href="#9-route和-router的区别" class="headerlink" title="9$route和$router的区别"></a>9<code>$route</code>和<code>$router</code>的区别</h4><blockquote><ul><li>$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。</li><li>$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li></ul></blockquote><h4 id="10-vue-router守卫"><a href="#10-vue-router守卫" class="headerlink" title="10.vue-router守卫"></a>10.vue-router守卫</h4><blockquote><ul><li>导航守卫 router.beforeEach 全局前置守卫</li></ul></blockquote><ul><li>to: Route: 即将要进入的目标（路由对象）</li><li>from: Route: 当前导航正要离开的路由</li><li>next: Function: 一定要调用该方法来 resolve 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截） 执行效果依赖 next 方法的调用参数。</li><li>next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。</li><li>next(false): 取消进入路由，url地址重置为from路由地址(也就是将要离开的路由地址)。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// main.js 入口文件    import router from &#x27;./router&#x27;; // 引入路由    router.beforeEach((to, from, next) =&gt; &#123;       next();    &#125;);    router.beforeResolve((to, from, next) =&gt; &#123;      next();    &#125;);    router.afterEach((to, from) =&gt; &#123;      console.log(&#x27;afterEach 全局后置钩子&#x27;);    &#125;);复制代码</span><br></pre></td></tr></table></figure><p>路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;  routes: [    &#123;      path: &#x27;/foo&#x27;,      component: Foo,      beforeEnter: (to, from, next) =&gt; &#123;        // ...      &#125;    &#125;  ]&#125;)复制代码</span><br></pre></td></tr></table></figure><p>组件内的守卫 你可以在路由组件内直接定义以下路由导航守卫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Foo = &#123;  template: `...`,  beforeRouteEnter (to, from, next) &#123;    // 在渲染该组件的对应路由被 confirm 前调用    // 不！能！获取组件实例 `this`    // 因为当守卫执行前，组件实例还没被创建  &#125;,  beforeRouteUpdate (to, from, next) &#123;    // 在当前路由改变，但是该组件被复用时调用    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。    // 可以访问组件实例 `this`  &#125;,  beforeRouteLeave (to, from, next) &#123;    // 导航离开该组件的对应路由时调用，我们用它来禁止用户离开    // 可以访问组件实例 `this`    // 比如还未保存草稿，或者在用户离开前，    将setInterval销毁，防止离开之后，定时器还在调用。  &#125;&#125;复制代码</span><br></pre></td></tr></table></figure><h4 id="11-axios是什么？怎么使用？描述使用它实现登录功能的流程？"><a href="#11-axios是什么？怎么使用？描述使用它实现登录功能的流程？" class="headerlink" title="11.axios是什么？怎么使用？描述使用它实现登录功能的流程？"></a>11.axios是什么？怎么使用？描述使用它实现登录功能的流程？</h4><blockquote><p>请求后台资源的模块。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install axios -S装好复制代码</span><br></pre></td></tr></table></figure><blockquote><p>然后发送的是跨域，需在配置文件中config/index.js进行设置。后台如果是Tp5则定义一个资源路由。 js中使用import进来，然后.get或.post。返回在.then函数中如果成功，失败则是在.catch函数中</p></blockquote><h4 id="12-vue修饰符"><a href="#12-vue修饰符" class="headerlink" title="12.vue修饰符"></a>12.vue修饰符</h4><ul><li>stop：阻止事件的冒泡</li><li>prevent：阻止事件的默认行为</li><li>once：只触发一次</li><li>self：只触发自己的事件行为时，才会执行</li></ul><h4 id="13-vue项目中的性能优化"><a href="#13-vue项目中的性能优化" class="headerlink" title="13.vue项目中的性能优化"></a>13.vue项目中的性能优化</h4><blockquote><p>1.不要在模板里面写过多表达式</p></blockquote><blockquote><p>2.循环调用子组件时添加key</p></blockquote><blockquote><p>3.频繁切换的使用v-show，不频繁切换的使用v-if</p></blockquote><blockquote><p>4.尽量少用float，可以用flex</p></blockquote><blockquote><p>5.按需加载，可以用require或者import()按需加载需要的组件</p></blockquote><blockquote><p>6.路由懒加载</p></blockquote><h4 id="14-vue-extend和vue-component"><a href="#14-vue-extend和vue-component" class="headerlink" title="14.vue.extend和vue.component"></a>14.vue.extend和vue.component</h4><blockquote><ul><li>extend 是构造一个组件的语法器。 然后这个组件你可以作用到Vue.component这个全局注册方法里 还可以在任意vue模板里使用组件。 也可以作用到vue实例或者某个组件中的components属性中并在内部使用apple组件。</li><li>Vue.component 你可以创建 ，也可以取组件。</li></ul></blockquote><h3 id="常见的兼容问题"><a href="#常见的兼容问题" class="headerlink" title="常见的兼容问题"></a>常见的兼容问题</h3><blockquote><p>png24位的图片在iE6浏览器上出现背景 解决方案是做成PNG8.也可以引用一段脚本处理.</p></blockquote><blockquote><p>浏览器默认的margin和padding不同。 解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p></blockquote><blockquote><p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p></blockquote><blockquote><p>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;}</p></blockquote><h1 id="React问题"><a href="#React问题" class="headerlink" title="React问题"></a>React问题</h1><h4 id="1-react和vue的区别"><a href="#1-react和vue的区别" class="headerlink" title="1.react和vue的区别"></a>1.react和vue的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=&gt;  相同点：1.数据驱动页面，提供响应式的试图组件2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范3.数据流动单向，都支持服务器的渲染SSR4.都有支持native的方法，react有React native， vue有wexx=&gt;  不同点：1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的2.数据渲染：大规模的数据渲染，react更快3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目4.开发风格：react推荐做法jsx + inline style把html和css都写在js了    vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件复制代码</span><br></pre></td></tr></table></figure><h4 id="2-redux中的reducer（纯函数）"><a href="#2-redux中的reducer（纯函数）" class="headerlink" title="2.redux中的reducer（纯函数）"></a>2.redux中的reducer（纯函数）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current action）更新state(这个state可以理解为上下累加器的结果）每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是&#x27;自身消减&#x27;(reduce),进而返回最新的state,这也就是典型reduce函数的用法：state -&gt;  action -&gt;  state复制代码</span><br></pre></td></tr></table></figure><h4 id="3-react的refs"><a href="#3-react的refs" class="headerlink" title="3.react的refs"></a>3.react的refs</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">refs就想一个逃生窗，允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函数，它将接受地城dom元素或组件的已挂在实例，作为第一个参数复制代码</span><br></pre></td></tr></table></figure><h4 id="4-react中的keys"><a href="#4-react中的keys" class="headerlink" title="4.react中的keys"></a>4.react中的keys</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">帮组我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去定位元素，并且操作它复制代码</span><br></pre></td></tr></table></figure><h4 id="5-React的生命周期"><a href="#5-React的生命周期" class="headerlink" title="5.React的生命周期"></a>5.React的生命周期</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三个状态：Mounting(已插入真实的DOM）  Updating(正在被重新渲染)  Unmounting(已移除真实的DOM)componentDIdMount 在第一次渲染后调用，只在客服端。之后组件已经生成对应的DOM结构，componentDidUpdate 在组件完成更新后立即调用，在出初始化是不会调用复制代码</span><br></pre></td></tr></table></figure><h4 id="6-React子组件向父组件传值"><a href="#6-React子组件向父组件传值" class="headerlink" title="6.React子组件向父组件传值"></a>6.React子组件向父组件传值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数据。复制代码</span><br></pre></td></tr></table></figure><h4 id="7-为什么虚拟DOM会提高性能-www-zhihu-com-question-29…"><a href="#7-为什么虚拟DOM会提高性能-www-zhihu-com-question-29…" class="headerlink" title="7.为什么虚拟DOM会提高性能 www.zhihu.com/question/29…"></a>7.为什么虚拟DOM会提高性能 <a href="https://link.juejin.cn/?target=https://www.zhihu.com/question/29504639?sort=created">www.zhihu.com/question/29…</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的doom操作，从而提高性能具体实现步骤：·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档中        ·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。复制代码</span><br></pre></td></tr></table></figure><h4 id="8-diff算法"><a href="#8-diff算法" class="headerlink" title="8.diff算法"></a>8.diff算法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.把树形结构按照层级分解，只比较同级元素2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个标记3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就记录到一个对象里面Vritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进行使用react只会匹配相同的class的component（这里的class指的是组件的名字）合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借宿，React检查所有标记dirty的component重新绘制4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能复制代码</span><br></pre></td></tr></table></figure><h4 id="9-简述下flux的思想"><a href="#9-简述下flux的思想" class="headerlink" title="9.简述下flux的思想"></a>9.简述下flux的思想</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flux的最大特点，就是数据的‘单向流动’1.用户访问View2.View发出用户的Action3.Dispatcher收到Action,要求state进行相应的更新4.store更新后，发出一个‘change’事件后，更新页面复制代码</span><br></pre></td></tr></table></figure><h4 id="10-reac性能优化是哪个周期函"><a href="#10-reac性能优化是哪个周期函" class="headerlink" title="10.reac性能优化是哪个周期函"></a>10.reac性能优化是哪个周期函</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的描绘非常消耗性能，如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能复制代码</span><br></pre></td></tr></table></figure><h4 id="11-react怎么划分业务组件和技术组件"><a href="#11-react怎么划分业务组件和技术组件" class="headerlink" title="11.react怎么划分业务组件和技术组件"></a>11.react怎么划分业务组件和技术组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据组件的职责通常把组件分为UI组件和容器组件UI组件负责UI的呈现，容器组件负责管理数据和逻辑两者通过React-redux提供connect方法联系起来复制代码</span><br></pre></td></tr></table></figure><h4 id="12-setState"><a href="#12-setState" class="headerlink" title="12.setState"></a>12.setState</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状态队列而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改this.state的值那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略之前修改的state，造成不可预知的错误同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state同步更新state:setState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible 有可能先于数据渲染完毕就执行。第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执行也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步例子：componentDidMount() &#123;fetch(&#x27;https://test.com&#x27;)    .then((res) =&gt; res.json())    .then(    (data) =&gt; &#123;this.setState(&#123; data:data &#125;);StatusBar.setNetworkActivityIndicatorVisible(false);        &#125;复制代码</span><br></pre></td></tr></table></figure><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h4 id="一、webpack打包文件体积过大？（最终打包为一个js文件）"><a href="#一、webpack打包文件体积过大？（最终打包为一个js文件）" class="headerlink" title="一、webpack打包文件体积过大？（最终打包为一个js文件）"></a>一、webpack打包文件体积过大？（最终打包为一个js文件）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.异步加载模块2.提取第三库3.代码压缩4.去除不必要的插件复制代码</span><br></pre></td></tr></table></figure><h4 id="二、如何优化webpack构建的性能"><a href="#二、如何优化webpack构建的性能" class="headerlink" title="二、如何优化webpack构建的性能"></a>二、如何优化webpack构建的性能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一、减少代码体积 1.使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积 2.把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理 3.对一些组件库采用按需加载，避免无用的代码二、减少目录检索范围 ·在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度三、减少检索路经：resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias复制代码</span><br></pre></td></tr></table></figure><h4 id="三、移动端的性能优化"><a href="#三、移动端的性能优化" class="headerlink" title="三、移动端的性能优化"></a>三、移动端的性能优化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、首屏加载和按需加载，懒加载  2、资源预加载  3、图片压缩处理，使用base64内嵌图片  4、合理缓存dom对象  5、使用touchstart代替click（click 300毫秒的延迟）  6、利用transform:translateZ(0)，开启硬件GUP加速  7、不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明  8、使用viewport固定屏幕渲染，加速页面渲染内容  9、尽量使用事件代理，避免直接事件绑定复制代码</span><br></pre></td></tr></table></figure><h4 id="四、Vue的SPA-如何优化加载速度"><a href="#四、Vue的SPA-如何优化加载速度" class="headerlink" title="四、Vue的SPA 如何优化加载速度"></a>四、Vue的SPA 如何优化加载速度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.减少入口文件体积2.静态资源本地缓存3.开启Gzip压缩4.使用SSR,nuxt.js复制代码</span><br></pre></td></tr></table></figure><h4 id="五、移动端300ms延迟"><a href="#五、移动端300ms延迟" class="headerlink" title="五、移动端300ms延迟"></a>五、移动端300ms延迟</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由来：300毫米延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放值原始比例。由于用户可以双击缩放或者是滚动的操作，当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作因此，safair浏览器就会等待300ms，用来判断用户是否在次点击了屏幕       解决方案：1.禁用缩放，设置meta标签 user-scalable=no  2.fastclick.js原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即      发出click事件，并把浏览器在300ms之后真正的click事件阻止掉fastclick.js还可以解决穿透问题复制代码</span><br></pre></td></tr></table></figure><h4 id="六、页面的重构；"><a href="#六、页面的重构；" class="headerlink" title="六、页面的重构；"></a>六、页面的重构；</h4><blockquote><p>在不改变外部行为的前提下，简化结构、添加可读性</p></blockquote><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><h4 id="一、状态码："><a href="#一、状态码：" class="headerlink" title="一、状态码："></a>一、状态码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2XX（成功处理了请求状态）      200 服务器已经成功处理请求，并提供了请求的网页      201 用户新建或修改数据成功      202 一个请求已经进入后台      204 用户删除成功  3XX（每次请求使用的重定向不要超过5次）      304 网页上次请求没有更新，节省带宽和开销  4XX（表示请求可能出错，妨碍了服务器的处理）      400 服务器不理解请求的语法      401 用户没有权限（用户名，密码输入错误）      403 用户得到授权（401相反），但是访问被禁止      404 服务器找不到请求的网页，  5XX（表示服务器在处理请求的时候发生内部错误）      500 服务器遇到错误，无法完成请求      503 服务器目前无法使用（超载或停机维护）     复制代码</span><br></pre></td></tr></table></figure><h4 id="二、304的缓存原理（添加Etag标签-last-modified）-304-网页上次请求没有更新，节省带宽和开销"><a href="#二、304的缓存原理（添加Etag标签-last-modified）-304-网页上次请求没有更新，节省带宽和开销" class="headerlink" title="二、304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销"></a>二、304的缓存原理（添加Etag标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.服务器首先产生Etag,服务器可在稍后使用它来判断页面是否被修改。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）2.304是HTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去去找浏览器缓存的文件3.流程：客户端请求一个页面A。服务器返回页面A，并在A上加一个Tage客服端渲染该页面，并把Tage也存储在缓存中。客户端再次请求页面A并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该页面自上次客户端请求之后未被修改。直接返回304last-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最后修改的时间客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-Modified-Since报头，询问该事件之后文件是否被修改，没修改返回304 有了Last-Modified，为什么还要用ETag？  1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—Modified不能识别秒单位的修改）  2、某些服务器不能精确的得到文件的最后修改时间  3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新GetETag，为什么还要用Last-Modified？  1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改  2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。ETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）  1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。复制代码</span><br></pre></td></tr></table></figure><h4 id="三、get-post的区别"><a href="#三、get-post的区别" class="headerlink" title="三、get/post的区别"></a>三、get/post的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&amp;相连； post方法是把提交的数据放在http包的Body中2.get提交的数据大小有限制，（因为浏览器对url的长度有限制），post的方法提交的数据没有限制3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量的值4.get的方法提交数据，会带来安全问题，比如登录一个页面，通过get的方式提交数据，用户名和密码就会出现在url上复制代码</span><br></pre></td></tr></table></figure><h4 id="四、http协议的理解"><a href="#四、http协议的理解" class="headerlink" title="四、http协议的理解"></a>四、http协议的理解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议2.基于TCP/IP通信协议来传递数据（HTML，图片资源）3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统4.http请求信息request：请求行（request line）、请求头部（header）,空行和请求数据四部分构成请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.请求头部，用来说明服务器要使用的附加信息空行，请求头部后面的空行是必须的请求数据也叫主体，可以添加任意的其他数据。5.http相应信息Response状态行、消息报头、空行和响应正文状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成消息报头，用来说明客户端要使用的一些附加信息空行，消息报头后面的空行是必须的响应正文，服务器返回给客户端的文本信息。复制代码</span><br></pre></td></tr></table></figure><h4 id="五、http和https"><a href="#五、http和https" class="headerlink" title="五、http和https"></a>五、http和https</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密http：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少复制代码</span><br></pre></td></tr></table></figure><h4 id="六、http1-0-1-1-2-0的区别"><a href="#六、http1-0-1-1-2-0的区别" class="headerlink" title="六、http1.0 1.1 2.0的区别"></a>六、http1.0 1.1 2.0的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）host域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量3.多路复用：一个连接可以并发处理多个请求4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源复制代码</span><br></pre></td></tr></table></figure><h4 id="七、web缓存"><a href="#七、web缓存" class="headerlink" title="七、web缓存"></a>七、web缓存</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本2.缓存的好处        （1）减少不必要的请求    （2）降低服务器的压力，减少服务器的消耗    （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）复制代码</span><br></pre></td></tr></table></figure><h4 id="八、常见的web安全及防护原理"><a href="#八、常见的web安全及防护原理" class="headerlink" title="八、常见的web安全及防护原理"></a>八、常见的web安全及防护原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。也就是说，            在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作时，会拼接对应参数，            同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。防范：1.对用户输入进行校验       2.不适用动态拼接sql2.XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。        举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息防范：1.尽量采用post而不使用get提交表单      2.避免cookie中泄漏用户的隐式3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求举例子：黄轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来获取QQ音乐的数据防范：在客服端页面增加伪随机数，通过验证码XSS和CSRF的区别：   1.XSS是获取信息，不需要提前知道其他用户页面的代码和数据包   2.CSRF代替用户完成指定的动作，需要知道其他页面的代码和数据包复制代码</span><br></pre></td></tr></table></figure><h4 id="九、CDN（内容分发网络）"><a href="#九、CDN（内容分发网络）" class="headerlink" title="九、CDN（内容分发网络）"></a>九、CDN（内容分发网络）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。2.关键技术：内容存储和分发技术中3.基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术    将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）复制代码</span><br></pre></td></tr></table></figure><h4 id="十、TCP三次握手-客服端和服务器端都需要确认各自可收发）"><a href="#十、TCP三次握手-客服端和服务器端都需要确认各自可收发）" class="headerlink" title="十、TCP三次握手    (客服端和服务器端都需要确认各自可收发）"></a>十、TCP三次握手    (客服端和服务器端都需要确认各自可收发）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客服端发c起请求连接服务器端s确认，服务器端也发起连接确认客服端确认。第一次握手：客服端发送一个请求连接，服务器端只能确认自己可以接受客服端发送的报文段第二次握手： 服务端向客服端发送一个链接，确认客服端收到自己发送的报文段第三次握手： 服务器端确认客服端收到了自己发送的报文段复制代码</span><br></pre></td></tr></table></figure><h4 id="十一、从输入url到获取页面的完整过程-blog-csdn-net-samjustin1-…"><a href="#十一、从输入url到获取页面的完整过程-blog-csdn-net-samjustin1-…" class="headerlink" title="十一、从输入url到获取页面的完整过程  blog.csdn.net/samjustin1/…"></a>十一、从输入url到获取页面的完整过程  <a href="https://link.juejin.cn/?target=https://blog.csdn.net/samjustin1/article/details/52650520">blog.csdn.net/samjustin1/…</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.查询NDS(域名解析),获取域名对应的IP地址  查询浏览器缓存2.浏览器与服务器建立tcp链接（三次握手）3.浏览器向服务器发送http请求(请求和传输数据）4.服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器5.浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js，图片一样的步骤6.浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来复制代码</span><br></pre></td></tr></table></figure><h4 id="十二、浏览器渲染原理及流程-DOM-gt-CSSOM-gt-render-gt-layout-gt-print"><a href="#十二、浏览器渲染原理及流程-DOM-gt-CSSOM-gt-render-gt-layout-gt-print" class="headerlink" title="十二、浏览器渲染原理及流程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print"></a>十二、浏览器渲染原理及流程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">流程：解析html以及构建dom树 -&gt; 构建render树 -&gt;  布局render树 -&gt; 绘制render树概念：1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树      2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）      3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置      4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点重绘：当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上触发重绘的条件：改变元素外观属性。如：color，background-color等重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观注意：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多发时间，要尽量避免使用table布局重排（重构/回流/reflow）： 当渲染书中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。每个页面都需要一次回流，就是页面第一次渲染的时候重排一定会影响重绘，但是重绘不一定会影响重排复制代码</span><br></pre></td></tr></table></figure><h4 id="十三、为什么css放在顶部而js写在后面"><a href="#十三、为什么css放在顶部而js写在后面" class="headerlink" title="十三、为什么css放在顶部而js写在后面"></a>十三、为什么css放在顶部而js写在后面</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了2.其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面复制代码</span><br></pre></td></tr></table></figure><h4 id="十四、存储方式与传输方式"><a href="#十四、存储方式与传输方式" class="headerlink" title="十四、存储方式与传输方式"></a>十四、存储方式与传输方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.indexBD: 是h5的本地存储库，把一些数据存储到浏览器中，没网络，浏览器可以从这里读取数据，离线运用。5m2.Cookie: 通过浏览器记录信息确认用户身份，最大4kb,这也就限制了传输的数据，请求的性能会受到影响3.Session: 服务器端使用的一种记录客户状态的机制（session_id存在set_cookie发送到客服端，保存为cookie）4.localStroage: h5的本地存储，数据永久保存在客服端复制代码</span><br></pre></td></tr></table></figure><h4 id="cookie，sessionStorage，localStorage"><a href="#cookie，sessionStorage，localStorage" class="headerlink" title="cookie，sessionStorage，localStorage"></a>cookie，sessionStorage，localStorage</h4><p>1、cookie，sessionStorage，localStorage是存放在客户端，session对象数据是存放在服务器上 实际上浏览器和服务器之间仅需传递session id即可，服务器根据session-id找到对应的用户session对象 session存储数据更安全一些，一般存放用户信息，浏览器只适合存储一般的数据 2、cookie数据始终在同源的http请求中携带，在浏览器和服务器来回传递，里面存放着session-id sessionStorage，localStorage仅在本地保存 3、大小限制区别，cookie数据不超过4kb，localStorage在谷歌浏览中2.6MB 4、数据有效期不同，cookie在设置的（服务器设置）有效期内有效，不管窗口和浏览器关闭 sessionStorage仅在当前浏览器窗口关闭前有效，关闭即销毁（临时存储） localStorage始终有效</p><p>SessionStorage和localStorage区别： 1.sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在用一个会话的页面中才能被访问（也就是说在第一次通信过程中） 并且在会话结束后数据也随之销毁，不是一个持久的本地存储，会话级别的储存 2.localStorage用于持久化的本地存储，除非主动删除数据，否则不会过期</p><h4 id="token、cookie、session三者的理解？？？！！！"><a href="#token、cookie、session三者的理解？？？！！！" class="headerlink" title="token、cookie、session三者的理解？？？！！！"></a>token、cookie、session三者的理解？？？！！！</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件（最好的身份认证，安全性好，且是唯一的）    用户身份的验证方式    2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名    服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信息）3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的就是服务器和客户端的一次会话过程）    cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。复制代码</span><br></pre></td></tr></table></figure><h4 id="基于Token的身份验证：（最简单的token-uid用户唯一的身份识别-time当前事件戳-sign签名）"><a href="#基于Token的身份验证：（最简单的token-uid用户唯一的身份识别-time当前事件戳-sign签名）" class="headerlink" title="基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前事件戳 + sign签名）"></a>基于Token的身份验证：（最简单的token: uid用户唯一的身份识别 + time当前事件戳 + sign签名）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、用户通过用户名和密码发送请求  2、服务器端验证  3、服务器端返回一个带签名的token，给客户端  4、客户端储存token，并且每次用于发送请求  5、服务器验证token并且返回数据  每一次请求都需要token复制代码</span><br></pre></td></tr></table></figure><h4 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、cookie数据存放在客户的浏览器上，session数据放在服务器上。  2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。  3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。  4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。复制代码</span><br></pre></td></tr></table></figure><h4 id="session与token区别"><a href="#session与token区别" class="headerlink" title="session与token区别"></a>session与token区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认证手段。只存在服务端，不能共享到其他的网站和第三方App  2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的就是让某APP有权访问某用户的的信息。Token是唯一的，     token不能转移到其他的App，也不能转到其他用户上。（适用于App）  3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客户端的复制代码</span><br></pre></td></tr></table></figure><h4 id="Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）"><a href="#Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）" class="headerlink" title="Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）"></a>Cookie的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1、数量和长度的限制。每个特定的域名下最多生成20个cookie（chorme和safari没有限制）  2、安全性问题。复制代码</span><br></pre></td></tr></table></figure><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote><p>一、观察者模式：<a href="https://juejin.cn/post/6844903513009422343">juejin.cn/post/684490…</a>   <a href="https://juejin.cn/post/6844903603107266567">juejin.cn/post/684490…</a> 在软件开发设计中是一个对象(subject)，维护一系列依赖他的对象（observer），当任何状态发生改变自动通知他们。强依赖关系 简单理解：数据发生改变时，对应的处理函数就会自动执行。一个Subjet,用来维护Observers,为某些event来通知（notify）观察者</p></blockquote><blockquote><p>二、发布-订阅者  有一个信息中介，过滤 耦合性低 它定义了一种一对多的关系，可以使多个观察者对象对一个主题对象进行监听，当这个主题对象发生改变时，依赖的所有对象都会被通知到。</p></blockquote><ul><li>-两者的区别： 1.观察者模式中，观察者知道Subject ,两者是相关联的，而发发布订阅者只有通过信息代理进行通信 2.在发布订阅模式中，组件式松散耦合的。正好和观察者模式相反。 3.观察者大部分是同步的，比如事件的触发。Subject就会调用观察者的方法。而发布订阅者大多数是异步的（） 4.观察者模式需要在单个应用程序地址空间中实现，而发布订阅者更像交叉应用模式。</li></ul><h1 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h1><h4 id="一、两个栈实现一个队列，两个队列实现一个栈-www-cnblogs-com-MrListening…"><a href="#一、两个栈实现一个队列，两个队列实现一个栈-www-cnblogs-com-MrListening…" class="headerlink" title="一、两个栈实现一个队列，两个队列实现一个栈 www.cnblogs.com/MrListening…"></a>一、两个栈实现一个队列，两个队列实现一个栈 <a href="https://link.juejin.cn/?target=https://www.cnblogs.com/MrListening/p/5697459.html">www.cnblogs.com/MrListening…</a></h4><h4 id="二、红黑树（解决二叉树依次插入多个节点时的线型排列）-juejin-cn-post-684490…"><a href="#二、红黑树（解决二叉树依次插入多个节点时的线型排列）-juejin-cn-post-684490…" class="headerlink" title="二、红黑树（解决二叉树依次插入多个节点时的线型排列） juejin.cn/post/684490…"></a>二、红黑树（解决二叉树依次插入多个节点时的线型排列） <a href="https://juejin.cn/post/6844903519632228365">juejin.cn/post/684490…</a></h4><h4 id="三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin-cn-post-684490…"><a href="#三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin-cn-post-684490…" class="headerlink" title="三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin.cn/post/684490…"></a>三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）<a href="https://juejin.cn/post/6844903521280589831">juejin.cn/post/684490…</a></h4><h4 id="四、十大排序"><a href="#四、十大排序" class="headerlink" title="四、十大排序"></a>四、十大排序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.冒泡排序：重复走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把它们交换过来。  实现过程：1.比较相邻的元素。如果第一个比第二个大，就交换他们两个    2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数    3.针对所有的元素重复以上的步骤，除了最后一个    4.重复步骤1-3，直到排序完成。2.选择排序：首先在未排序序列中找到最小值，放在排序序列的起始位置，然后，在从剩下未排序元素中继续寻找最小值，然后放在与排序序列的末尾  实现过程：3.插入排序：构建有序序列，对于未排序数据，在已排序序列中冲后向前扫描，找到相应位置并插入  实现过程：1.从第一个元素开始，该元素可以认为已经被排序    2.取出下一个元素，在已排序的元素序列中冲后向前扫描    3.如果该元素（以排序）大于新元素，将元素向后移一位    4.在取出一个元素，比较之前的，直到找到自己合适的位置4.桶排序：将数据分布到有限数量的桶里，每个桶在分别排序1.快速排序：快速排序使用分治法把一个串（list）分为两个子串（sub-lists）.具体算法实现  实现过程：1.从数组中挑出一个元素，成为一个基准    2.重新排列数组，所有元素比基准小的摆在基准前面，所有元素比基准大的摆在基准后面（相同的可以摆在一边）这个分区退出之后，该基准就处于数列的中间位置。成为分区操作。    3.递归的把小于基准值的子数列和大于基准值元素的子数列排序算法实现： function quickSort (arr) &#123;if （arr.length &lt;= 1） &#123;return arr&#125;var destIndex = Math.floor(arr.length/2)var left = [], right = [];var dest = arr.splice(destIndex,1)[0];for (var i =0;i&lt;arr.length;i++)&#123;if (arr[i]&lt;dest) &#123;left.push(arr[i])&#125; else &#123;right.push(arr[i]) &#125;return quickSort(left).concat([dest],quickSort(right)2.堆排序：利用对这种数据结构所涉及的一种排序算法，堆积是一个近乎完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或大于）它的父节点。  实现过程：1.复制代码</span><br></pre></td></tr></table></figure><h4 id="五、数组去重-juejin-cn-post-684490…"><a href="#五、数组去重-juejin-cn-post-684490…" class="headerlink" title="五、数组去重 juejin.cn/post/684490…"></a>五、数组去重 <a href="https://juejin.cn/post/6844903602197102605#heading-6">juejin.cn/post/684490…</a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.双重循环2.indexOf3.数组排序去重 最快你Olong复制代码</span><br></pre></td></tr></table></figure><h4 id="六、字符串"><a href="#六、字符串" class="headerlink" title="六、字符串"></a>六、字符串</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断回文字符串：（递归的思想）1.字符串分隔，倒转，聚合[...obj].reverse().join(&#x27;&#x27;)2.字符串头部和尾部，逐次向中间检测 实现：function isPalindrome(line) &#123;line += &#x27;&#x27;;for (var i=0,j=line.length-1;i&lt;j;i++,j--) &#123;if (line.chartAt(i) !== line.chartAt(j) &#123;return false&#125;3.递归复制代码</span><br></pre></td></tr></table></figure><h4 id="七、二分查找（有序数组的查找）"><a href="#七、二分查找（有序数组的查找）" class="headerlink" title="七、二分查找（有序数组的查找）"></a>七、二分查找（有序数组的查找）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二分查找可以解决已排序数组的查找问题，即只要数组中包含T(要查找的值)，那么通过不断的缩小包含T的数据范围，就可以最终要找到的数 (1) 一开始,数据范围覆盖整个数组。 (2) 将数组的中间项与T进行比较，如果T比数组的中间项小，则到数组的前半部分继续查找，反之，则到数组的后半部分继续查找。 (3) 就这样，每次查找都可以排除一半元素，相当于范围缩小一半。这样反复比较，反复缩小范围，最终会在数组中找到T代码实现：function binarySearch (data, dest, start, end)&#123;var end = end || data.length-1;var start = start || 0;var m = Math.floor((start+end)/2);if (dest&lt;data[m])&#123;return binarySearch(data, dest, 0, m-1)&#125; else &#123;return binarySearch(data, dest, m+1, end)&#125;&#125;return false复制代码</span><br></pre></td></tr></table></figure><h1 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h1><h4 id="一、动手实现一个bind（原理通过apply，call）"><a href="#一、动手实现一个bind（原理通过apply，call）" class="headerlink" title="一、动手实现一个bind（原理通过apply，call）"></a>一、动手实现一个bind（原理通过apply，call）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一句话概括：1.bind()返回一个新函数，并不会立即执行。    2.bind的第一个参数将作为他运行时的this，之后的一系列参数将会在传递的实参前传入作为他的参数    3.bind返回函数作为构造函数，就是可以new的，bind时指定的this值就会消失，但传入的参数依然生效复制代码Function.prototype.bind = function (obj, arg) &#123;   var arg = Array.prototype.slice.call(arguments, 1);   var context = this;   var bound = function (newArg) &#123;   arg = arg.concat(Array.prototype.slice.call(newArg);   return context.apply(obj, arg)&#125;  var F =  function () &#123;&#125;  // 在new一个bind会生成新函数，必须的条件就是要继承原函数的原型，因此用到寄生继承来完成我们的过程  F.prototype = context.prototype;  bound.prototype =  new F();  return bound;&#125;复制代码</span><br></pre></td></tr></table></figure><h4 id="二、-AJAX-（异步的javascript和xml）"><a href="#二、-AJAX-（异步的javascript和xml）" class="headerlink" title="二、 AJAX （异步的javascript和xml）"></a>二、 AJAX （异步的javascript和xml）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">ajax的原理：相当于在用户和服务器之间加一个中间层（ajax引擎),使用户操作与服务器响应异步化。</span><br><span class="line">优点：在不刷新整个页面的前提下与服务器通信维护数据。不会导致页面的重载</span><br><span class="line">      可以把前端服务器的任务转嫁到客服端来处理，减轻服务器负担，节省宽带</span><br><span class="line">劣势：不支持back。对搜索引擎的支持比较弱；不容易调试</span><br><span class="line">怎么解决呢？通过location.hash值来解决Ajax过程中导致的浏览器前进后退按键失效，</span><br><span class="line">解决以前被人常遇到的重复加载的问题。主要比较前后的hash值，看其是否相等，在判断是否触发ajax</span><br><span class="line">复制代码</span><br><span class="line">function getData(url) &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();  // 创建一个对象，创建一个异步调用的对象</span><br><span class="line">    xhr.open(&#x27;get&#x27;, url, true)  // 设置一个http请求，设置请求的方式，url以及验证身份</span><br><span class="line">    xhr.send() //发送一个http请求</span><br><span class="line">    xhr.onreadystatechange = function () &#123;  //设置一个http请求状态的函数</span><br><span class="line">      if (xhr.readyState == 4 &amp;&amp; xhr.status ==200) &#123;</span><br><span class="line">        console.log(xhr.responseText)  // 获取异步调用返回的数据</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Promise(getData(url)).resolve(data =&gt; data)</span><br><span class="line"></span><br><span class="line"> AJAX状态码：0 - （未初始化）还没有调用send()方法</span><br><span class="line">     1 - （载入）已调用send方法，正在发送请求</span><br><span class="line">     2 - （载入完成呢）send()方法执行完成</span><br><span class="line">     3 - （交互）正在解析相应内容</span><br><span class="line">     4 - （完成）响应内容解析完成，可以在客户端调用了</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">#### 三、函数节流（throttle）</span><br><span class="line">```</span><br><span class="line"> function throttle (func, wait) &#123;</span><br><span class="line">        var timeout;</span><br><span class="line">        var previous = 0;</span><br><span class="line">        return function () &#123;</span><br><span class="line">            context = this;</span><br><span class="line">            args = arguments;</span><br><span class="line">            if (!timeout) &#123;</span><br><span class="line">                timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">                    timeout = null;</span><br><span class="line">                    func.apply(context,args)</span><br><span class="line">                &#125;, wait);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">#### 四、函数防抖（dobounce）</span><br><span class="line">```</span><br><span class="line"> function debounce (func, wait) &#123;</span><br><span class="line">         var timeout;</span><br><span class="line">         return function() &#123;</span><br><span class="line">             var context = this;</span><br><span class="line">             var args = arguments;</span><br><span class="line">             clearTimeout(timeout);</span><br><span class="line">             timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">                 func.apply(context,args)</span><br><span class="line">             &#125;, wait);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">#### 五、实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</span><br><span class="line">```    </span><br><span class="line">    Object.prototype.clone = function() &#123;</span><br><span class="line">      var newObject = this.constructor === Array ? [] : &#123;&#125;  //对象的深拷贝 获取对应的构造函数 [] 或者 &#123;&#125;</span><br><span class="line">      for (let e in this) &#123; //遍历对象的属性 in  this[e]</span><br><span class="line">        newObject[e] = typeof this[e] === &#x27;object&#x27; ? this[e].clone() : this[e]  //对象中的属性如果还是对象 那就继续递归 否则就返回基本的数据类型</span><br><span class="line">      &#125;</span><br><span class="line">      return newObject</span><br><span class="line">    &#125;</span><br><span class="line">```</span><br><span class="line"> </span><br><span class="line">#### 六、实现一个简单的Promise https://juejin.cn/post/6844903625769091079</span><br><span class="line">```</span><br><span class="line">class Promise &#123;</span><br><span class="line">  constructor (executor) &#123;   // executor里面有两个参数，一个叫resolve（成功），一个叫reject（失败）。</span><br><span class="line">    this.status = &#x27;pending&#x27;,</span><br><span class="line">    this.value = undefined;</span><br><span class="line">    this.reason = undefined;</span><br><span class="line">    // 成功存放的数组</span><br><span class="line">    this.onResolvedCallbacks = [];</span><br><span class="line">     // 失败存放法数组</span><br><span class="line">     this.onRejectedCallbacks = [];</span><br><span class="line">    let resolve = (value) =&gt; &#123;</span><br><span class="line">      if (this.status == &#x27;pending&#x27;) &#123;</span><br><span class="line">        this.status = &#x27;resolve&#x27;;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.onResolvedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let reject = (reason) =&gt; &#123;</span><br><span class="line">      if (this.status == &#x27;pending&#x27;) &#123;</span><br><span class="line">        this.status = &#x27;reject&#x27;;</span><br><span class="line">        this.reason = reason;</span><br><span class="line">        this.onRejectedCallbacks.forEach(fn =&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  then (onFullFilled,onRejected) &#123;</span><br><span class="line">    if (this.status == &#x27;resolved&#x27;) &#123;</span><br><span class="line">      onFullFilled(this.value)</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status == &#x27;rejectd&#x27;) &#123;</span><br><span class="line">      onRejected(this.reason);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status == &#x27;pending&#x27;) &#123;</span><br><span class="line">      this.onResolvedCallbacks.push(()=&gt;&#123;</span><br><span class="line">        onFullFilled(this.value);</span><br><span class="line">      &#125;)</span><br><span class="line">      this.onRejectedCallbacks.push(()=&gt; &#123;</span><br><span class="line">          onRejected(this.reason);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve(&#x27;hello world&#x27;)</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line">p.then((data) =&gt;&#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;,(err) =&gt;&#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">&#125;)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">#### 七、发布订阅者模式（观察者模式）</span><br><span class="line">```</span><br><span class="line">var event = &#123;&#125;; // 发布者</span><br><span class="line">event.clientList = [] //发布者的缓存列表</span><br><span class="line"></span><br><span class="line">event.listen = function (fn) &#123;  // 增加订阅者函数</span><br><span class="line">  this.clientList.push(fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.trigger = function () &#123;  // 发布信息</span><br><span class="line">  for (var i =0;i&lt;this.clientList.length;i++) &#123;</span><br><span class="line">    var fn = this.clientList[i];</span><br><span class="line">    fn.apply(this, arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.listen (function(time) &#123;</span><br><span class="line">  console.log(&#x27;正式上班时间为：&#x27; +time)</span><br><span class="line">&#125;)</span><br><span class="line">event.trigger (&#x27;2018/7&#x27;)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">#### 八、手动写一个node服务器</span><br><span class="line">```</span><br><span class="line">const http = require(&#x27;http&#x27;);</span><br><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line">const server = http.createServer((req,res) =&gt; &#123;</span><br><span class="line">if (reu.url == &#x27;/&#x27;) &#123;</span><br><span class="line">const indexFile = fs.createReadStream(&#x27;./index.html&#x27;)</span><br><span class="line">req.writeHead(200,&#123;&#x27;context-Type&#x27;:&#x27;text/html;charset = utf8&#125;)</span><br><span class="line">indexFile.pipe(res)</span><br><span class="line">&#125;</span><br><span class="line">server.listen(8080)</span><br><span class="line">```</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTML </tag>
            
            <tag> Http </tag>
            
            <tag> CSS </tag>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试复习路线</title>
      <link href="/2022/03/01/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2022/03/01/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JavaScript-基础"><a href="#1-JavaScript-基础" class="headerlink" title="1. JavaScript 基础"></a>1. JavaScript 基础</h2><p><img src="../img/javascript.png" alt="image-20220301163103625"></p><h2 id="2-CSS-基础"><a href="#2-CSS-基础" class="headerlink" title="2. CSS 基础"></a>2. CSS 基础</h2><p><img src="../img/css.png" alt="image-20220301162753126"></p><h2 id="3-框架-Vue-为主"><a href="#3-框架-Vue-为主" class="headerlink" title="3. 框架(Vue 为主)"></a>3. 框架(Vue 为主)</h2><p><img src="../img/frame.png" alt="image-20220301162814498"></p><h2 id="4-工程化"><a href="#4-工程化" class="headerlink" title="4. 工程化"></a>4. 工程化</h2><p><img src="../img/webpack.png" alt="image-20220301162824681"></p><h2 id="5-性能优化"><a href="#5-性能优化" class="headerlink" title="5.性能优化"></a>5.性能优化</h2><p><img src="../img/performance.png" alt="image-20220301162854191"></p><h2 id="6-TypeScript"><a href="#6-TypeScript" class="headerlink" title="6. TypeScript"></a>6. TypeScript</h2><p><img src="../img/typescript.png" alt="image-20220301162905975"></p><h2 id="7-网络"><a href="#7-网络" class="headerlink" title="7. 网络"></a>7. 网络</h2><p><img src="../img/http.png" alt="image-20220301162917274"></p><h2 id="8-设计模式"><a href="#8-设计模式" class="headerlink" title="8. 设计模式"></a>8. 设计模式</h2><p><img src="../img/design.png" alt="image-20220301162929421"></p><h2 id="9-数据结构-算法"><a href="#9-数据结构-算法" class="headerlink" title="9. 数据结构/算法"></a>9. 数据结构/算法</h2><p><img src="../img/datastructure.png" alt="image-20220301162944459"></p><h2 id="10-安全"><a href="#10-安全" class="headerlink" title="10. 安全"></a>10. 安全</h2><p><img src="../img/safe.png" alt="image-20220301162958144"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习路线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript深入之作用域链</title>
      <link href="/2022/03/01/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/2022/03/01/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="https://github.com/mqyqingfeng/Blog/issues/4">《JavaScript深入之执行上下文栈》</a>中讲到，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable object，VO)</li><li>作用域链(Scope chain)</li><li>this</li></ul><p>今天重点讲讲作用域链。</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>在<a href="https://github.com/mqyqingfeng/Blog/issues/5">《JavaScript深入之变量对象》</a>中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p><p>下面，让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。</p><h2 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h2><p>在<a href="https://github.com/mqyqingfeng/Blog/issues/3">《JavaScript深入之词法作用域和动态作用域》</a>中讲到，函数的作用域在函数定义的时候就决定了。</p><p>这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    function bar() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数创建时，各自的[[scope]]为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">    fooContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h2><p>当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。</p><p>这时候执行上下文的作用域链，我们命名为 Scope：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure><p>至此，作用域链创建完毕。</p><h2 id="捋一捋"><a href="#捋一捋" class="headerlink" title="捋一捋"></a>捋一捋</h2><p>以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var scope = &quot;global scope&quot;;</span><br><span class="line">function checkscope()&#123;</span><br><span class="line">    var scope2 = &#x27;local scope&#x27;;</span><br><span class="line">    return scope2;</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><p>执行过程如下：</p><p>1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] = [</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    checkscopeContext,</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: undefined</span><br><span class="line">    &#125;，</span><br><span class="line">    Scope: checkscope.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.第三步：将活动对象压入 checkscope 作用域链顶端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">    AO: &#123;</span><br><span class="line">        arguments: &#123;</span><br><span class="line">            length: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        scope2: &#x27;local scope&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    Scope: [AO, [[Scope]]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 作用域链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>史上最强vue总结---面试开发全靠它了</title>
      <link href="/2022/02/27/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BAvue%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E5%BC%80%E5%8F%91%E5%85%A8%E9%9D%A0%E5%AE%83%E4%BA%86/"/>
      <url>/2022/02/27/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BAvue%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E5%BC%80%E5%8F%91%E5%85%A8%E9%9D%A0%E5%AE%83%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<h2 id="vue框架篇"><a href="#vue框架篇" class="headerlink" title="vue框架篇"></a>vue框架篇</h2><h3 id="vue的优点"><a href="#vue的优点" class="headerlink" title="vue的优点"></a>vue的优点</h3><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；</p><p>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</p><p>双向数据绑定：保留了angular的特点，在数据操作方面更为简单；</p><p>组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；</p><p>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p><p>虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；</p><p>运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。</p><h3 id="请详细说下你对vue生命周期的理解？"><a href="#请详细说下你对vue生命周期的理解？" class="headerlink" title="请详细说下你对vue生命周期的理解？"></a>请详细说下你对vue生命周期的理解？</h3><p>总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。</p><blockquote><p>创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el为undefined，还未初始化。</p></blockquote><blockquote><p>载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。</p></blockquote><blockquote><p>更新前/后：当data变化时，会触发beforeUpdate和updated方法</p></blockquote><blockquote><p>销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</p></blockquote><h3 id="为什么vue组件中data必须是一个函数？"><a href="#为什么vue组件中data必须是一个函数？" class="headerlink" title="为什么vue组件中data必须是一个函数？"></a>为什么vue组件中data必须是一个函数？</h3><p>对象为引用类型，当复用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。</p><h3 id="vue中v-if和v-show有什么区别？"><a href="#vue中v-if和v-show有什么区别？" class="headerlink" title="vue中v-if和v-show有什么区别？"></a>vue中v-if和v-show有什么区别？</h3><p>v-if和v-show看起来似乎差不多，当条件不成立时，其所对应的标签元素都不可见，但是这两个选项是有区别的:</p><p>1、v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大。</p><p>2、v-if是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则v-if不会去渲染标签。v-show则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的CSS切换。</p><h3 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h3><h4 id="计算属性computed："><a href="#计算属性computed：" class="headerlink" title="计算属性computed："></a>计算属性computed：</h4><ul><li>支持缓存，只有依赖数据发生改变，才会重新进行计算</li><li>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</li><li>computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</li><li>如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</li></ul><h4 id="侦听属性watch："><a href="#侦听属性watch：" class="headerlink" title="侦听属性watch："></a>侦听属性watch：</h4><ul><li>不支持缓存，数据变，直接会触发相应的操作；</li><li>watch支持异步；</li><li>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</li><li>当一个属性发生变化时，需要执行对应的操作；一对多；</li><li>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：</li></ul><blockquote><p>immediate：组件加载立即触发回调函数执行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  firstName: &#123;</span><br><span class="line">    handler(newName, oldName) &#123;</span><br><span class="line">      this.fullName = newName + &#x27; &#x27; + this.lastName;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 代表在wacth里声明了firstName这个方法之后立即执行handler方法</span><br><span class="line">    immediate: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><blockquote><p>deep: deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    handler(newName, oldName) &#123;</span><br><span class="line">      console.log(&#x27;obj.a changed&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    immediate: true,</span><br><span class="line">    deep: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>优化：我们可以使用字符串的形式监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  &#x27;obj.a&#x27;: &#123;</span><br><span class="line">    handler(newName, oldName) &#123;</span><br><span class="line">      console.log(&#x27;obj.a changed&#x27;);</span><br><span class="line">    &#125;,</span><br><span class="line">    immediate: true,</span><br><span class="line">    // deep: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数。</p><h3 id="vue-loader是什么？使用它的用途有哪些？"><a href="#vue-loader是什么？使用它的用途有哪些？" class="headerlink" title="vue-loader是什么？使用它的用途有哪些？"></a>vue-loader是什么？使用它的用途有哪些？</h3><p>vue文件的一个加载器，跟template/js/style转换成js模块。</p><h3 id="nextTick是什么？"><a href="#nextTick是什么？" class="headerlink" title="$nextTick是什么？"></a>$nextTick是什么？</h3><p>vue实现响应式并不是数据发生变化后dom立即变化，而是按照一定的策略来进行dom更新。</p><blockquote><p>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM</p></blockquote><h3 id="v-for-key的作用"><a href="#v-for-key的作用" class="headerlink" title="v-for key的作用"></a>v-for key的作用</h3><p>当Vue用 v-for 正在更新已渲染过的元素列表是，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p><p>为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。key属性的类型只能为 string或者number类型。</p><p>key 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p><h3 id="Vue的双向数据绑定原理是什么？"><a href="#Vue的双向数据绑定原理是什么？" class="headerlink" title="Vue的双向数据绑定原理是什么？"></a>Vue的双向数据绑定原理是什么？</h3><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p><blockquote><p>1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p></blockquote><blockquote><p>2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p></blockquote><blockquote><p>3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p></blockquote><blockquote><p>4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p></blockquote><h3 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h3><h4 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h4><p>通过props传递</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父组件： &lt;child value = &#x27;传递的数据&#x27; /&gt;</span><br><span class="line"></span><br><span class="line">子组件: props[&#x27;value&#x27;],接收数据,接受之后使用和data中定义数据使用方式一样</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h4><p>在父组件中给子组件绑定一个自定义的事件，子组件通过$emit()触发该事件并传值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">父组件： &lt;child @receive = &#x27;receive&#x27; /&gt;</span><br><span class="line"></span><br><span class="line"> 子组件: this.$emit(&#x27;receive&#x27;,&#x27;传递的数据&#x27;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="兄弟组件传值"><a href="#兄弟组件传值" class="headerlink" title="兄弟组件传值"></a>兄弟组件传值</h4><ul><li>通过中央通信 let bus = new Vue()</li></ul><blockquote><p>A：methods :{ 函数{bus.$emit(‘自定义事件名’，数据)} 发送</p></blockquote><blockquote><p>B：created （）{bus.$on(‘A发送过来的自定义事件名’，函数)} 进行数据接收</p></blockquote><ul><li>通过vuex</li></ul><h3 id="prop-验证，和默认值"><a href="#prop-验证，和默认值" class="headerlink" title="prop 验证，和默认值"></a>prop 验证，和默认值</h3><p>我们在父组件给子组件传值的时候，可以指定该props的默认值及类型，当传递数据类型不正确的时候，vue会发出警告</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    visible: &#123;</span><br><span class="line">        default: true,</span><br><span class="line">        type: Boolean,</span><br><span class="line">        required: true</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h3 id="请说下封装-vue-组件的过程"><a href="#请说下封装-vue-组件的过程" class="headerlink" title="请说下封装 vue 组件的过程"></a>请说下封装 vue 组件的过程</h3><p>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。</p><p>然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</p><h3 id="Vue-js的template编译"><a href="#Vue-js的template编译" class="headerlink" title="Vue.js的template编译"></a>Vue.js的template编译</h3><p>简而言之，就是先转化成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点），详细步骤如下：</p><blockquote><p>首先，通过compile编译器把template编译成AST语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。</p></blockquote><blockquote><p>然后，AST会经过generate（将AST语法树转化成render funtion字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等等）</p></blockquote><h3 id="scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？"><a href="#scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？" class="headerlink" title="scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？"></a>scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</h3><p>css的预编译,使用步骤如下：</p><p>第一步：用npm 下三个loader（sass-loader、css-loader、node-sass）</p><p>第二步：在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss</p><p>第三步：还是在同一个文件，配置一个module属性</p><p>第四步：然后在组件的style标签加上lang属性 ，例如：lang=”scss”</p><p>特性主要有:</p><ul><li>可以用变量，例如（$变量名称=值）</li><li>可以用混合器，例如（）</li><li>可以嵌套</li></ul><h3 id="vue如何监听对象或者数组某个属性的变化"><a href="#vue如何监听对象或者数组某个属性的变化" class="headerlink" title="vue如何监听对象或者数组某个属性的变化"></a>vue如何监听对象或者数组某个属性的变化</h3><p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。</p><p>解决方式：</p><ul><li>this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$set(this.arr, 0, &quot;OBKoro1&quot;); // 改变数组</span><br><span class="line">this.$set(this.obj, &quot;c&quot;, &quot;OBKoro1&quot;); // 改变对象</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>调用以下几个数组的方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">splice()、 push()、pop()、shift()、unshift()、sort()、reverse()</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用我们再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除/添加操作</p><h3 id="常用的事件修饰符"><a href="#常用的事件修饰符" class="headerlink" title="常用的事件修饰符"></a>常用的事件修饰符</h3><ul><li>.stop:阻止冒泡</li><li>.prevent:阻止默认行为</li><li>.self:仅绑定元素自身触发</li><li>.once: 2.1.4 新增,只触发一次</li><li>passive: 2.3.0 新增,滚动事件的默认行为 (即滚动行为) 将会立即触发,不能和.prevent 一起使用</li><li>.sync 修饰符</li></ul><p>从 2.3.0 起vue重新引入了.sync修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;复制代码</span><br></pre></td></tr></table></figure><p>会被扩展为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;复制代码</span><br></pre></td></tr></table></figure><p>当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$emit(&#x27;update:foo&#x27;, newValue)复制代码</span><br></pre></td></tr></table></figure><h3 id="vue如何获取dom"><a href="#vue如何获取dom" class="headerlink" title="vue如何获取dom"></a>vue如何获取dom</h3><p>先给标签设置一个ref值，再通过this.$refs.domName获取，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ref=&quot;test&quot;&gt;&lt;/div&gt;const dom = this.$refs.test复制代码</span><br></pre></td></tr></table></figure><h3 id="v-on可以监听多个方法吗？"><a href="#v-on可以监听多个方法吗？" class="headerlink" title="v-on可以监听多个方法吗？"></a>v-on可以监听多个方法吗？</h3><p>是可以的，来个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; v-on=&quot;&#123; input:onInput,focus:onFocus,blur:onBlur, &#125;&quot;&gt;复制代码</span><br></pre></td></tr></table></figure><h3 id="assets和static的区别"><a href="#assets和static的区别" class="headerlink" title="assets和static的区别"></a>assets和static的区别</h3><p>这两个都是用来存放项目中所使用的静态资源文件。</p><p>两者的区别：</p><p>assets中的文件在运行npm run build的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到static中。</p><p>static中的文件则不会被打包。</p><blockquote><p>建议：将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了。</p></blockquote><h3 id="slot插槽"><a href="#slot插槽" class="headerlink" title="slot插槽"></a>slot插槽</h3><p>很多时候，我们封装了一个子组件之后，在父组件使用的时候，想添加一些dom元素，这个时候就可以使用slot插槽了，但是这些dom是否显示以及在哪里显示，则是看子组件中slot组件的位置了。</p><h3 id="vue初始化页面闪动问题"><a href="#vue初始化页面闪动问题" class="headerlink" title="vue初始化页面闪动问题"></a>vue初始化页面闪动问题</h3><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是我们还是有必要让解决这个问题的。</p><p>首先：在css里加上以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[v-cloak] &#123;    display: none;&#125;复制代码</span><br></pre></td></tr></table></figure><p>如果没有彻底解决问题，则在根元素加上style=”display: none;” :style=”{display: ‘block’}”</p><h2 id="vue插件篇"><a href="#vue插件篇" class="headerlink" title="vue插件篇"></a>vue插件篇</h2><h3 id="状态管理（vuex）"><a href="#状态管理（vuex）" class="headerlink" title="状态管理（vuex）"></a>状态管理（vuex）</h3><h4 id="vuex是什么"><a href="#vuex是什么" class="headerlink" title="vuex是什么"></a>vuex是什么</h4><p>Vuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p><h4 id="怎么使用vuex"><a href="#怎么使用vuex" class="headerlink" title="怎么使用vuex"></a>怎么使用vuex</h4><p>第一步安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex -S复制代码</span><br></pre></td></tr></table></figure><p>第二步创建store</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;;import Vuex from &#x27;vuex&#x27;;Vue.use(Vuex);//不是在生产环境debug为trueconst debug = process.env.NODE_ENV !== &#x27;production&#x27;;//创建Vuex实例对象const store = new Vuex.Store(&#123;    strict:debug,//在不是生产环境下都开启严格模式    state:&#123;    &#125;,    getters:&#123;    &#125;,    mutations:&#123;    &#125;,    actions:&#123;    &#125;&#125;)export default store;复制代码</span><br></pre></td></tr></table></figure><p>第三步注入vuex</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;import store from &#x27;./store&#x27;;const vm = new Vue(&#123;    store:store,    render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;)复制代码</span><br></pre></td></tr></table></figure><h4 id="vuex中有几个核心属性，分别是什么？"><a href="#vuex中有几个核心属性，分别是什么？" class="headerlink" title="vuex中有几个核心属性，分别是什么？"></a>vuex中有几个核心属性，分别是什么？</h4><p>一共有5个核心属性，分别是:</p><ul><li>state 唯一数据源,Vue 实例中的 data 遵循相同的规则</li><li>getters 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;  state: &#123;    todos: [      &#123; id: 1, text: &#x27;...&#x27;, done: true &#125;,      &#123; id: 2, text: &#x27;...&#x27;, done: false &#125;    ]  &#125;,  getters: &#123;    doneTodos: state =&gt; &#123;      return state.todos.filter(todo =&gt; todo.done)    &#125;  &#125;&#125;)store.getters.doneTodos // -&gt; [&#123; id: 1, text: &#x27;...&#x27;, done: true &#125;]复制代码</span><br></pre></td></tr></table></figure><ul><li>mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,非常类似于事件,通过store.commit 方法触发</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;  state: &#123;    count: 1  &#125;,  mutations: &#123;    increment (state) &#123;      // 变更状态      state.count++    &#125;  &#125;&#125;)store.commit(&#x27;increment&#x27;)复制代码</span><br></pre></td></tr></table></figure><ul><li>action Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  mutations: &#123;    increment (state) &#123;      state.count++    &#125;  &#125;,  actions: &#123;    increment (context) &#123;      context.commit(&#x27;increment&#x27;)    &#125;  &#125;&#125;)复制代码</span><br></pre></td></tr></table></figure><ul><li>module  由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;  state: () =&gt; (&#123; ... &#125;),  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;,  getters: &#123; ... &#125;&#125;const moduleB = &#123;  state: () =&gt; (&#123; ... &#125;),  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123;  modules: &#123;    a: moduleA,    b: moduleB  &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态复制代码</span><br></pre></td></tr></table></figure><h4 id="ajax请求代码应该写在组件的methods中还是vuex的actions中"><a href="#ajax请求代码应该写在组件的methods中还是vuex的actions中" class="headerlink" title="ajax请求代码应该写在组件的methods中还是vuex的actions中"></a>ajax请求代码应该写在组件的methods中还是vuex的actions中</h4><p>如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。</p><p>如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用。</p><h4 id="从vuex中获取的数据能直接更改吗？"><a href="#从vuex中获取的数据能直接更改吗？" class="headerlink" title="从vuex中获取的数据能直接更改吗？"></a>从vuex中获取的数据能直接更改吗？</h4><p>从vuex中取的数据，不能直接更改，需要浅拷贝对象之后更改，否则报错；</p><h4 id="vuex中的数据在页面刷新后数据消失"><a href="#vuex中的数据在页面刷新后数据消失" class="headerlink" title="vuex中的数据在页面刷新后数据消失"></a>vuex中的数据在页面刷新后数据消失</h4><p>用sessionstorage 或者 localstorage 存储数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存储： sessionStorage.setItem( &#x27;名&#x27;, JSON.stringify(值) )使用： sessionStorage.getItem(&#x27;名&#x27;) ---得到的值为字符串类型，用JSON.parse()去引号；复制代码</span><br></pre></td></tr></table></figure><p>也可以引入插件vuex-persist，使用方法如下：</p><ul><li>安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save vuex-persistoryarn add vuex-persist复制代码</span><br></pre></td></tr></table></figure><ul><li>引入</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import VuexPersistence from &#x27;vuex-persist&#x27;复制代码</span><br></pre></td></tr></table></figure><ul><li>先创建一个对象并进行配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const vuexLocal = new VuexPersistence(&#123;    storage: window.localStorage&#125;)复制代码</span><br></pre></td></tr></table></figure><ul><li>引入进vuex插件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;  state: &#123; ... &#125;,  mutations: &#123; ... &#125;,  actions: &#123; ... &#125;,  plugins: [vuexLocal.plugin]&#125;) 复制代码</span><br></pre></td></tr></table></figure><p>通过以上设置，在图3中各个页面之间跳转，如果刷新某个视图，数据并不会丢失，依然存在，并且不需要在每个 mutations 中手动存取 storage 。</p><h4 id="Vuex的严格模式是什么-有什么作用-怎么开启？"><a href="#Vuex的严格模式是什么-有什么作用-怎么开启？" class="headerlink" title="Vuex的严格模式是什么,有什么作用,怎么开启？"></a>Vuex的严格模式是什么,有什么作用,怎么开启？</h4><p>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p><p>在Vuex.Store 构造器选项中开启,如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const store = new Vuex.Store(&#123;    strict:true,&#125;)复制代码</span><br></pre></td></tr></table></figure><h4 id="怎么在组件中批量使用Vuex的getter属性"><a href="#怎么在组件中批量使用Vuex的getter属性" class="headerlink" title="怎么在组件中批量使用Vuex的getter属性"></a>怎么在组件中批量使用Vuex的getter属性</h4><p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;mapGetters&#125; from &#x27;vuex&#x27;export default&#123;    computed:&#123;        ...mapGetters([&#x27;total&#x27;,&#x27;discountTotal&#x27;])    &#125;&#125;复制代码</span><br></pre></td></tr></table></figure><h4 id="组件中重复使用mutation"><a href="#组件中重复使用mutation" class="headerlink" title="组件中重复使用mutation"></a>组件中重复使用mutation</h4><p>使用mapMutations辅助函数,在组件中这么使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapMutations &#125; from &#x27;vuex&#x27;methods:&#123;    ...mapMutations(&#123;        setNumber:&#x27;SET_NUMBER&#x27;,    &#125;)&#125;复制代码</span><br></pre></td></tr></table></figure><p>然后调用this.setNumber(10)相当调用this.$store.commit(‘SET_NUMBER’,10)</p><h4 id="mutation和action有什么区别"><a href="#mutation和action有什么区别" class="headerlink" title="mutation和action有什么区别"></a>mutation和action有什么区别</h4><ul><li>action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态</li><li>action 可以包含任意异步操作。mutation只能是同步操作</li><li>提交方式不同</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action 是用this.store.dispatch(&#x27;ACTION_NAME&#x27;,data)来提交。mutation是用this.$store.commit(&#x27;SET_NUMBER&#x27;,10)来提交复制代码</span><br></pre></td></tr></table></figure><ul><li>接收参数不同，mutation第一个参数是state，而action第一个参数是context，其包含了</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;    state,      // 等同于 `store.state`，若在模块中则为局部状态    rootState,  // 等同于 `store.state`，只存在于模块中    commit,     // 等同于 `store.commit`    dispatch,   // 等同于 `store.dispatch`    getters,    // 等同于 `store.getters`    rootGetters // 等同于 `store.getters`，只存在于模块中&#125;复制代码</span><br></pre></td></tr></table></figure><h4 id="在v-model上怎么用Vuex中state的值？"><a href="#在v-model上怎么用Vuex中state的值？" class="headerlink" title="在v-model上怎么用Vuex中state的值？"></a>在v-model上怎么用Vuex中state的值？</h4><p>需要通过computed计算属性来转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;message&quot;&gt;// ...computed: &#123;    message: &#123;        get () &#123;            return this.$store.state.message        &#125;,        set (value) &#123;            this.$store.commit(&#x27;updateMessage&#x27;, value)        &#125;    &#125;&#125;复制代码</span><br></pre></td></tr></table></figure><h3 id="路由页面管理（vue-router）"><a href="#路由页面管理（vue-router）" class="headerlink" title="路由页面管理（vue-router）"></a>路由页面管理（vue-router）</h3><h4 id="什么是vue-router"><a href="#什么是vue-router" class="headerlink" title="什么是vue-router"></a>什么是vue-router</h4><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p><ul><li>嵌套的路由/视图表</li><li>模块化的、基于组件的路由配置</li><li>路由参数、查询、通配符</li><li>基于 Vue.js 过渡系统的视图过渡效果</li><li>细粒度的导航控制</li><li>带有自动激活的 CSS class 的链接</li><li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li><li>自定义的滚动条行为</li></ul><h4 id="怎么使用vue-router"><a href="#怎么使用vue-router" class="headerlink" title="怎么使用vue-router"></a>怎么使用vue-router</h4><p>第一步安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router -S</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>第二步在main.js中使用Vue Router组件</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/14/1734d65dc240568e~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>第三步配置路由</p><ul><li>定义 (路由) 组件</li></ul><p>路由组件可以是直接定义，也可以是导入已经定义好的组件。这里导入已经定义好的组件。如下</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/14/1734d65dc2668cc8~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ul><li>定义路由（路由对象数组）</li></ul><p>定义路由对象数组。对象的path是自定义的路径（即使用这个路径可以找到对应的组件），component是指该路由对应的组件。如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/14/1734d65dc3da62ed~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ul><li>实例化Vue Router对象</li></ul><p>调用Vue Router的构造方法创建一个Vue Router的实例对象，将上一步定义的路由对象数组作为参数对象的值传入。如下</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/14/1734d65dc48e8bf4~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><ul><li>挂载根实例</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/14/1734d65dcb5f42d7~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><p>第四步在App.vue中使用路由</p><p>在App.vue中使用标签来显示路由对应的组件，使用标签指定当点击时显示的对应的组件，to属性就是指定组件对应的路由。如下：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/14/1734d65dc512c1e6~tplv-t2oaga2asx-watermark.awebp" alt="img"></p><h4 id="怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"><a href="#怎么定义vue-router的动态路由？怎么获取传过来的动态参数？" class="headerlink" title="怎么定义vue-router的动态路由？怎么获取传过来的动态参数？"></a>怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</h4><p>在router目录下的index.js文件中，对path属性加上/:id。使用router对象的params.id获取动态参数</p><h4 id="vue-router的导航钩子"><a href="#vue-router的导航钩子" class="headerlink" title="vue-router的导航钩子"></a>vue-router的导航钩子</h4><p>常用的是router.beforeEach(to,from,next)，在跳转前进行权限判断。一共有三种：</p><ul><li>全局导航钩子：router.beforeEach(to,from,next)</li><li>组件内的钩子</li><li>单独路由独享组件</li></ul><h4 id="vue路由传参"><a href="#vue路由传参" class="headerlink" title="vue路由传参"></a>vue路由传参</h4><blockquote><p>使用query方法传入的参数使用this.$route.query接受</p></blockquote><blockquote><p>使用params方式传入的参数使用this.$route.params接受</p></blockquote><h4 id="router和route的区别"><a href="#router和route的区别" class="headerlink" title="router和route的区别"></a>router和route的区别</h4><blockquote><p>route为当前router跳转对象里面可以获取name、path、query、params等</p></blockquote><blockquote><p>router为VueRouter实例，想要导航到不同URL，则使用router.push方法</p></blockquote><h4 id="路由-TypeError-Cannot-read-property-‘matched’-of-undefined-的错误问题"><a href="#路由-TypeError-Cannot-read-property-‘matched’-of-undefined-的错误问题" class="headerlink" title="路由 TypeError: Cannot read property ‘matched’ of undefined 的错误问题"></a>路由 TypeError: Cannot read property ‘matched’ of undefined 的错误问题</h4><p>找到入口文件main.js里的new Vue()，必须使用router名，不能把router改成Router或者其他的别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 引入路由</span><br><span class="line">import router from &#x27;./routers/router.js&#x27;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    router,    // 这个名字必须使用router</span><br><span class="line">    render: h =&gt; h(App)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="路由按需加载"><a href="#路由按需加载" class="headerlink" title="路由按需加载"></a>路由按需加载</h4><p>随着项目功能模块的增加，引入的文件数量剧增。如果不做任何处理，那么首屏加载会相当的缓慢，这个时候，路由按需加载就闪亮登场了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">webpack&lt; 2.4 时</span><br><span class="line">&#123; </span><br><span class="line">    path:&#x27;/&#x27;, </span><br><span class="line">    name:&#x27;home&#x27;,</span><br><span class="line">    components:resolve=&gt;require([&#x27;@/components/home&#x27;],resolve)</span><br><span class="line">&#125; </span><br><span class="line">webpack&gt; 2.4 时</span><br><span class="line">&#123; </span><br><span class="line">    path:&#x27;/&#x27;, </span><br><span class="line">    name:&#x27;home&#x27;, </span><br><span class="line">    components:()=&gt;import(&#x27;@/components/home&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>import()方法是由es6提出的，动态加载返回一个Promise对象，then方法的参数是加载到的模块。类似于Node.js的require方法，主要import()方法是异步加载的。</p><h4 id="Vue里面router-link在电脑上有用，在安卓上没反应怎么解决"><a href="#Vue里面router-link在电脑上有用，在安卓上没反应怎么解决" class="headerlink" title="Vue里面router-link在电脑上有用，在安卓上没反应怎么解决"></a>Vue里面router-link在电脑上有用，在安卓上没反应怎么解决</h4><p>Vue路由在Android机上有问题，babel问题，安装babel polypill插件解决</p><h4 id="Vue2中注册在router-link上事件无效解决方法"><a href="#Vue2中注册在router-link上事件无效解决方法" class="headerlink" title="Vue2中注册在router-link上事件无效解决方法"></a>Vue2中注册在router-link上事件无效解决方法</h4><p>使用@click.native。原因：router-link会阻止click事件，.native指直接监听一个原生事件</p><h4 id="RouterLink在IE和Firefox中不起作用（路由不跳转）的问题"><a href="#RouterLink在IE和Firefox中不起作用（路由不跳转）的问题" class="headerlink" title="RouterLink在IE和Firefox中不起作用（路由不跳转）的问题"></a>RouterLink在IE和Firefox中不起作用（路由不跳转）的问题</h4><ul><li>只用a标签，不使用button标签</li><li>使用button标签和Router.navigate方法</li></ul><h3 id="网络请求-axios"><a href="#网络请求-axios" class="headerlink" title="网络请求(axios)"></a>网络请求(axios)</h3><p>这个模块请看我的另一篇文章，此处不再整理（我太懒了）</p><p><a href="https://juejin.cn/post/6847009771606769677">学会了axios封装，世界都是你的</a></p><h3 id="视频播放-video-js"><a href="#视频播放-video-js" class="headerlink" title="视频播放(video.js)"></a>视频播放(video.js)</h3><p>这个模块请看我的另一篇文章，此处不再整理（我太懒了）</p><p><a href="https://juejin.cn/post/6850037269227634702">手把手从零开始—封装一个vue视频播放器组件</a></p><h3 id="vue常用ui库"><a href="#vue常用ui库" class="headerlink" title="vue常用ui库"></a>vue常用ui库</h3><h4 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h4><ul><li>mint-ui （<a href="http://mint-ui.github.io/#!/zh-cn%EF%BC%89">http://mint-ui.github.io/#!/zh-cn）</a></li><li>Vant（<a href="https://youzan.github.io/vant/#/zh-CN/home%EF%BC%89">https://youzan.github.io/vant/#/zh-CN/home）</a></li><li>VUX (<a href="https://vux.li/">https://vux.li/</a>)</li></ul><h4 id="pc端"><a href="#pc端" class="headerlink" title="pc端"></a>pc端</h4><ul><li>element-ui（<a href="https://element.eleme.cn/2.13/#/zh-CN/component/installation%EF%BC%89">https://element.eleme.cn/2.13/#/zh-CN/component/installation）</a></li><li>Ant Design of Vue（<a href="https://www.antdv.com/docs/vue/introduce-cn/%EF%BC%89">https://www.antdv.com/docs/vue/introduce-cn/）</a></li><li>Avue (<a href="https://avuejs.com/">https://avuejs.com/</a>)</li></ul><h2 id="常用webpack配置"><a href="#常用webpack配置" class="headerlink" title="常用webpack配置"></a>常用webpack配置</h2><h3 id="vue-lic3脚手架（vue-config-js）"><a href="#vue-lic3脚手架（vue-config-js）" class="headerlink" title="vue-lic3脚手架（vue.config.js）"></a>vue-lic3脚手架（vue.config.js）</h3><h4 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h4><p>类型：String</p><p>默认：’/‘</p><p>部署应用包时的基本 URL。默认情况下，Vue CLI会假设你的应用是被部署在一个域名的根路径上，例如<a href="https://www.my-app.com/%E3%80%82%E5%A6%82%E6%9E%9C%E5%BA%94%E7%94%A8%E8%A2%AB%E9%83%A8%E7%BD%B2%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%AD%90%E8%B7%AF%E5%BE%84%E4%B8%8A%EF%BC%8C%E4%BD%A0%E5%B0%B1%E9%9C%80%E8%A6%81%E7%94%A8%E8%BF%99%E4%B8%AA%E9%80%89%E9%A1%B9%E6%8C%87%E5%AE%9A%E8%BF%99%E4%B8%AA%E5%AD%90%E8%B7%AF%E5%BE%84%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E8%A2%AB%E9%83%A8%E7%BD%B2%E5%9C%A8https://www.my-app.com/my-app/%EF%BC%8C%E5%88%99%E8%AE%BE%E7%BD%AEpublicPath%E4%B8%BA/my-app/">https://www.my-app.com/。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在https://www.my-app.com/my-app/，则设置publicPath为/my-app/</a></p><p>这个值也可以被设置为空字符串 (‘’) 或是相对路径 (‘./‘)，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似 Cordova hybrid 应用的文件系统中。</p><h4 id="productionSourceMap"><a href="#productionSourceMap" class="headerlink" title="productionSourceMap"></a>productionSourceMap</h4><p>类型：boolean</p><p>moren：true</p><p>不允许打包时生成项目来源映射文件，在生产环境下可以显著的减少包的体积</p><blockquote><p>注 Source map的作用：针对打包后的代码进行的处理，就是一个信息文件，里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。有了它，出错的时候，除错工具将直接显示原始代码，而不是转换后的代码。这无疑给开发者带来了很大方便</p></blockquote><h4 id="assetsDir"><a href="#assetsDir" class="headerlink" title="assetsDir"></a>assetsDir</h4><p>放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录,默认是’’,</p><h4 id="indexPath"><a href="#indexPath" class="headerlink" title="indexPath"></a>indexPath</h4><p>指定生成的 index.html 的输出路径(相对于outputDir)。也可以是一个绝对路径。默认是’index.html’</p><h4 id="lintOnSave"><a href="#lintOnSave" class="headerlink" title="lintOnSave"></a>lintOnSave</h4><p>是否在每次保存时使用eslint检查，这个对语法的要求比较严格，对自己有要求的同学可以使用</p><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">css: &#123;    //是否启用css分离插件，默认是true，如果不启用css样式分离插件，打包出来的css是通过内联样式的方式注入至dom中的，    extract: true,    sourceMap: false,//效果同上    modules: false,// 为所有的 CSS 及其预处理文件开启 CSS Modules。    // 这个选项不会影响 `*.vue` 文件。  &#125;,复制代码</span><br></pre></td></tr></table></figure><h4 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h4><p>本地开发服务器配置，此处直接贴上我常用的配置，以注释的方式介绍</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123; </span><br><span class="line">    //配置开发服务器</span><br><span class="line">    host: &quot;0.0.0.0&quot;,</span><br><span class="line">    //是否启用热加载，就是每次更新代码，是否需要重新刷新浏览器才能看到新代码效果</span><br><span class="line">    hot: true,</span><br><span class="line">    //服务启动端口</span><br><span class="line">    port: &quot;8080&quot;,</span><br><span class="line">    //是否自动打开浏览器默认为false</span><br><span class="line">    open: false,</span><br><span class="line">    //配置http代理</span><br><span class="line">    proxy: &#123; </span><br><span class="line">      &quot;/api&quot;: &#123; //如果ajax请求的地址是http://192.168.0.118:9999/api1那么你就可以在jajx中使用/api/api1路径,其请求路径会解析</span><br><span class="line">        // http://192.168.0.118:9999/api1，当然你在浏览器上开到的还是http://localhost:8080/api/api1;</span><br><span class="line">        target: &quot;http://192.168.0.118:9999&quot;,</span><br><span class="line">        //是否允许跨域，这里是在开发环境会起作用，但在生产环境下，还是由后台去处理，所以不必太在意</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">            //把多余的路径置为&#x27;&#x27;</span><br><span class="line">          &quot;api&quot;: &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;/api2&quot;: &#123;//可以配置多个代理，匹配上那个就使用哪种解析方式</span><br><span class="line">        target: &quot;http://api2&quot;,</span><br><span class="line">        // ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="pluginOptions"><a href="#pluginOptions" class="headerlink" title="pluginOptions"></a>pluginOptions</h4><p>这是一个不进行任何 schema 验证的对象，因此它可以用来传递任何第三方插件选项，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    //定义一个全局的less文件，把公共样式变量放入其中，这样每次使用的时候就不用重新引用了</span><br><span class="line">    &#x27;style-resources-loader&#x27;: &#123;</span><br><span class="line">      preProcessor: &#x27;less&#x27;,</span><br><span class="line">      patterns: [</span><br><span class="line">        &#x27;./src/assets/public.less&#x27;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="chainWebpack"><a href="#chainWebpack" class="headerlink" title="chainWebpack"></a>chainWebpack</h4><p>是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chainWebpack(config) &#123; </span><br><span class="line">//添加一个路径别名 假设有在assets/img/menu/目录下有十张图片，如果全路径require(&quot;/assets/img/menu/img1.png&quot;)</span><br><span class="line">//去引入在不同的层级下实在是太不方便了，这时候向下方一样定义一个路劲别名就很实用了</span><br><span class="line">    config.resolve.alias</span><br><span class="line">      //添加多个别名支持链式调用</span><br><span class="line">      .set(&quot;assets&quot;, path.join(__dirname, &quot;/src/assets&quot;))</span><br><span class="line">      .set(&quot;img&quot;, path.join(__dirname, &quot;/src/assets/img/menu&quot;))</span><br><span class="line">      //引入图片时只需require(&quot;img/img1.png&quot;);即可</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>参考：</p><p>1、Vue常见问题总结 <a href="https://blog.csdn.net/qq_27674439/article/details/99449197">https://blog.csdn.net/qq_27674439/article/details/99449197</a></p><p>2、vue常见面试题 <a href="https://zhuanlan.zhihu.com/p/92407628">https://zhuanlan.zhihu.com/p/92407628</a></p><p>3、vuex官网 <a href="https://vuex.vuejs.org/zh/">https://vuex.vuejs.org/zh/</a></p><p>4、Vuex面试题汇总 <a href="https://juejin.cn/post/6844903993374670855">https://juejin.cn/post/6844903993374670855</a></p><p>5、Vue CLI官网 <a href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></p><p>历史好文推荐：</p><p>1、<a href="https://juejin.cn/post/6850418118695583758">【万字长文】史上最强css、html总结~看完涨薪不再是梦</a></p><p>2、<a href="https://juejin.cn/post/6854573211451932685">【万字长文】最全JavaScript基础总结~建议收藏 </a></p><p>3、<a href="https://juejin.cn/post/6847902222882340872">Event Loop我知道，宏任务微任务是什么鬼？</a></p><p>4、<a href="https://juejin.cn/post/6847009771493523464">锋利码农武器之vscode</a></p><p>5、<a href="https://juejin.cn/post/6847009771371888653">面试宝典带你走上人生巅峰</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS如何优雅的获取浮点数的整数和小数部分</title>
      <link href="/2022/01/08/JS%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%8E%B7%E5%8F%96%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%95%B4%E6%95%B0%E5%92%8C%E5%B0%8F%E6%95%B0%E9%83%A8%E5%88%86/"/>
      <url>/2022/01/08/JS%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%8E%B7%E5%8F%96%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%95%B4%E6%95%B0%E5%92%8C%E5%B0%8F%E6%95%B0%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h3 id="1-取整数"><a href="#1-取整数" class="headerlink" title="1.取整数"></a>1.取整数</h3><p>1.parseInt</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">3.75</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(num)); <span class="comment">// 3</span></span><br><span class="line">num = -<span class="number">3.75</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(num)); <span class="comment">// -3</span></span><br></pre></td></tr></table></figure><p>用parseInt取整数，结果是没问题的，但是如果<strong>严格来说</strong>，其实<strong>parseInt并不是设计用来取整数的</strong>。</p><blockquote><p><strong>👉🏻 知识点：</strong><code>parseInt(string, radix)`` </code>这个方法是一个将字符串转换为整数的方法，它有两个参数，第一个参数表示要转换的字符串，如果参数不是一个字符串，则将其转换为字符串。第二个参数是基数即进制，默认为10。</p></blockquote><p>所以用 parseInt 方法取整数，有<strong>两个不好的地方</strong>，一是 parseInt 这个函数名，看起来就是将字符串转整数的，用在这里不是很适合，另一个是转字符串有点多此一举，而且肯定会带来性能开销，所以使用 parseInt 虽然方便，但不是最好的办法。</p><p>2.Math方法</p><p>其中 Math.round 是四舍五入的，Math.ceil 是向上取整，Math.floor 是向下取整。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trunc</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Math</span>.floor(num) <span class="comment">//如果小于0 向上取整</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.ceil(num) <span class="comment">//向下取整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.位操作</p><p>使用位操作方法，在运算过程中会把操作数转为成32位整数，如此，运算后的结果就是整数部分了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">3.75</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num | <span class="number">0</span>); <span class="comment">// 3</span></span><br><span class="line">num = -num;</span><br><span class="line"><span class="built_in">console</span>.log(num | <span class="number">0</span>); <span class="comment">// -3</span></span><br></pre></td></tr></table></figure><p>但是这样做也有缺陷</p><blockquote><p>👉🏻 <strong>冷知识</strong>：因为bitwise操作将操作数转为Int32，所以它不能处理超过32位的数值取整，而JavaScript有效整数的范围是53位。</p></blockquote><p>当数值范围超过32位时，它将不能对数值取整，而JavaScript有效整数的范围是53位。</p><p>那么用“|”有什么<strong>好处</strong>呢？如果考虑js文件大小，那么<strong>a|0</strong>与其他方式比较，是最短的方式，所以如果要考虑压缩代码的大小，且明确知道数值范围不会超过32位整数的时候，可以考虑使用这个技巧。</p><h3 id="2-取小数"><a href="#2-取小数" class="headerlink" title="2.取小数"></a>2.取小数</h3><p>1.parseInt+split</p><p>将数值转换成2字符串后切割并转换回数值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">12.76</span></span><br><span class="line"><span class="keyword">const</span> integer = <span class="built_in">parseInt</span>(num.toString().split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">const</span> decimal = <span class="built_in">parseInt</span>(num.toString().split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>])<span class="comment">//取小数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;integer&#125;</span>.<span class="subst">$&#123;decimal&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>2.Math.trunc()</p><p>先用<code>Math.trunc(num)</code>取整，然后再与原数相减，就得到了小数部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fract</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num - <span class="built_in">Math</span>.trunc(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fract(<span class="number">3.75</span>)); <span class="comment">// 0.75</span></span><br><span class="line"><span class="built_in">console</span>.log(fract(-<span class="number">3.75</span>)); <span class="comment">// -0.75</span></span><br></pre></td></tr></table></figure><p>3.取模运算</p><blockquote><p><strong>👉🏻 知识点：</strong> JavaScript的取模运算%并不限于整数运算，可以对浮点数取模。</p></blockquote><p>所以，直接将原数对1取模，即可获得小数部分！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">3.75</span> % <span class="number">1</span>); <span class="comment">// 0.75</span></span><br><span class="line"><span class="built_in">console</span>.log(-<span class="number">3.75</span> % <span class="number">1</span>); <span class="comment">// -0.75</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写new</title>
      <link href="/2022/01/08/%E6%89%8B%E5%86%99new/"/>
      <url>/2022/01/08/%E6%89%8B%E5%86%99new/</url>
      
        <content type="html"><![CDATA[<p>先用文字描述一下 new 的实现过程</p><ul><li>新定义一个 json 对象</li><li>对象 继承 构造函数的原型链</li><li>将构造函数的 this 指向这个对象</li><li>根据构造函数的返回值类型返回结果</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn,...args</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125; <span class="comment">//创建一个新的对象</span></span><br><span class="line">    obj.__proto__ = fn.prototype <span class="comment">//对象继承构造函数的原型链</span></span><br><span class="line">    fn.apply(obj,args) <span class="comment">//将构造函数的this指向这个对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">this</span>.name = <span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">this</span>.age = <span class="built_in">arguments</span>[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">this</span>.gender = <span class="built_in">arguments</span>[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"> Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;你好呀,我是&quot;</span>,<span class="built_in">this</span>.name);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据测试</span></span><br><span class="line"> <span class="keyword">let</span> test = myNew(Person,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"> test.sayHello()</span><br><span class="line"> <span class="built_in">console</span>.log(test.name);</span><br><span class="line"> <span class="built_in">console</span>.log(test.age);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
