<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试知识整理 | AstronautBlog</title><meta name="keywords" content="JavaScript,HTML,Http,CSS,Webpack"><meta name="author" content="zzm,957957209@qq.com"><meta name="copyright" content="zzm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="面试复习1.JavaScript 基础 1.执行上下文&#x2F;作用域&#x2F;闭包1.什么是执行上下文?执行上下文是评估和执行JavaScript代码环境的抽象概念。每当JavaScript代码在运行时，他都是在执行上下文中运行。  执行上下文的类型 JavaScript共有三种执行上下文类型  全局执行上下文 这是基础的上下文,任何不在函数内部的代码都在全局上下文中.他会执行两件事:创建一个全局的window">
<meta property="og:type" content="article">
<meta property="og:title" content="面试知识整理">
<meta property="og:url" content="http://example.com/2022/03/13/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="AstronautBlog">
<meta property="og:description" content="面试复习1.JavaScript 基础 1.执行上下文&#x2F;作用域&#x2F;闭包1.什么是执行上下文?执行上下文是评估和执行JavaScript代码环境的抽象概念。每当JavaScript代码在运行时，他都是在执行上下文中运行。  执行上下文的类型 JavaScript共有三种执行上下文类型  全局执行上下文 这是基础的上下文,任何不在函数内部的代码都在全局上下文中.他会执行两件事:创建一个全局的window">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041355284.jpg">
<meta property="article:published_time" content="2022-03-13T13:05:16.000Z">
<meta property="article:modified_time" content="2022-03-14T10:08:42.544Z">
<meta property="article:author" content="zzm">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="HTML">
<meta property="article:tag" content="Http">
<meta property="article:tag" content="CSS">
<meta property="article:tag" content="Webpack">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041355284.jpg"><link rel="shortcut icon" href="/./img/first.png"><link rel="canonical" href="http://example.com/2022/03/13/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试知识整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-14 18:08:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avater1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-folder-ope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 我的</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041355284.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">AstronautBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-folder-ope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 我的</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试知识整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-13T13:05:16.000Z" title="发表于 2022-03-13 21:05:16">2022-03-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-14T10:08:42.544Z" title="更新于 2022-03-14 18:08:42">2022-03-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%9D%82%E7%83%A9/">前端知识杂烩</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试知识整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="面试复习"><a href="#面试复习" class="headerlink" title="面试复习"></a>面试复习</h1><h2 id="1-JavaScript-基础"><a href="#1-JavaScript-基础" class="headerlink" title="1.JavaScript 基础"></a>1.JavaScript 基础</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132100087.png" alt="image-20220308142823940"></p>
<h3 id="1-执行上下文-作用域-闭包"><a href="#1-执行上下文-作用域-闭包" class="headerlink" title="1.执行上下文/作用域/闭包"></a>1.执行上下文/作用域/闭包</h3><h4 id="1-什么是执行上下文"><a href="#1-什么是执行上下文" class="headerlink" title="1.什么是执行上下文?"></a>1.什么是执行上下文?</h4><p>执行上下文是评估和执行JavaScript代码环境的抽象概念。每当JavaScript代码在运行时，他都是在执行上下文中运行。</p>
<hr>
<p><strong>执行上下文的类型</strong></p>
<p>JavaScript共有<strong>三种</strong>执行上下文类型</p>
<ul>
<li><strong>全局执行上下文</strong><ul>
<li>这是基础的上下文,任何不在函数内部的代码都在全局上下文中.他会执行两件事:创建一个全局的window对象(浏览器环境的情况下),并且设置this的值等于这个全局对象。一个程序中只会有一个全局执行上下文</li>
</ul>
</li>
<li><strong>函数执行上下文</strong><ul>
<li>每当函数被调用时，都会为该函数创建一个新的执行上下文。每个函数都有他自己的执行上下文，只不过是在函数被调用时才被创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，他会按定义的瞬狙执行一系列步骤</li>
</ul>
</li>
<li><strong>Eval函数执行上下文</strong><ul>
<li>执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文</li>
</ul>
</li>
</ul>
<hr>
<p><strong>执行上下文栈</strong></p>
<p>执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。</p>
<p>当JavaScript引擎第一次遇到你的脚本时，他会创建一个全局的执行上下文并且压入当前执行栈。<strong>每当引擎遇到一个函数调用，他会为该函数创建一个新的执行上下文并压入栈的顶部.</strong></p>
<p>引擎会执行那些执行上下文位于栈顶的函数.<strong>每当函数执行结束之后，最上层的执行上下文从栈中弹出</strong>，控制流程到达当前栈中的下一个上下文</p>
<p><strong>一旦所有代码执行完毕，JavaScript引擎从当前栈中移除全局执行上下文</strong></p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132100915.png" alt="image-20220308144717269"></p>
<hr>
<p><strong>怎么创建执行上下文?</strong></p>
<p>创建执行上下文有两个阶段:</p>
<ol>
<li><strong>创建阶段</strong></li>
<li><strong>执行阶段</strong></li>
</ol>
<hr>
<p><strong>创建阶段</strong></p>
<p>在JavaScript代码执行前，执行上下文将经历创建阶段。在创建阶段将会发生三件事:</p>
<ol>
<li><strong>this</strong>值的绑定</li>
<li>创建<strong>词法环境</strong></li>
<li>创建<strong>变量环境</strong></li>
</ol>
<p>所以执行上下文在概念上表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext = &#123;</span><br><span class="line">  ThisBinding = &lt;this value&gt;,</span><br><span class="line">  LexicalEnvironment = &#123; ... &#125;,</span><br><span class="line">  VariableEnvironment = &#123; ... &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>This绑定:</strong></p>
<p>在全局执行上下文中,<code>this</code>的值指向全局对象(在浏览器中,全局对象为<code>window</code>’)</p>
<p>在函数执行上下文中,this的值取决于该函数是如何被调用的.如果他被一个引用类型对象调用,那么this会被设置成那个对象,否则<code>this</code>的值被设置成全局对象或者<code>undefined</code>(严格模式)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let foo = &#123;</span><br><span class="line">  baz: function() &#123;</span><br><span class="line">  console.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.baz();   <span class="comment">// &#x27;this&#x27; 引用 &#x27;foo&#x27;, 因为 &#x27;baz&#x27; 被</span></span><br><span class="line">             <span class="comment">// 对象 &#x27;foo&#x27; 调用</span></span><br><span class="line"></span><br><span class="line">let bar = foo.baz;</span><br><span class="line"></span><br><span class="line">bar();       <span class="comment">// &#x27;this&#x27; 指向全局 window 对象，因为</span></span><br><span class="line">             <span class="comment">// 没有指定引用对象</span></span><br></pre></td></tr></table></figure>



<p><strong>词法环境</strong></p>
<p><a href="https://link.juejin.cn/?target=http://ecma-international.org/ecma-262/6.0/">官方的 ES6</a> 文档把词法环境定义为</p>
<blockquote>
<p><strong>词法环境</strong>是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义<strong>标识符</strong>和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用<strong>外部</strong>词法环境的空值组成。</p>
</blockquote>
<p>词法环境是一种持有<strong>变量符-变量映射</strong>的结构(标识符指的是变量/函数的名字,而变量是对实际对象或原始数据的引用)</p>
<p>在词法环境的内部有两个组件:1.<strong>环境记录器</strong>和2.一个<strong>外部环境的引用</strong></p>
<p>1.<strong>环境记录器</strong>是存储变量和函数声明的实际位置</p>
<p>2.<strong>外部环境的引用</strong>意味着它可以访问其父级词法环境(作用域)</p>
<p><strong>词法环境</strong>有两种类型: <strong>全局环境</strong>和<strong>函数环境</strong></p>
<ul>
<li><p><strong>全局环境</strong>(在全局执行上下文中)是没有外部环境引用的词法环境,全局环境的外部环境引用是<strong>null</strong>，</p>
<p>它拥有创建的Object/Array等,在环境记录器内的原型函数(关联全局对象,比如window对象)还有任何用户定义的全局变量,并且<code>this</code>的值指向全局对象</p>
</li>
<li><p>在<strong>函数环境</strong>中，函数内部用户定义的变量存储在<strong>环境记录器</strong>中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。</p>
</li>
</ul>
<p>环境记录器也有两种类型:</p>
<ol>
<li><strong>声明式环境记录器</strong>，用来存储变量、函数和参数</li>
<li><strong>对象环境记录器</strong>,用来定义出现在<strong>全局上下文</strong>中的变量和函数关系</li>
</ol>
<p>由上不难得知</p>
<ul>
<li>在<strong>全局环境</strong>中,环境记录器是对象环境记录器</li>
<li>在<strong>函数环境</strong>中,环境记录器是声明式环境记录器</li>
</ul>
<p><strong>注意 :</strong> 对于<strong>函数环境</strong>，<strong>声明式环境记录器</strong>还包含了一个传递给函数的 <code>arguments</code> 对象（此对象存储索引和参数的映射）和传递给函数的参数的 <strong>length</strong>。</p>
<p>抽象地讲，词法环境在伪代码中看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;Global or outer function environment reference&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>变量环境</strong></p>
<p>变量环境其实也是一个<strong>词法环境</strong>,其环境记录器中持有变量声明语句在执行上下文中创建的绑定关系</p>
<p>变量环境有着词法环境的所有属性</p>
<p>在ES6中,词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量(<code>let</code>和<code>const</code>)绑定,而后者只用来存储<code>var</code>变量绑定</p>
<p>我们看点样例代码来理解上面的概念：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">e, f</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> g = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">return</span> e * f * g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = multiply(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行上下文看起来像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">ThisBinding</span>: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      a: &lt; uninitialized &gt;,</span><br><span class="line">      b: &lt; uninitialized &gt;,</span><br><span class="line">      multiply: &lt; func &gt;</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      c: undefined,</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  ThisBinding: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      Arguments: &#123;0: 20, 1: 30, length: 2&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      g: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可能你已经注意到 <code>let</code> 和 <code>const</code> 定义的变量并没有关联任何值，但 <code>var</code> 定义的变量被设成了 <code>undefined</code>。</p>
<p>这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 <code>undefined</code>（<code>var</code> 情况下），或者未初始化（<code>let</code> 和 <code>const</code> 情况下）。</p>
<p>这就是为什么你可以在声明之前访问 <code>var</code> 定义的变量（虽然是 <code>undefined</code>），但是在声明之前访问 <code>let</code> 和 <code>const</code> 的变量会得到一个引用错误。</p>
<p>这就是我们说的<strong>变量声明提升</strong>。</p>
<hr>
<p><strong>执行阶段</strong></p>
<p><strong>在此阶段完成对所有存储的变量的分配,最后执行代码.</strong></p>
<p><strong>注意:</strong> 在执行阶段,如果JavaScript引擎不能再源码中声明的实际位置找到<code>let</code>变量的值，那么他就会被赋值为<code>undefined</code></p>
<hr>
<hr>
<h4 id="2-作用域-Scope"><a href="#2-作用域-Scope" class="headerlink" title="2.作用域(Scope)"></a>2.作用域(Scope)</h4><p><strong>什么是作用域?</strong></p>
<p><strong>作用域是指程序源代码中定义变量的区域。</strong></p>
<p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>
<p>JavaScript 采用<strong>词法作用域</strong>(lexical scoping)，也就是静态作用域。</p>
<p>我们可以这样理解：<strong>作用域就是一个独立的地盘，让变量不会外泄、暴露出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong></p>
<p>ES6之前,JavaScript只有<strong>全局作用域</strong>和<strong>函数作用域</strong>,ES6之后，新增了<strong>块级作用域</strong>，可以通过<code>let</code>和<code>const</code>来创建</p>
<hr>
<p><strong>全局作用域和函数作用域</strong></p>
<p>**在代码中任何地方都能访问到的对象拥有全局作用域,**以下几种情况拥有全局作用域:</p>
<ul>
<li>最外层函数和在最外层函数外定义的变量拥有全局作用域</li>
<li>所有未定义直接赋值的变量默认为全局变量，拥有全局作用域</li>
<li>所有window对象的属性拥有全局作用域</li>
</ul>
<p>全局作用域的<strong>弊端</strong>:容易引发命名冲突，污染全局命名空间</p>
<hr>
<p><strong>函数作用域</strong></p>
<p><strong>在函数内部声明的变量</strong>拥有函数作用域,一般只能在固定的代码片段内可以访问到.</p>
<hr>
<p>作用域是分层的,内层作用域可以访问外层作用域的变量,反之则不行</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132100037.png" alt="image-20220308172822751"></p>
<p>值得注意的是：<strong>块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// &#x27;if&#x27; 条件语句块不会创建一个新的作用域</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;Hammad&#x27;</span>; <span class="comment">// name 依然在全局作用域中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// logs &#x27;Hammad&#x27;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>块级作用域</strong></p>
<p>块级作用域可以通过<code>let</code>和<code>const</code>声明,所声明的变量在指定块作用域·之外无法被访问。</p>
<p>块级作用域在如下情况被创建:</p>
<ol>
<li>在一个函数内部</li>
<li>在一个代码块内部(‘**{}**’)</li>
</ol>
<p>块级作用域有以下几个特点:</p>
<ul>
<li>声明变量不会提升的代码块顶部</li>
<li>禁止重复声明</li>
</ul>
<hr>
<p><strong>作用域链</strong></p>
<p>在JavaScript中,函数、块、模块都可以形成作用域,他们之间可以相互嵌套、作用域之间会形成引用关系，这条链叫做作用域链</p>
<p><strong>作用域链的创建和变化</strong></p>
<p><strong>函数创建时:</strong></p>
<p>JavaScript中使用的是词法作用域,<strong>函数的作用域在函数定义的时候就已经决定了</strong></p>
<p>函数有一个内部属性[[scope]]，当函数创建的时候,就会保存所有父变量对象到其中,可以理解为[[scope]]就是所有父变量对象的层级链,但是注意:[[scope]]并不代表完整的作用域链</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数创建时，各自的[[scope]]为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">    fooContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p><strong>函数被激活时:</strong></p>
<p>当函数被激活时,进入函数上下文,创建VO/AO后就会将活动对象添加到作用域的前端</p>
<p>这时候执行上下文的作用域链,我们命名为Scope</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure>

<p>至此,<strong>作用域链创建完毕</strong></p>
<hr>
<h4 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3.闭包"></a>3.闭包</h4><p><strong>什么是闭包?</strong></p>
<p>闭包就是同时含有对函数对象以及作用域对象引用的对象,实际上所有JavaScript对象都是闭包.</p>
<p><strong>本质</strong>:在一个函数内部创建另一个函数</p>
<p><strong>只要存在函数嵌套,并且内部函数调用了外部函数的属性,就产生了闭包.</strong></p>
<p>闭包的特性:</p>
<ul>
<li>函数嵌套函数</li>
<li>函数内部引用函数外部的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ul>
<hr>
<p><strong>闭包是什么时候被创建的？</strong></p>
<p>因为所有JavaScript对象都是闭包,所以当你定义一个函数时.就产生了闭包</p>
<hr>
<p><strong>闭包是什么时候被销毁的?</strong></p>
<p>当他不被任何其他的对象引用的时候，闭包就被销毁</p>
<hr>
<p><strong>闭包的好处</strong>:</p>
<ul>
<li>保护函数内的变量安全,实现封装,防止变量流入其他环境发生命名冲突</li>
<li>在内存中维持一个变量，延长变量的生命周期</li>
<li>匿名自执行函数可以减少内存消耗</li>
</ul>
<hr>
<p><strong>闭包的缺点:</strong></p>
<ul>
<li>被引用的私有变量不能被销毁，增大了内存的消耗，造成内存泄露</li>
<li>闭包涉及跨域访问，会导致性能损失</li>
</ul>
<hr>
<p><strong>闭包的作用</strong></p>
<ul>
<li>使得函数内部的变量在函数执行完之后，仍然存活在内存中(延长了局部变量的生命周期)</li>
<li>让函数外部可以操作到函数内部的数据</li>
</ul>
<hr>
<p><strong>闭包的原理</strong></p>
<p>当一个函数返回后，没有其他对象会保存对其的引用。所以，它就可能被<code>垃圾回收器</code>回收。</p>
<p>函数对象中总是有一个<code>[[scope]]</code>属性，保存着该函数被定义的时候所能够直接访问的作用域对象。所以，当我们在定义嵌套的函数的时候，这个嵌套的函数的<code>[[scope]]</code>就会引用外围函数（Outer function）的当前作用域对象。</p>
<p>如果我们将这个嵌套函数返回,并被另一个标识符所引用的话,那么这个嵌套函数及其[[scope]]所引用的作用作用域对象就不会被垃圾回收器所销毁,这个对象就会一直存活在内存中,我们可以通过这个作用于对象获取到外部函数的属性和值。</p>
<p>这就是闭包的原理</p>
<hr>
<h3 id="2-this-call-apply-bind"><a href="#2-this-call-apply-bind" class="headerlink" title="2.this/call/apply/bind"></a>2.this/call/apply/bind</h3><h4 id="1-this的指向"><a href="#1-this的指向" class="headerlink" title="1.this的指向"></a>1.this的指向</h4><blockquote>
<p>函数的this是在函数调用时才绑定的,它的指向完全取决于函数的调用位置(也就是函数的调用方法),为了搞清楚<code>this</code>的指向是什么，必须知道相关函数是如何调用的</p>
</blockquote>
<p><strong>在全局上下文中:</strong></p>
<p>非严格模式和严格模式中this都指向顶层对象(在浏览器中是<code>window</code>)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span> === <span class="built_in">window</span> <span class="comment">// true&#x27;use strict&#x27;this === window;this.name = &#x27;若川&#x27;;console.log(this.name); // 若川</span></span><br></pre></td></tr></table></figure>

<p><strong>普通函数调用模式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 非严格模式var name = &#x27;window&#x27;;var doSth = function()&#123;    console.log(this.name);&#125;doSth(); // &#x27;window&#x27;复制代码</span><br></pre></td></tr></table></figure>

<p>你可能会误以为<code>window.doSth()</code>是调用的，所以是指向<code>window</code>。虽然本例中<code>window.doSth</code>确实等于<code>doSth</code>。<code>name</code>等于<code>window.name</code>。上面代码中这是因为在<code>ES5</code>中，全局变量是挂载在顶层对象（浏览器是<code>window</code>）中。 事实上，并不是如此。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 非严格模式let name2 = &#x27;window2&#x27;;let doSth2 = function()&#123;    console.log(this === window);    console.log(this.name2);&#125;doSth2() // true, undefined复制代码</span><br></pre></td></tr></table></figure>

<p>这个例子中<code>let</code>没有给顶层对象中（浏览器是window）添加属性，<code>window.name2和window.doSth</code>都是<code>undefined</code>。</p>
<p>严格模式中，普通函数中的<code>this</code>则表现不同，表现为<code>undefined</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 严格模式</span><br><span class="line">&#x27;use strict&#x27;</span><br><span class="line">var name = &#x27;window&#x27;;</span><br><span class="line">var doSth = function()&#123;</span><br><span class="line">    console.log(typeof this === &#x27;undefined&#x27;);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">doSth(); // true，// 报错，因为this是undefined</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>看过的《你不知道的<code>JavaScript</code>》上卷的读者，应该知道书上将这种叫做默认绑定。 对<code>call</code>，<code>apply</code>熟悉的读者会类比为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSth.call(undefined);</span><br><span class="line">doSth.apply(undefined);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>效果是一样的，<code>call</code>，<code>apply</code>作用之一就是用来修改函数中的<code>this</code>指向为第一个参数的。 第一个参数是<code>undefined</code>或者<code>null</code>，非严格模式下，是指向<code>window</code>。严格模式下，就是指向第一个参数。后文详细解释。<br> 经常有这类代码（回调函数），其实也是普通函数调用模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;若川&#x27;;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;, 0);</span><br><span class="line">// 语法</span><br><span class="line">setTimeout(fn | code, 0, arg1, arg2, ...)</span><br><span class="line">// 也可以是一串代码。也可以传递其他函数</span><br><span class="line">// 类比 setTimeout函数内部调用fn或者执行代码`code`。</span><br><span class="line">fn.call(undefined, arg1, arg2, ...);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>对象中的函数（方法）调用模式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;window&#x27;;</span><br><span class="line">var doSth = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var student = &#123;</span><br><span class="line">    name: &#x27;若川&#x27;,</span><br><span class="line">    doSth: doSth,</span><br><span class="line">    other: &#123;</span><br><span class="line">        name: &#x27;other&#x27;,</span><br><span class="line">        doSth: doSth,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">student.doSth(); // &#x27;若川&#x27;</span><br><span class="line">student.other.doSth(); // &#x27;other&#x27;</span><br><span class="line">// 用call类比则为：</span><br><span class="line">student.doSth.call(student);</span><br><span class="line">// 用call类比则为：</span><br><span class="line">student.other.doSth.call(student.other);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>但往往会有以下场景，把对象中的函数赋值成一个变量了。 这样其实又变成普通函数了，所以使用普通函数的规则（默认绑定）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var studentDoSth = student.doSth;studentDoSth(); // &#x27;window&#x27;// 用call类比则为：studentDoSth.call(undefined);复制代码</span><br></pre></td></tr></table></figure>

<p><strong><code>call、apply、bind</code> 调用模式</strong></p>
<p>上文提到<code>call</code>、<code>apply</code>，这里详细解读一下。先通过<code>MDN</code>认识下<code>call</code>和<code>apply</code> <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">MDN 文档：Function.prototype.call()</a><br> <strong>语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)复制代码</span><br></pre></td></tr></table></figure>

<p><strong>thisArg</strong><br> 在<code>fun</code>函数运行时指定的<code>this</code>值。需要注意的是，指定的<code>this</code>值并不一定是该函数执行时真正的<code>this</code>值，如果这个函数处于<strong>非严格模式</strong>下，则指定为<code>null</code>和<code>undefined</code>的<code>this</code>值会自动指向全局对象(浏览器中就是<code>window</code>对象)，同时值为原始值(数字，字符串，布尔值)的<code>this</code>会指向该原始值的自动包装对象。<br> <strong>arg1, arg2, …</strong><br> 指定的参数列表<br> <strong>返回值</strong><br> 返回值是你调用的方法的返回值，若该方法没有返回值，则返回<code>undefined</code>。<br> <code>apply</code>和<code>call</code>类似。只是参数不一样。它的参数是数组（或者类数组）。</p>
<p>根据参数<code>thisArg</code>的描述，可以知道，<code>call</code>就是改变函数中的<code>this</code>指向为<code>thisArg</code>，并且执行这个函数，这也就使<code>JS</code>灵活很多。严格模式下，<code>thisArg</code>是原始值是值类型，也就是原始值。不会被包装成对象。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var doSth = function(name)&#123;    console.log(this);    console.log(name);&#125;doSth.call(2, &#x27;若川&#x27;); // Number&#123;2&#125;, &#x27;若川&#x27;var doSth2 = function(name)&#123;    &#x27;use strict&#x27;;    console.log(this);    console.log(name);&#125;doSth2.call(2, &#x27;若川&#x27;); // 2, &#x27;若川&#x27;复制代码</span><br></pre></td></tr></table></figure>

<p>虽然一般不会把<code>thisArg</code>参数写成值类型。但还是需要知道这个知识。 之前写过一篇文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903728147857415">面试官问：能否模拟实现<code>JS</code>的<code>call</code>和<code>apply</code>方法</a> 就是利用对象上的函数<code>this</code>指向这个对象，来模拟实现<code>call</code>和<code>apply</code>的。感兴趣的读者思考如何实现，再去看看笔者的实现。</p>
<p><code>bind</code>和<code>call</code>和<code>apply</code>类似，第一个参数也是修改<code>this</code>指向，只不过返回值是新函数，新函数也能当做构造函数（<code>new</code>）调用。 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">MDN Function.prototype.bind</a></p>
<blockquote>
<p><code>bind()</code>方法创建一个新的函数， 当这个新函数被调用时<code>this</code>键值为其提供的值，其参数列表前几项值为创建时指定的参数序列。</p>
</blockquote>
<p><strong>语法：</strong> fun.bind(thisArg[, arg1[, arg2[, …]]])<br> <strong>参数：</strong> <strong>thisArg</strong> 调用绑定函数时作为this参数传递给目标函数的值。 如果使用<code>new</code>运算符构造绑定函数，则忽略该值。当使用<code>bind</code>在<code>setTimeout</code>中创建一个函数（作为回调提供）时，作为<code>thisArg</code>传递的任何原始值都将转换为<code>object</code>。如果没有提供绑定的参数，则执行作用域的<code>this</code>被视为新函数的<code>thisArg</code>。 <strong>arg1, arg2, …</strong> 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 <strong>返回值</strong> 返回由指定的<code>this</code>值和初始化参数改造的原函数拷贝。</p>
<p><strong>构造函数调用模式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Student(name)&#123;    this.name = name;    console.log(this); // &#123;name: &#x27;若川&#x27;&#125;    // 相当于返回了    // return this;&#125;var result = new Student(&#x27;若川&#x27;);复制代码</span><br></pre></td></tr></table></figure>

<p>使用<code>new</code>操作符调用函数，会自动执行以下步骤。</p>
<blockquote>
<ol>
<li>创建了一个全新的对象。</li>
<li>这个对象会被执行<code>[[Prototype]]</code>（也就是<code>__proto__</code>）链接。</li>
<li>生成的新对象会绑定到函数调用的<code>this</code>。</li>
<li>通过<code>new</code>创建的每个对象将最终被<code>[[Prototype]]</code>链接到这个函数的<code>prototype</code>对象上。</li>
<li>如果函数没有返回对象类型<code>Object</code>(包含<code>Functoin</code>, <code>Array</code>, <code>Date</code>, <code>RegExg</code>, <code>Error</code>)，那么<code>new</code>表达式中的函数调用会自动返回这个新的对象。</li>
</ol>
</blockquote>
<p>由此可以知道：<code>new</code>操作符调用时，<code>this</code>指向生成的新对象。 <strong>特别提醒一下，<code>new</code>调用时的返回值，如果没有显式返回对象或者函数，才是返回生成的新对象</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Student(name)&#123;    this.name = name;    // return function f()&#123;&#125;;    // return &#123;&#125;;&#125;var result = new Student(&#x27;若川&#x27;);console.log(result); &#123;name: &#x27;若川&#x27;&#125;// 如果返回函数f，则result是函数f，如果是对象&#123;&#125;，则result是对象&#123;&#125;复制代码</span><br></pre></td></tr></table></figure>

<p>很多人或者文章都忽略了这一点，直接简单用<code>typeof</code>判断对象。虽然实际使用时不会显示返回，但面试官会问到。</p>
<hr>
<p><strong>总结</strong></p>
<p>如果要判断一个运行中的函数的this绑定，就需要找到这个函数的直接调用位置.找到之后就可以顺序应用下面这四条规则来判断this的指向</p>
<ol>
<li><strong>普通函数调用</strong>:在严格模式下绑定到<code>undefined</code>,否则绑定到全局对象</li>
<li><strong>构造函数形式调用</strong>:绑定到新创建的实例对象</li>
<li><strong>对象上的函数调用</strong>:帮到到那个对象</li>
<li><strong>call、apply、bind调用</strong>:在非严格模式下,this为函数传入的第一个参数,如果第一个参数为<code>null</code>或者<code>undefined</code>，<code>this</code>会指向全局对象(浏览器中就是window对象)</li>
</ol>
<p><strong>箭头函数的this</strong>:不会使用上文的四条标准的绑定规则,而是<strong>根据当前的词法作用域来决定this。</strong></p>
<p>箭头函数没有自己的this、super、argument和new.target绑定,所以<strong>必须通过查找作用域链来决定其值</strong>.<strong>如果箭头函数被非箭头函数包含,则this绑定的是最近一层非箭头函数的this,否则this的值会被设置位全局对象.</strong></p>
<hr>
<h4 id="2-call"><a href="#2-call" class="headerlink" title="2.call"></a>2.call</h4><blockquote>
<p>call()方法的作用是在使用<strong>一个指定的this值</strong>和<strong>若干个指定的参数值</strong>的前提下调用某个函数或方法</p>
</blockquote>
<p>举个栗子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;    <span class="attr">value</span>: <span class="number">1</span>&#125;;<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);&#125;bar.call(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>手写实现call方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.ts_call(obj,...args)&#123;    obj = obj || <span class="built_in">window</span>;        <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(); <span class="comment">//创建一个唯一变量,防止属性名冲突        obj[fn] = this; //将属性指定为目标函数        obj[fn](...args);//执行函数        delete obj[fn];//执行后将这个属性删除&#125;function fn(age)&#123;    console.log(`我叫$&#123;this.name&#125;今年$&#123;age&#125;岁了!`);&#125;const testobj2 = &#123;    name: &#x27;zzm&#x27;&#125;fn.cs_call(testobj2,18)//我叫zzm今年18岁了!</span></span><br></pre></td></tr></table></figure>



<h4 id="3-apply"><a href="#3-apply" class="headerlink" title="3.apply"></a>3.apply</h4><blockquote>
<p>apply的方法与call类似,不同之处在于<strong>apply参数以数组的方式传递</strong>,所以call能实现的需求，用apply也同样可以</p>
</blockquote>
<p>手写实现apply方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.cs_apply(obj,arg)&#123;    obj = obj || <span class="built_in">window</span>;        <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();        obj[fn] = <span class="built_in">this</span>;        obj[fn](...args);        <span class="keyword">delete</span> obj[fn];&#125;<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">age,hobby</span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="string">`我叫<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>今年<span class="subst">$&#123;age&#125;</span>岁了我喜欢<span class="subst">$&#123;hobby&#125;</span>`</span>);&#125;<span class="keyword">const</span> testobj2 = &#123;    <span class="attr">name</span>: <span class="string">&#x27;zzm&#x27;</span>&#125;fn.cs_apply(testobj2,[<span class="number">18</span>,<span class="string">&#x27;睡觉&#x27;</span>])<span class="comment">//我叫zzm今年18岁了我喜欢睡觉</span></span><br></pre></td></tr></table></figure>



<h4 id="4-bind"><a href="#4-bind" class="headerlink" title="4.bind"></a>4.bind</h4><blockquote>
<p>bind()函数会创建一个新函数(称之为绑定函数)</p>
</blockquote>
<ul>
<li>bind是ES5新增的一个方法</li>
<li>传参和call或apply类似</li>
<li>不会执行对应的函数，call或apply会自动执行对应的函数</li>
<li>返回对函数的引用</li>
</ul>
<p><strong>下面例子：</strong>当点击网页时，<code>EventClick</code>被触发执行，输出<code>JSLite.io p1 p2</code>, 说明<code>EventClick</code>中的<code>this</code>被<code>bind</code>改变成了<code>obj</code>对象。如果你将<code>EventClick.bind(obj,&#39;p1&#39;,&#39;p2&#39;)</code> 变成 <code>EventClick.call(obj,&#39;p1&#39;,&#39;p2&#39;)</code> 的话，页面会直接输出 <code>JSLite.io p1 p2</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;name:&#x27;JSLite.io&#x27;&#125;;</span><br><span class="line">/**</span><br><span class="line"> * 给document添加click事件监听，并绑定EventClick函数</span><br><span class="line"> * 通过bind方法设置EventClick的this为obj，并传递参数p1,p2</span><br><span class="line"> */</span><br><span class="line">document.addEventListener(&#x27;click&#x27;,EventClick.bind(obj,&#x27;p1&#x27;,&#x27;p2&#x27;),false);</span><br><span class="line">//当点击网页时触发并执行</span><br><span class="line">function EventClick(a,b)&#123;</span><br><span class="line">    console.log(</span><br><span class="line">            this.name, //JSLite.io</span><br><span class="line">            a, //p1</span><br><span class="line">            b  //p2</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">// JSLite.io p1 p2</span><br></pre></td></tr></table></figure>



<p>手写bind</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.cs_bind = <span class="function"><span class="keyword">function</span>(<span class="params">obj,...args</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    obj = obj || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    obj[fn] = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="function"><span class="keyword">function</span>(<span class="params">...innerArgs</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> <span class="keyword">instanceof</span> _this)&#123;<span class="comment">//当作构造函数使用</span></span><br><span class="line">            <span class="built_in">this</span>[fn] = _this;</span><br><span class="line">            <span class="built_in">this</span>[fn](...[...args,...innerArgs]);</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>[fn];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//没有当作构造函数使用</span></span><br><span class="line">            obj[fn](...[...args,...innerArgs])</span><br><span class="line">            <span class="keyword">delete</span> obj[fn];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.prototype = <span class="built_in">Object</span>.create(<span class="built_in">this</span>.prototype);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-原型-继承"><a href="#3-原型-继承" class="headerlink" title="3.原型/继承"></a>3.原型/继承</h3><h4 id="1-原型"><a href="#1-原型" class="headerlink" title="1.原型"></a>1.原型</h4><p><strong>原型链经典神图</strong></p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131611904.png" alt="image-20220313161148825"></p>
<ul>
<li>function Foo 就是一个方法，比如JavaScript 中内置的 Array、String 等</li>
<li>function Object 就是一个 Object</li>
<li>function Function 就是 Function</li>
<li>以上都是 function，所以 <code>.__proto__</code>都是<code>Function.prototype</code></li>
<li>再次强调，String、Array、Number、Function、Object都是 function</li>
</ul>
<hr>
<p><strong>prototype的定义</strong></p>
<p>在规范里,prototype被定义为:<strong>给其他对象提供共享属性的对象</strong></p>
<p>也就是说prototype自己也是对象,只是被用来承担某个只能罢了</p>
<p><strong>prototype描述的是两个对象之间的某种关系(其中一个对象为另一个对象提供属性访问权限).所有对象都可以作为另一个对象的prototype来使用</strong></p>
<hr>
<p><strong>函数对象和普通对象</strong></p>
<p>在JavaScript中,<strong>万物皆对象</strong>,但是不同的对象是存在着差异性的.</p>
<p>在JavaScript中，我们将对象分为函数对象和普通对象,<strong>函数对象就是JavaScript用函数来模拟的类实现</strong>,<strong>Object</strong>和<strong>Function</strong>就是典型的函数对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;&#125;;<span class="keyword">const</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;<span class="keyword">const</span> fun3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;console.log(name)&#x27;</span>);<span class="keyword">const</span> obj1 = &#123;&#125;;<span class="keyword">const</span> obj2 = <span class="keyword">new</span> <span class="built_in">Object</span>();<span class="keyword">const</span> obj3 = <span class="keyword">new</span> fun1();<span class="keyword">const</span> obj4 = <span class="keyword">new</span> <span class="keyword">new</span> <span class="built_in">Function</span>();<span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>);<span class="comment">//functionconsole.log(typeof Function);//functionconsole.log(typeof fun1);//functionconsole.log(typeof fun2);//functionconsole.log(typeof fun3);//functionconsole.log(typeof obj1);//objectconsole.log(typeof obj2);//objectconsole.log(typeof obj3);//objectconsole.log(typeof obj4);//object</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>obj1</code>，<code>obj2</code>，<code>obj3</code>，<code>obj4</code>都是普通对象，<code>fun1</code>，<code>fun2</code>，<code>fun3</code> 都是 <code>Function</code> 的实例，也就是函数对象。</p>
<p>总结:<strong>所有的Function的实例都是函数对象,其他的均为普通对象,包括Function实例的实例</strong></p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131629020.webp" alt="img"></p>
<p><strong>JavaScript中万物皆对象,而对象皆出自构造函数</strong></p>
<p>对于<strong>Function</strong>对象:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<hr>
<p><strong>__ proto__</strong></p>
<p>首先我们需要明确:</p>
<ul>
<li><strong>__ proto__<strong>和</strong>constructor</strong>是<strong>对象</strong>独有的</li>
<li><strong>prototype</strong>属性是<strong>函数</strong>独有的</li>
</ul>
<p>但是在JavaScript中,函数也是一种特殊的对象,<strong>所以函数也拥有<code>__proto__</code>和 <code>constructor</code>属性</strong></p>
<p>结合上面我们介绍的 <code>Object</code> 和 <code>Function</code> 的关系，看一下代码和关系图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;…&#125;; let nealyang = new Person(); </span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131647800.webp" alt="__proto__"></p>
<p>再梳理上图关系之前，我们再来讲解下<code>__proto__</code>。</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131647353.webp" alt="img"></p>
<p>这里我们需要知道的是，<code>__proto__</code>是对象所独有的，并且<code>__proto__</code>是<strong>一个对象指向另一个对象</strong>，也就是他的原型对象。我们也可以理解为父类对象。它的作用就是当你在访问一个对象属性的时候，如果该对象内部不存在这个属性，那么就回去它的<code>__proto__</code>属性所指向的对象（父类对象）上查找，如果父类对象依旧不存在这个属性，那么就回去其父类的<code>__proto__</code>属性所指向的父类的父类上去查找。以此类推，知道找到 <code>null</code>。而这个查找的过程，也就构成了我们常说的<strong>原型链</strong>。</p>
<p><strong>原型链就是根据对象的__ proto __指向,一层一层连接起来的具有关联性的对象集合</strong></p>
<hr>
<p><strong>prototype</strong></p>
<p>prototype 被定义为：<strong>给其它对象提供共享属性的对象</strong>。<code>prototype</code> 自己也是对象，只是被用以承担某个职能罢了</p>
<p>所有对象都可以作为另一个对象的<strong>prototype</strong>使用</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131651653.webp" alt="img"></p>
<p><strong>任何函数在创建的时候，都会默认给该函数添加 <code>prototype</code> 属性.</strong></p>
<hr>
<p><strong>constructor</strong></p>
<p><strong>constructor</strong>属性也是对象所独有的,<strong>他是一个对象指向同一个函数，这个函数就是该对象的构造函数</strong></p>
<p>每个对象都有其对应的构造函数,它由本身或者继承而来.</p>
<p><strong>函数.prototype.constructor</strong>===<strong>该函数本身</strong></p>
<p><strong>constructor属性只有prototype对象才有</strong>,函数在创建的时候,JavaScript会同时创建一个该函数对应的prototype对象,<strong>而函数创建的对象.proto === 该函数.prototype</strong></p>
<p>通过函数创建的对象即使自己没有<code>constructor</code>属性，它也能通过<code>__proto__</code>找到对应的<code>constructor</code>，所以<strong>任何对象最终都可以找到其对应的构造函数。</strong></p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131707239.webp" alt="img"></p>
<hr>
<p><strong>原型链</strong></p>
<p><strong>原型链就是根据对象的__ proto __指向,一层一层连接起来的具有关联性的对象集合</strong></p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131709481.webp" alt="img"></p>
<hr>
<p><strong>typeof</strong>&amp;&amp;<strong>instanceof</strong>原理</p>
<p><strong>typeof</strong></p>
<p>用于判断变量的类型,可以判断的类型有:<strong>number</strong>、<strong>undefined</strong>、<strong>String</strong>、<strong>Boolean</strong>、<strong>function</strong>、<strong>object</strong>、<strong>symbol</strong>，但是<strong>typeof在判断object时不能明确的告诉你属于哪一类object</strong></p>
<p>所以<strong>一般不用typeof来判断object的类型</strong></p>
<p>为什么<strong>typeof null</strong> 返回’<strong>object</strong>’？</p>
<p><strong>因为null代表的是空指针对象,所以typeof null 为object</strong></p>
<p>具体原因:在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 <code>null</code> 代表的是空指针（大多数平台下值为 0x00），因此，<code>null</code> 的类型标签是 0，<code>typeof null</code> 也因此返回 <code>&quot;object&quot;</code></p>
<hr>
<p><strong>instanceof</strong></p>
<p><code>instanceof</code> 运算符用来检测 <code>constructor.prototype</code> 是否存在于参数 <code>object</code> 的原型链上。与 <code>typeof</code> 方法不同的是，<code>instanceof</code> 方法要求开发者明确地确认对象为某特定类型。</p>
<p><strong>instanceof</strong>可以判断<strong>一个实例是否是其父类型或者祖先类型的实例。</strong></p>
<p><strong>instanceof</strong>是如何进行判断的?</p>
<ul>
<li>表达式**:A instanceof B**:如果B的显式原型(prototype)对象在A的原型链上,返回true,否则返回false</li>
</ul>
<p><strong>手写instanceof</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_instanceof</span>(<span class="params">child,father</span>)</span>&#123;    <span class="keyword">const</span> fp =  father.prototype       <span class="keyword">let</span> cp = child.__proto__    <span class="keyword">while</span>(cp)&#123;        <span class="keyword">if</span>(cp.__proto__ === father.protype)&#123;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;        cp = cp.__proto__;    &#125;    <span class="keyword">return</span> <span class="literal">false</span>;    &#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true console.log(Function instanceof Function);//true console.log(Number instanceof Number);//false console.log(String instanceof String);//false console.log(Function instanceof Object);//true console.log(Foo instanceof Function);//true console.log(Foo instanceof Foo);//false</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么 <code>Object</code> 和 <code>Function</code> <code>instanceof</code> 自己等于 <code>true</code>，而其他类 <code>instanceof</code> 自己却又不等于 <code>true</code> 呢？如何解释？</strong></p>
<ul>
<li><p><code>Object instanceof Object</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了方便表述，首先区分左侧表达式和右侧表达式ObjectL = Object, ObjectR = Object; // 下面根据规范逐步推演O = ObjectR.prototype = Object.prototype L = ObjectL.__proto__ = Function.prototype // 第一次判断O != L // 循环查找 L 是否还有 __proto__ L = Function.prototype.__proto__ = Object.prototype // 第二次判断O == L // 返回 true</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Function instanceof Function</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了方便表述，首先区分左侧表达式和右侧表达式FunctionL = Function, FunctionR = Function; // 下面根据规范逐步推演O = FunctionR.prototype = Function.prototype L = FunctionL.__proto__ = Function.prototype // 第一次判断O == L // 返回 true</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Foo instanceof Foo</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了方便表述，首先区分左侧表达式和右侧表达式</span></span><br><span class="line">FooL = Foo, FooR = Foo; </span><br><span class="line"><span class="comment">// 下面根据规范逐步推演</span></span><br><span class="line">O = FooR.prototype = Foo.prototype </span><br><span class="line">L = FooL.__proto__ = <span class="built_in">Function</span>.prototype </span><br><span class="line"><span class="comment">// 第一次判断</span></span><br><span class="line">O != L </span><br><span class="line"><span class="comment">// 循环再次查找 L 是否还有 __proto__ </span></span><br><span class="line">L = <span class="built_in">Function</span>.prototype.__proto__ = <span class="built_in">Object</span>.prototype </span><br><span class="line"><span class="comment">// 第二次判断</span></span><br><span class="line">O != L </span><br><span class="line"><span class="comment">// 再次循环查找 L 是否还有 __proto__ </span></span><br><span class="line">L = <span class="built_in">Object</span>.prototype.__proto__ = <span class="literal">null</span> </span><br><span class="line"><span class="comment">// 第三次判断</span></span><br><span class="line">L == <span class="literal">null</span> </span><br><span class="line"><span class="comment">// 返回 false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<hr>
<h4 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h4><p>在JavaScript中,有两类原型继承的方式:<strong>显式继承</strong>和<strong>隐式继承</strong></p>
<hr>
<h5 id="new"><a href="#new" class="headerlink" title="new"></a><strong>new</strong></h5><p><strong>new用来创建构造函数的实例对象</strong></p>
<p><strong>手写new</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn,...args</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    obj.__proto__ = fn.prototype;<span class="comment">//将obj的__proto__赋值为fn的prototype</span></span><br><span class="line">    fn.apply(obj,args);<span class="comment">//将构造函数的this指向这个对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h5 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a><strong>类式继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.superValue = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.superValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line"></span><br><span class="line">SubClass.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> SubClass();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( instance  <span class="keyword">instanceof</span> SuperClass);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log( instance  <span class="keyword">instanceof</span> SubClass);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(SubClass <span class="keyword">instanceof</span> SuperClass);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>虽然实现起来清晰简洁，但是这种继承方式有两个缺点：</p>
<ul>
<li>由于子类通过其原型prototype对父类实例化，继承了父类，所以说父类中如果共有属性是引用类型，就会在子类中被所有的实例所共享，因此一个子类的实例更改子类原型从父类构造函数中继承的共有属性就会直接影响到其他的子类</li>
<li>由于子类实现的继承是靠其原型prototype对父类进行实例化实现的，因此在创建父类的时候，是无法向父类传递参数的。因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化</li>
</ul>
<hr>
<h5 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a><strong>构造函数继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">id</span>) </span>&#123;    <span class="built_in">this</span>.books = [<span class="string">&#x27;js&#x27;</span>,<span class="string">&#x27;css&#x27;</span>];    <span class="built_in">this</span>.id = id;&#125;SuperClass.prototype.showBooks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="built_in">this</span>.books);&#125;<span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">id</span>)</span>&#123;    SuperClass.call(<span class="built_in">this</span>,id)&#125;<span class="keyword">const</span> instance1 = <span class="keyword">new</span> SubClass(<span class="number">10</span>);<span class="keyword">const</span> instance2 = <span class="keyword">new</span> SubClass(<span class="number">10</span>);instance1.books.push(<span class="string">&#x27;html&#x27;</span>);<span class="built_in">console</span>.log(instance1)<span class="built_in">console</span>.log(instance2)instance1.showBooks();<span class="comment">//TypeError</span></span><br></pre></td></tr></table></figure>

<p><code>SuperClass.call(this,id)</code>当然就是构造函数继承的核心语句了.由于父类中给this绑定属性，因此子类自然也就继承父类的共有属性。由于这种类型的继承没有涉及到原型<code>prototype</code>，所以父类的原型方法自然不会被子类继承，而如果想被子类继承，就必须放到构造函数中，这样创建出来的每一个实例都会单独的拥有一份而不能共用，这样就违背了代码复用的原则，所以综合上述两种，我们提出了组合式继承方法</p>
<hr>
<h5 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a><strong>组合式继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;  <span class="built_in">this</span>.name = name;   <span class="built_in">this</span>.books = [<span class="string">&#x27;Js&#x27;</span>,<span class="string">&#x27;CSS&#x27;</span>];&#125;SuperClass.prototype.getBooks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="built_in">this</span>.books);&#125;<span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name,time</span>) </span>&#123;  SuperClass.call(<span class="built_in">this</span>,name);  <span class="built_in">this</span>.time = time;&#125;SubClass.prototype = <span class="keyword">new</span> SuperClass();SubClass.prototype.getTime = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="built_in">this</span>.time);&#125;</span><br></pre></td></tr></table></figure>

<p>如上，我们就解决了之前说到的一些问题，但是是不是从代码看，还是有些不爽呢？至少这个<code>SuperClass</code>的构造函数执行了两遍就感觉非常的不妥.</p>
<h5 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a><strong>原型式继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritObject</span>(<span class="params">o</span>) </span>&#123;    <span class="comment">//声明一个过渡对象  function F() &#123; &#125;  //过渡对象的原型继承父对象  F.prototype = o;  //返回过渡对象的实例，该对象的原型继承了父对象  return new F();&#125;</span></span><br></pre></td></tr></table></figure>

<p>原型式继承大致的实现方式如上，是不是想到了我们<code>new</code>关键字模拟的实现？</p>
<p>其实这种方式和类式继承非常的相似，他只是对类式继承的一个封装，其中的过渡对象就相当于类式继承的子类，只不过在原型继承中作为一个普通的过渡对象存在，目的是为了创建要返回的新的实例对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;    name:&#x27;js book&#x27;,    likeBook:[&#x27;css Book&#x27;,&#x27;html book&#x27;]&#125;var newBook = inheritObject(book);newBook.name = &#x27;ajax book&#x27;;newBook.likeBook.push(&#x27;react book&#x27;);var otherBook = inheritObject(book);otherBook.name = &#x27;canvas book&#x27;;otherBook.likeBook.push(&#x27;node book&#x27;);console.log(newBook,otherBook);复制代码</span><br></pre></td></tr></table></figure>

<p>如上代码我们可以看出，原型式继承和类式继承一个样子，对于引用类型的变量，还是存在子类实例共享的情况。</p>
<p>所以，我们还有下面的寄生式继承</p>
<hr>
<h5 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a><strong>寄生式继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;js book&#x27;</span>,</span><br><span class="line">    <span class="attr">likeBook</span>:[<span class="string">&#x27;html book&#x27;</span>,<span class="string">&#x27;css book&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBook</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//通过原型方式创建新的对象</span></span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> inheritObject(obj);</span><br><span class="line">  <span class="comment">// 拓展新对象</span></span><br><span class="line">  o.getName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回拓展后的新对象</span></span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实寄生式继承就是对原型继承的拓展，一个二次封装的过程，这样新创建的对象不仅仅有父类的属性和方法，还新增了别的属性和方法。</p>
<h5 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a><strong>寄生组合式继承</strong></h5><p>回到之前的组合式继承，那时候我们将类式继承和构造函数继承组合使用，但是存在的问题就是子类不是父类的实例，而子类的原型是父类的实例，所以才有了寄生组合式继承</p>
<p>而寄生组合式继承是寄生式继承和构造函数继承的组合。但是这里寄生式继承有些特殊，这里他处理不是对象，而是类的原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//声明一个过渡对象</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">  <span class="comment">//过渡对象的原型继承父对象</span></span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="comment">//返回过渡对象的实例，该对象的原型继承了父对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subClass,superClass</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 复制一份父类的原型副本到变量中</span></span><br><span class="line">  <span class="keyword">var</span> p = inheritObject(superClass.prototype);</span><br><span class="line">  <span class="comment">// 修正因为重写子类的原型导致子类的constructor属性被修改</span></span><br><span class="line">  p.constructor = subClass;</span><br><span class="line">  <span class="comment">// 设置子类原型</span></span><br><span class="line">  subClass.prototype = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>组合式继承中，通过构造函数继承的属性和方法都是没有问题的，所以这里我们主要探究通过寄生式继承重新继承父类的原型。</p>
<p>我们需要继承的仅仅是父类的原型，不用去调用父类的构造函数。换句话说，在构造函数继承中，我们已经调用了父类的构造函数。因此我们需要的就是父类的原型对象的一个副本，而这个副本我们可以通过原型继承拿到，但是这么直接赋值给子类会有问题，因为对父类原型对象复制得到的复制对象p中的<code>constructor</code>属性指向的不是<code>subClass</code>子类对象，因此在寄生式继承中要对复制对象p做一次增强，修复起<code>constructor</code>属性指向性不正确的问题，最后将得到的复制对象p赋值给子类原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.books=[<span class="string">&#x27;js book&#x27;</span>,<span class="string">&#x27;css book&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name,time</span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="built_in">this</span>,name);</span><br><span class="line">  <span class="built_in">this</span>.time = time;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubClass,SuperClass);</span><br><span class="line">SubClass.prototype.getTime = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubClass(<span class="string">&#x27;React&#x27;</span>,<span class="string">&#x27;2017/11/11&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubClass(<span class="string">&#x27;Js&#x27;</span>,<span class="string">&#x27;2018/22/33&#x27;</span>);</span><br><span class="line"></span><br><span class="line">instance1.books.push(<span class="string">&#x27;test book&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance1.books,instance2.books);</span><br><span class="line">instance2.getName();</span><br><span class="line">instance2.getTime();</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131828871.webp" alt="img"></p>
<p>这种方式继承其实如上图所示，其中最大的改变就是子类原型中的处理，被赋予父类原型中的一个引用，这是一个对象，因此有一点你需要注意，就是子类在想添加原型方法必须通过prototype.来添加，否则直接赋予对象就会覆盖从父类原型继承的对象了.</p>
<h3 id="4-promise"><a href="#4-promise" class="headerlink" title="4.promise"></a>4.promise</h3><h4 id="1-什么是promise-它用来解决什么问题"><a href="#1-什么是promise-它用来解决什么问题" class="headerlink" title="1.什么是promise?它用来解决什么问题?"></a>1.<strong>什么是promise?它用来解决什么问题?</strong></h4><blockquote>
<p>Promise是异步编程的一种解决方案:从语法上讲，promise是一个对象,可以通过它获取异步操作的消息；从本意上讲，他是承诺，承诺他过一段时间会给你一个结果。promise有三种状态:<strong>pending</strong>(等待态)，<strong>fulfiled</strong>(成功态),<strong>rejected</strong>(失败态);<strong>状态一旦改变，就不会再改变</strong>(也就是说promise的操作是不可逆的)，<strong>创造promise实例后，他会立即执行</strong></p>
</blockquote>
<p>promise是用来解决两个问题:</p>
<ul>
<li><strong>回调地狱</strong>，减少多层回调嵌套</li>
<li><strong>异步执行</strong>(但是不能说promise是异步的)</li>
</ul>
<hr>
<h4 id="2-promise用法"><a href="#2-promise用法" class="headerlink" title="2.promise用法"></a>2.<strong>promise用法</strong></h4><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132032800.png" alt="image-20220313203224725"></p>
<h5 id="创建promise对象"><a href="#创建promise对象" class="headerlink" title="创建promise对象"></a><strong>创建promise对象</strong></h5><p>promise是一个<strong>构造函数</strong>，可以通过<strong>new</strong>来创建实例对象</p>
<p>Promise的构造函数接收<strong>一个参数</strong>:函数,并且这个函数需要传入<strong>两个参数</strong>:</p>
<ul>
<li><strong>resolve</strong>:异步操作执行成功后的回调函数</li>
<li><strong>reject</strong>:异步操作执行失败后的回调函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//做一些异步操作</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;执行完成&#x27;</span>);</span><br><span class="line">        resolve(<span class="string">&#x27;我是成功！！&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="then链式调用"><a href="#then链式调用" class="headerlink" title="then链式调用"></a><strong>then链式调用</strong></h5><p>promise可以通过链式调用来减少多层回调嵌套</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,rehect</span>) =&gt;</span>&#123;</span><br><span class="line">     resolve(<span class="string">&#x27;ok&#x27;</span>);          </span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="reject的用法"><a href="#reject的用法" class="headerlink" title="reject的用法"></a><strong>reject的用法</strong></h5><p>把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//做一些异步操作</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> num = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">10</span>); <span class="comment">//生成1-10的随机数</span></span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">5</span>)&#123;</span><br><span class="line">            resolve(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            reject(<span class="string">&#x27;数字太大了&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>,data);</span><br><span class="line">    &#125;,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;rejected&#x27;</span>,err);</span><br><span class="line">    &#125;</span><br><span class="line">); </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132043346.webp" alt="img">或者<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16377e4fd8619228~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<hr>
<h5 id="catch的用法"><a href="#catch的用法" class="headerlink" title="catch的用法"></a><strong>catch的用法</strong></h5><p>catch的作用与then的第二个参数类似,用于捕获失败的回调,不过与后者不同的是，在链式调用时，如果代码出错了，他不会报错使js执行停止，而是会进入到catch方法中,并捕获到异常</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>,data);</span><br><span class="line">    <span class="built_in">console</span>.log(somedata); <span class="comment">//此处的somedata未定义</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;rejected&#x27;</span>,err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132046474.webp" alt="img"></p>
<p>也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能</p>
<hr>
<h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a><strong>Promise.all()</strong></h5><p><strong>用法</strong>:接受一个<strong>数组</strong>参数，里面的值最终都返回Promise对象</p>
<p><strong>特点</strong>:谁执行<strong>慢</strong>,以谁为准执行回调</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">let</span> Promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">let</span> Promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([Promise1, Promise2, Promise3])</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="title">funciton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 三个都成功则成功  </span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 只要有失败，则失败 </span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>应用场景:<em>一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</em></p>
<hr>
<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a><strong>Promise.race()</strong></h5><p><strong>用法</strong>:接受一个数组参数,里面的值最终都返回Promise对象</p>
<p><strong>特点</strong>:谁执行<strong>快</strong>，以谁为准执行回调</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// resolve(1);</span></span><br><span class="line">    reject(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([promise1,promise2,promise3])</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;data&quot;</span>,data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;err&quot;</span>,err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a><strong>Promise.any()</strong></h5><p><strong>注意</strong>:<strong>Promise.any()尚未被所有浏览器所支持</strong>,node环境下不能使用这个API</p>
<p><strong>用法</strong>:接受一个数组参数,里面的值最终都返回Promise对象</p>
<p><strong>特点</strong>:只要有一个promise执行成功,那么就返回那个成功的promise</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// resolve(1);</span></span><br><span class="line">    reject(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.any([promise1,promise2,promise3])</span><br><span class="line"></span><br><span class="line">p</span><br><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;data&quot;</span>,data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;err&quot;</span>,err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-async-await"><a href="#3-async-await" class="headerlink" title="3.async/await"></a>3.<strong>async/await</strong></h4><h5 id="1-什么是async"><a href="#1-什么是async" class="headerlink" title="1.什么是async?"></a>1.什么是async?</h5><p><strong>介绍</strong>:async函数是使用<code>async</code>关键字声明的函数。 async函数是<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction"><code>AsyncFunction</code></a>构造函数的实例， 并且其中允许使用<code>await</code>关键字。<code>async</code>和<code>await</code>关键字让我们可以用一种更简洁的方式写出基于<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>的异步行为，而无需刻意地链式调用<code>promise</code>。</p>
<p><strong>特性</strong>:async函数可能包含0个或者多个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await"><code>await</code></a>表达式。await表达式会暂停整个async函数的执行进程并出让其控制权，只有当其等待的基于promise的异步操作被兑现或被拒绝之后才会恢复进程。promise的解决值会被当作该await表达式的返回值。使用<code>async</code> / <code>await</code>关键字就可以在异步代码中使用普通的<code>try</code> / <code>catch</code>代码块。</p>
<p><code>async</code> 函数是 <code>Generator</code> 函数的语法糖。使用 关键字 <code>async</code> 来表示，在函数内部使用 <code>await</code> 来表示异步。相较于 <code>Generator</code>，<code>async</code> 函数的改进在于下面四点：</p>
<ul>
<li><strong>内置执行器</strong>。<code>Generator</code> 函数的执行必须依靠执行器，而 <code>async</code> 函数自带执行器，调用方式跟普通函数的调用一样</li>
<li><strong>更好的语义</strong>。<code>async</code> 和 <code>await</code> 相较于 <code>*</code> 和 <code>yield</code> 更加语义化</li>
<li><strong>更广的适用性</strong>。<code>co</code> 模块约定，<code>yield</code> 命令后面只能是 Thunk 函数或 Promise对象。而 <code>async</code> 函数的 <code>await</code> 命令后面则可以是 Promise 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作）</li>
<li><strong>返回值是 Promise</strong>。<code>async</code> 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 <code>then()</code> 方法进行调用</li>
</ul>
<p><code>async</code>是ES7新出的特性，表明当前函数是异步函数，不会阻塞线程导致后续代码停止运行。</p>
<hr>
<h5 id="2-async函数怎么用"><a href="#2-async函数怎么用" class="headerlink" title="2.async函数怎么用?"></a>2.async函数怎么用?</h5><p><strong>async</strong>用来声明函数是一个异步函数</p>
<p><strong>await</strong>表示紧跟在后面的表达式需要等待结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">asuncFn();</span><br></pre></td></tr></table></figure>



<p><strong>async</strong>函数返回的是一个<strong>promise</strong>对象,状态为<strong>resolved</strong>,参数是<strong>return</strong>的值,所以async函数可以链式调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;我后执行&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">asyncFn().then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);<span class="comment">//我后执行</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我先执行&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>async</strong>函数返回的是一个promise对象，如果再执行过程中函数<strong>内部抛出异常</strong>或者返回<strong>reject</strong>，都会是的函数的promise状态变为失败<strong>rejected</strong>，函数抛出异常后，可以通过<strong>catch</strong>接收到返回的错误信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">Promise</span>.reject(<span class="string">&#x27;reason&#x27;</span>)</span><br><span class="line">    <span class="comment">// throw new Error(&#x27;has error&#x27;)</span></span><br><span class="line">&#125;</span><br><span class="line">asyncFn().then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;,<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;我先执行&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>async函数接收到的返回值,如果不是<strong>异常</strong>或者<strong>reject</strong>，则判定成功,即<strong>resolve</strong></p>
<p>以下结果会使async函数判定<strong>失败</strong>:</p>
<ul>
<li>内部含有直接使用并且未声明的变量或者函数。</li>
<li>内部抛出一个错误<code>throw new Error</code>或者返回<code>reject</code>状态<code>return Promise.reject(&#39;执行失败&#39;)</code></li>
<li>函数方法执行出错（🌰：Object使用push()）等等…</li>
</ul>
<p>async函数如果需要返回结果,都必须使用<strong>return</strong>来返回,不论是<strong>reject</strong>还是<strong>resolve</strong>都需要使用return，不然就会返回一个值为<strong>undefined</strong> 的<strong>resolved</strong>(成功)状态</p>
<hr>
<h5 id="3-await是什么"><a href="#3-await是什么" class="headerlink" title="3.await是什么"></a>3.await是什么</h5><p><strong>await</strong>的意思是<strong>async wait</strong>(异步等待),<strong>await必须配合async使用</strong>，<strong>async函数必须等到内部所有的await命令的promise执行完,才会返回结果</strong></p>
<p><strong>打个比方，await是学生，async是校车，必须等人齐了再开车。</strong></p>
<p>就是说，必须等所有<code>await</code> 函数执行完毕后，才会告诉<code>promise</code>我成功了还是失败了，执行<code>then</code>或者<code>catch</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function awaitReturn() &#123;     </span><br><span class="line">    return await 1</span><br><span class="line">&#125;;</span><br><span class="line">awaitReturn().then(success =&gt; console.log(&#x27;成功&#x27;, success))</span><br><span class="line">             .catch(error =&gt; console.log(&#x27;失败&#x27;,error))</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203141014457.webp" alt="img"></p>
<p>async中的await会返回一个<strong>promise</strong>,<strong>下一个await必须等待上一个await返回promise结果状态才会开始执行</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> time1;</span><br><span class="line"><span class="keyword">let</span> time2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    time1 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第一个函数执行完毕&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    time2 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;第二个函数执行完毕&quot;</span>,time2-time1);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeoutFn = <span class="function"><span class="keyword">function</span>(<span class="params">timeout</span>)</span>&#123; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">setTimeout</span>(resolve, timeout);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeOut</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> timeoutFn(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">await</span> timeoutFn(<span class="number">2000</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">timeOut()</span><br></pre></td></tr></table></figure>

<p>不考虑<strong>event loop</strong>(事件循环)</p>
<p>上面的例子中 两个<strong>setTimeout</strong>函数会在<strong>2s</strong>左右(之所以说左右这个词,是因为函数执行会消耗几毫秒时间)，</p>
<p>而<strong>timeOut</strong>函数则需要<strong>3s</strong>左右的时间才会执行完成,这也说明了下一个<strong>await</strong>必须等待上一个<strong>await</strong>返回promise结果状态才会开始执行的结论是正确的</p>
<hr>
<p><strong>await后面的表达式应该返回一个promise，如果不是promise，js内部也会将其转换为一个resolved状态的 promise</strong></p>
<h3 id="5-深浅拷贝"><a href="#5-深浅拷贝" class="headerlink" title="5.深浅拷贝"></a>5.深浅拷贝</h3><p>JavaScript的数据类型分为<strong>基本数据类型</strong>和<strong>引用数据类型</strong>。</p>
<p>对于<strong>基本数据类型</strong>的拷贝，并没有深浅拷贝的区别，我们所说的<strong>深浅拷贝都是对于引用数据类型而言的</strong>。</p>
<h4 id="什么是浅拷贝"><a href="#什么是浅拷贝" class="headerlink" title="什么是浅拷贝?"></a>什么是浅拷贝?</h4><p>浅拷贝的意思就是只复制引用，而未复制真正的值。</p>
<p>当我们浅拷贝一个数组或者对象后，改变这个新的数组或对象,那么被我们拷贝的数组和对象也会改变</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];<span class="comment">//数组是引用类型</span></span><br><span class="line"><span class="keyword">const</span> originObj = &#123;<span class="attr">a</span>:<span class="string">&#x27;a&#x27;</span>,<span class="attr">b</span>:<span class="string">&#x27;b&#x27;</span>,<span class="attr">c</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="attr">d</span>:&#123;<span class="attr">dd</span>:<span class="string">&#x27;dd&#x27;</span>&#125;&#125;;<span class="comment">//对象是引用类型</span></span><br><span class="line"><span class="keyword">let</span> originType = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> originNumber = <span class="number">1</span>; <span class="comment">//基本值类型,不存在深浅拷贝之分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clonedArray = originArray;</span><br><span class="line"><span class="keyword">const</span> clonedObj = originObj;</span><br><span class="line"><span class="keyword">let</span> cloneNumber = originNumber;</span><br><span class="line"><span class="keyword">let</span> cloneType = originType;</span><br><span class="line"></span><br><span class="line">clonedArray.push(<span class="number">6</span>);</span><br><span class="line">clonedObj.a = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line">cloneNumber = <span class="number">2</span>;</span><br><span class="line">cloneType = &#123;<span class="attr">a</span>:<span class="string">&#x27;a&#x27;</span>,<span class="attr">b</span>:<span class="string">&#x27;b&#x27;</span>,<span class="attr">b</span>:<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(originArray);<span class="comment">//[ 1, 2, 3, 4, 5, 6 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(originObj);<span class="comment">//&#123; a: &#x27;aa&#x27;, b: &#x27;b&#x27;, c: [ 1, 2, 3 ], d: &#123; dd: &#x27;dd&#x27; &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(originNumber);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(originType);<span class="comment">//当我们改变了变量引用的类型时,这个新变量和被拷贝的变量就没有了任何联系(二者指向不同引用)</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="什么是深拷贝？"><a href="#什么是深拷贝？" class="headerlink" title="什么是深拷贝？"></a>什么是深拷贝？</h4><p>深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。</p>
<p><strong>只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。</strong></p>
<p>目前实现深拷贝的方法不多，主要是两种：</p>
<ol>
<li>利用 <code>JSON</code> 对象中的 <code>parse</code> 和 <code>stringify</code></li>
<li>利用递归来实现每一层都重新创建对象并赋值</li>
</ol>
<hr>
<p><strong>利用JSON.stringify/parse的方法实现深拷贝</strong></p>
<p>JSON.stringify的作用是<strong>将一个javascript值转换成json字符串</strong></p>
<p>JSON.parse的作用是<strong>将一个JSON字符串转换成javascript值或对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> cloneArray = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(originArray));</span><br><span class="line"><span class="built_in">console</span>.log(cloneArray === originArray); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> originObj = &#123;<span class="attr">a</span>:<span class="string">&#x27;a&#x27;</span>,<span class="attr">b</span>:<span class="string">&#x27;b&#x27;</span>,<span class="attr">c</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="attr">d</span>:&#123;<span class="attr">dd</span>:<span class="string">&#x27;dd&#x27;</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> cloneObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(originObj));</span><br><span class="line"><span class="built_in">console</span>.log(cloneObj === originObj); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">cloneObj.a = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line">cloneObj.c = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">cloneObj.d.dd = <span class="string">&#x27;doubled&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneObj); <span class="comment">// &#123;a:&#x27;aa&#x27;,b:&#x27;b&#x27;,c:[1,1,1],d:&#123;dd:&#x27;doubled&#x27;&#125;&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(originObj); <span class="comment">// &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子可以实现深拷贝,但是这种方式只能适用于一些简单的情况，因为<strong>在使用HSON.stringify()时，<code>undefined</code>、<code>function</code>、<code>symbol</code> 会在转换过程中被忽略。。</strong></p>
<p>如果对象中含有以上几种类型时，就不能用这个方法进行深拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originObj = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;axuebin&#x27;</span>,</span><br><span class="line">  <span class="attr">sayHello</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(originObj); <span class="comment">// &#123;name: &quot;axuebin&quot;, sayHello: ƒ&#125;</span></span><br><span class="line"><span class="keyword">const</span> cloneObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(originObj));</span><br><span class="line"><span class="built_in">console</span>.log(cloneObj); <span class="comment">// &#123;name: &quot;axuebin&quot;&#125;</span></span><br></pre></td></tr></table></figure>



<hr>
<p><strong>使用递归的方法实现深拷贝</strong></p>
<p>递归的思想就很简单了，就是对每一层的数据都实现一次 <code>创建对象-&gt;对象赋值</code> 的操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">deepClone</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> targetObj = source.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;; <span class="comment">// 判断复制的目标是数组还是对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.hasOwnProperty(key)) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(source[key] &amp;&amp; <span class="keyword">typeof</span> source[key] === <span class="string">&#x27;object&#x27;</span>)&#123;<span class="comment">//如果值是对象就递归</span></span><br><span class="line">                targetObj[key] = source[key].constructor === <span class="string">&#x27;Array&#x27;</span> ? [] : &#123;&#125;;</span><br><span class="line">                deepClone(targetObj[key]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果不是就直接赋值</span></span><br><span class="line">                targetObj[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> targetObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> originObj = &#123;<span class="attr">a</span>:<span class="string">&#x27;a&#x27;</span>,<span class="attr">b</span>:<span class="string">&#x27;b&#x27;</span>,<span class="attr">c</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="attr">d</span>:&#123;<span class="attr">dd</span>:<span class="string">&#x27;dd&#x27;</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> cloneObj = deepClone(originObj);</span><br><span class="line"><span class="built_in">console</span>.log(cloneObj === originObj); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">cloneObj.a = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line">cloneObj.c = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">cloneObj.d.dd = <span class="string">&#x27;doubled&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneObj); <span class="comment">// &#123;a:&#x27;aa&#x27;,b:&#x27;b&#x27;,c:[1,1,1],d:&#123;dd:&#x27;doubled&#x27;&#125;&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(originObj); <span class="comment">// &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> originObj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;张振明&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHello</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(originObj2); <span class="comment">// &#123;name: &quot;张振明&quot;, sayHello: ƒ&#125;</span></span><br><span class="line">  <span class="keyword">const</span> cloneObj2 = deepClone(originObj2);</span><br><span class="line">  <span class="built_in">console</span>.log(cloneObj2); <span class="comment">// &#123;name: &quot;张振明&quot;, sayHello: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="JavaScript中的拷贝方法"><a href="#JavaScript中的拷贝方法" class="headerlink" title="JavaScript中的拷贝方法"></a>JavaScript中的拷贝方法</h4><p>JavaScript数组中有两个方法,<strong>concat</strong>和<strong>slice</strong>,他们都<strong>不会改变原数组</strong>，而是返回一个新数组</p>
<p>所以他们是可以实现对原数组的拷贝的,另外es6新增的<code>Object.assgn</code> 方法和 <code>...</code> 展开运算符也能实现对对象的拷贝</p>
<p>这里只说明结论,不解释详细过程</p>
<p><strong>concat</strong></p>
<p>该方法可以连接两个或者更多的数组，但是它不会修改已存在的数组，而是返回一个新数组。</p>
<p><strong>结论：<code>concat</code> 只是对数组的第一层进行深拷贝。</strong></p>
<hr>
<p><strong>slice</strong></p>
<p><strong>结论：<code>slice</code> 只是对数组的第一层进行深拷贝。</strong></p>
<hr>
<p><strong>Object.assign()</strong></p>
<p><strong>结论：<code>Object.assign()</code> 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值</strong></p>
<hr>
<p><strong>… 展开运算符</strong></p>
<p><strong>结论：<code>...</code> 实现的是对象第一层的深拷贝。后面的只是拷贝的引用值。</strong></p>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>赋值运算符 <code>=</code> 实现的是浅拷贝，只拷贝对象的引用值；</li>
<li>JavaScript 中数组和对象自带的拷贝方法都是“首层浅拷贝”；</li>
<li><code>JSON.stringify</code> 实现的是深拷贝，但是对目标对象有要求；</li>
<li>若想真正意义上的深拷贝，请递归。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:957957209@qq.com">zzm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/03/13/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">http://example.com/2022/03/13/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">AstronautBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/HTML/">HTML</a><a class="post-meta__tags" href="/tags/Http/">Http</a><a class="post-meta__tags" href="/tags/CSS/">CSS</a><a class="post-meta__tags" href="/tags/Webpack/">Webpack</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041355284.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"><img class="next-cover" src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440795.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面试题整理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="面试题整理"><img class="cover" src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440795.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-04</div><div class="title">面试题整理</div></div></a></div><div><a href="/2022/01/08/%E6%89%8B%E5%86%99new/" title="手写new"><img class="cover" src="/./img/background.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-08</div><div class="title">手写new</div></div></a></div><div><a href="/2022/03/01/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/" title="JavaScript深入之作用域链"><img class="cover" src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440862.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-01</div><div class="title">JavaScript深入之作用域链</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTEyNi8zMTU5NA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/avater1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zzm</div><div class="author-info__description">好久不见</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hnistzzm"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hnistzzm" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://gitee.com/hnistzzm" target="_blank" title="Gitee"><i class="fab fa-git-alt"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=957957209" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客网站</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">面试复习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JavaScript-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">1.JavaScript 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E9%97%AD%E5%8C%85"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.执行上下文&#x2F;作用域&#x2F;闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.什么是执行上下文?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%9C%E7%94%A8%E5%9F%9F-Scope"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">2.作用域(Scope)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%97%AD%E5%8C%85"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">3.闭包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-this-call-apply-bind"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.this&#x2F;call&#x2F;apply&#x2F;bind</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-this%E7%9A%84%E6%8C%87%E5%90%91"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.this的指向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-call"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2.call</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-apply"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">3.apply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-bind"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">4.bind</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8E%9F%E5%9E%8B-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.原型&#x2F;继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1.原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">2.继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#new"><span class="toc-number">1.1.3.2.1.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.3.2.2.</span> <span class="toc-text">类式继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.3.2.3.</span> <span class="toc-text">构造函数继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.3.2.4.</span> <span class="toc-text">组合式继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.3.2.5.</span> <span class="toc-text">原型式继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.3.2.6.</span> <span class="toc-text">寄生式继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.3.2.7.</span> <span class="toc-text">寄生组合式继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-promise"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.promise</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFpromise-%E5%AE%83%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1.什么是promise?它用来解决什么问题?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-promise%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">2.promise用法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BApromise%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.4.2.1.</span> <span class="toc-text">创建promise对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#then%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.4.2.2.</span> <span class="toc-text">then链式调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reject%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.4.2.3.</span> <span class="toc-text">reject的用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#catch%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.4.2.4.</span> <span class="toc-text">catch的用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-all"><span class="toc-number">1.1.4.2.5.</span> <span class="toc-text">Promise.all()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-race"><span class="toc-number">1.1.4.2.6.</span> <span class="toc-text">Promise.race()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-any"><span class="toc-number">1.1.4.2.7.</span> <span class="toc-text">Promise.any()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-async-await"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">3.async&#x2F;await</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFasync"><span class="toc-number">1.1.4.3.1.</span> <span class="toc-text">1.什么是async?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-async%E5%87%BD%E6%95%B0%E6%80%8E%E4%B9%88%E7%94%A8"><span class="toc-number">1.1.4.3.2.</span> <span class="toc-text">2.async函数怎么用?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-await%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.4.3.3.</span> <span class="toc-text">3.await是什么</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.1.5.</span> <span class="toc-text">5.深浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">什么是浅拷贝?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">什么是深拷贝？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">JavaScript中的拷贝方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/13/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" title="面试知识整理"><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041355284.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试知识整理"/></a><div class="content"><a class="title" href="/2022/03/13/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" title="面试知识整理">面试知识整理</a><time datetime="2022-03-13T13:05:16.000Z" title="发表于 2022-03-13 21:05:16">2022-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="面试题整理"><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440795.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试题整理"/></a><div class="content"><a class="title" href="/2022/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="面试题整理">面试题整理</a><time datetime="2022-03-04T08:20:18.000Z" title="发表于 2022-03-04 16:20:18">2022-03-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/01/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E8%B7%AF%E7%BA%BF/" title="面试复习路线"><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440678.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试复习路线"/></a><div class="content"><a class="title" href="/2022/03/01/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E8%B7%AF%E7%BA%BF/" title="面试复习路线">面试复习路线</a><time datetime="2022-03-01T08:38:56.000Z" title="发表于 2022-03-01 16:38:56">2022-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/01/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/" title="JavaScript深入之作用域链"><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440862.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript深入之作用域链"/></a><div class="content"><a class="title" href="/2022/03/01/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/" title="JavaScript深入之作用域链">JavaScript深入之作用域链</a><time datetime="2022-03-01T08:10:06.000Z" title="发表于 2022-03-01 16:10:06">2022-03-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/02/27/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BAvue%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E5%BC%80%E5%8F%91%E5%85%A8%E9%9D%A0%E5%AE%83%E4%BA%86/" title="史上最强vue总结---面试开发全靠它了"><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041438071.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="史上最强vue总结---面试开发全靠它了"/></a><div class="content"><a class="title" href="/2022/02/27/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%BC%BAvue%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E5%BC%80%E5%8F%91%E5%85%A8%E9%9D%A0%E5%AE%83%E4%BA%86/" title="史上最强vue总结---面试开发全靠它了">史上最强vue总结---面试开发全靠它了</a><time datetime="2022-02-27T12:44:24.000Z" title="发表于 2022-02-27 20:44:24">2022-02-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By zzm</div><div class="footer_custom_text">你将不再是道具，而是人如其名</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (true) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>