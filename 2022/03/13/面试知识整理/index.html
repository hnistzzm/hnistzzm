<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试知识整理 | AstronautBlog</title><meta name="keywords" content="JavaScript,HTML,Http,CSS,Webpack"><meta name="author" content="zzm,957957209@qq.com"><meta name="copyright" content="zzm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="面试复习 1.JavaScript 基础 1.执行上下文&#x2F;作用域&#x2F;闭包1.什么是执行上下文?执行上下文是评估和执行JavaScript代码环境的抽象概念。每当JavaScript代码在运行时，他都是在执行上下文中运行。  执行上下文的类型 JavaScript共有三种执行上下文类型  全局执行上下文 这是基础的上下文,任何不在函数内部的代码都在全局上下文中.他会执行两件事:创建一个全局的windo">
<meta property="og:type" content="article">
<meta property="og:title" content="面试知识整理">
<meta property="og:url" content="http://example.com/2022/03/13/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="AstronautBlog">
<meta property="og:description" content="面试复习 1.JavaScript 基础 1.执行上下文&#x2F;作用域&#x2F;闭包1.什么是执行上下文?执行上下文是评估和执行JavaScript代码环境的抽象概念。每当JavaScript代码在运行时，他都是在执行上下文中运行。  执行上下文的类型 JavaScript共有三种执行上下文类型  全局执行上下文 这是基础的上下文,任何不在函数内部的代码都在全局上下文中.他会执行两件事:创建一个全局的windo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440795.webp">
<meta property="article:published_time" content="2022-03-13T13:05:16.000Z">
<meta property="article:modified_time" content="2022-03-22T11:19:19.930Z">
<meta property="article:author" content="zzm">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="HTML">
<meta property="article:tag" content="Http">
<meta property="article:tag" content="CSS">
<meta property="article:tag" content="Webpack">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440795.webp"><link rel="shortcut icon" href="/./img/first.png"><link rel="canonical" href="http://example.com/2022/03/13/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试知识整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-22 19:19:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avater1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-folder-ope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 我的</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440795.webp')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">AstronautBlog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-folder-ope"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 我的</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试知识整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-13T13:05:16.000Z" title="发表于 2022-03-13 21:05:16">2022-03-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-22T11:19:19.930Z" title="更新于 2022-03-22 19:19:19">2022-03-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E6%9D%82%E7%83%A9/">前端知识杂烩</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">36.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>123分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试知识整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>面试复习</p>
<h2 id="1-JavaScript-基础"><a href="#1-JavaScript-基础" class="headerlink" title="1.JavaScript 基础"></a>1.JavaScript 基础</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132100087.png" alt="image-20220308142823940"></p>
<h3 id="1-执行上下文-作用域-闭包"><a href="#1-执行上下文-作用域-闭包" class="headerlink" title="1.执行上下文/作用域/闭包"></a>1.执行上下文/作用域/闭包</h3><h4 id="1-什么是执行上下文"><a href="#1-什么是执行上下文" class="headerlink" title="1.什么是执行上下文?"></a>1.什么是执行上下文?</h4><p>执行上下文是评估和执行JavaScript代码环境的抽象概念。每当JavaScript代码在运行时，他都是在执行上下文中运行。</p>
<hr>
<p><strong>执行上下文的类型</strong></p>
<p>JavaScript共有<strong>三种</strong>执行上下文类型</p>
<ul>
<li><strong>全局执行上下文</strong><ul>
<li>这是基础的上下文,任何不在函数内部的代码都在全局上下文中.他会执行两件事:创建一个全局的window对象(浏览器环境的情况下),并且设置this的值等于这个全局对象。一个程序中只会有一个全局执行上下文</li>
</ul>
</li>
<li><strong>函数执行上下文</strong><ul>
<li>每当函数被调用时，都会为该函数创建一个新的执行上下文。每个函数都有他自己的执行上下文，只不过是在函数被调用时才被创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，他会按定义的瞬狙执行一系列步骤</li>
</ul>
</li>
<li><strong>Eval函数执行上下文</strong><ul>
<li>执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文</li>
</ul>
</li>
</ul>
<hr>
<p><strong>执行上下文栈</strong></p>
<p>执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。</p>
<p>当JavaScript引擎第一次遇到你的脚本时，他会创建一个全局的执行上下文并且压入当前执行栈。<strong>每当引擎遇到一个函数调用，他会为该函数创建一个新的执行上下文并压入栈的顶部.</strong></p>
<p>引擎会执行那些执行上下文位于栈顶的函数.<strong>每当函数执行结束之后，最上层的执行上下文从栈中弹出</strong>，控制流程到达当前栈中的下一个上下文</p>
<p><strong>一旦所有代码执行完毕，JavaScript引擎从当前栈中移除全局执行上下文</strong></p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132100915.png" alt="image-20220308144717269"></p>
<hr>
<p><strong>怎么创建执行上下文?</strong></p>
<p>创建执行上下文有两个阶段:</p>
<ol>
<li><strong>创建阶段</strong></li>
<li><strong>执行阶段</strong></li>
</ol>
<hr>
<p><strong>创建阶段</strong></p>
<p>在JavaScript代码执行前，执行上下文将经历创建阶段。在创建阶段将会发生三件事:</p>
<ol>
<li><strong>this</strong>值的绑定</li>
<li>创建<strong>词法环境</strong></li>
<li>创建<strong>变量环境</strong></li>
</ol>
<p>所以执行上下文在概念上表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext = &#123;</span><br><span class="line">  ThisBinding = &lt;this value&gt;,</span><br><span class="line">  LexicalEnvironment = &#123; ... &#125;,</span><br><span class="line">  VariableEnvironment = &#123; ... &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>This绑定:</strong></p>
<p>在全局执行上下文中,<code>this</code>的值指向全局对象(在浏览器中,全局对象为<code>window</code>’)</p>
<p>在函数执行上下文中,this的值取决于该函数是如何被调用的.如果他被一个引用类型对象调用,那么this会被设置成那个对象,否则<code>this</code>的值被设置成全局对象或者<code>undefined</code>(严格模式)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let foo = &#123;</span><br><span class="line">  baz: function() &#123;</span><br><span class="line">  console.log(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.baz();   <span class="comment">// &#x27;this&#x27; 引用 &#x27;foo&#x27;, 因为 &#x27;baz&#x27; 被</span></span><br><span class="line">             <span class="comment">// 对象 &#x27;foo&#x27; 调用</span></span><br><span class="line"></span><br><span class="line">let bar = foo.baz;</span><br><span class="line"></span><br><span class="line">bar();       <span class="comment">// &#x27;this&#x27; 指向全局 window 对象，因为</span></span><br><span class="line">             <span class="comment">// 没有指定引用对象</span></span><br></pre></td></tr></table></figure>



<p><strong>词法环境</strong></p>
<p><a href="https://link.juejin.cn/?target=http://ecma-international.org/ecma-262/6.0/">官方的 ES6</a> 文档把词法环境定义为</p>
<blockquote>
<p><strong>词法环境</strong>是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义<strong>标识符</strong>和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用<strong>外部</strong>词法环境的空值组成。</p>
</blockquote>
<p>词法环境是一种持有<strong>变量符-变量映射</strong>的结构(标识符指的是变量/函数的名字,而变量是对实际对象或原始数据的引用)</p>
<p>在词法环境的内部有两个组件:1.<strong>环境记录器</strong>和2.一个<strong>外部环境的引用</strong></p>
<p>1.<strong>环境记录器</strong>是存储变量和函数声明的实际位置</p>
<p>2.<strong>外部环境的引用</strong>意味着它可以访问其父级词法环境(作用域)</p>
<p><strong>词法环境</strong>有两种类型: <strong>全局环境</strong>和<strong>函数环境</strong></p>
<ul>
<li><p><strong>全局环境</strong>(在全局执行上下文中)是没有外部环境引用的词法环境,全局环境的外部环境引用是<strong>null</strong>，</p>
<p>它拥有创建的Object/Array等,在环境记录器内的原型函数(关联全局对象,比如window对象)还有任何用户定义的全局变量,并且<code>this</code>的值指向全局对象</p>
</li>
<li><p>在<strong>函数环境</strong>中，函数内部用户定义的变量存储在<strong>环境记录器</strong>中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。</p>
</li>
</ul>
<p>环境记录器也有两种类型:</p>
<ol>
<li><strong>声明式环境记录器</strong>，用来存储变量、函数和参数</li>
<li><strong>对象环境记录器</strong>,用来定义出现在<strong>全局上下文</strong>中的变量和函数关系</li>
</ol>
<p>由上不难得知</p>
<ul>
<li>在<strong>全局环境</strong>中,环境记录器是对象环境记录器</li>
<li>在<strong>函数环境</strong>中,环境记录器是声明式环境记录器</li>
</ul>
<p><strong>注意 :</strong> 对于<strong>函数环境</strong>，<strong>声明式环境记录器</strong>还包含了一个传递给函数的 <code>arguments</code> 对象（此对象存储索引和参数的映射）和传递给函数的参数的 <strong>length</strong>。</p>
<p>抽象地讲，词法环境在伪代码中看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;Global or outer function environment reference&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>变量环境</strong></p>
<p>变量环境其实也是一个<strong>词法环境</strong>,其环境记录器中持有变量声明语句在执行上下文中创建的绑定关系</p>
<p>变量环境有着词法环境的所有属性</p>
<p>在ES6中,词法环境组件和变量环境的一个不同就是前者被用来存储函数声明和变量(<code>let</code>和<code>const</code>)绑定,而后者只用来存储<code>var</code>变量绑定</p>
<p>我们看点样例代码来理解上面的概念：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">var</span> c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">e, f</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> g = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">return</span> e * f * g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = multiply(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行上下文看起来像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">GlobalExectionContext = &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">ThisBinding</span>: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      a: &lt; uninitialized &gt;,</span><br><span class="line">      b: &lt; uninitialized &gt;,</span><br><span class="line">      multiply: &lt; func &gt;</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Object&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      c: undefined,</span><br><span class="line">    &#125;</span><br><span class="line">    outer: &lt;null&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">  ThisBinding: &lt;Global Object&gt;,</span><br><span class="line"></span><br><span class="line">  LexicalEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      Arguments: &#123;0: 20, 1: 30, length: 2&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">VariableEnvironment: &#123;</span><br><span class="line">    EnvironmentRecord: &#123;</span><br><span class="line">      Type: &quot;Declarative&quot;,</span><br><span class="line">      // 在这里绑定标识符</span><br><span class="line">      g: undefined</span><br><span class="line">    &#125;,</span><br><span class="line">    outer: &lt;GlobalLexicalEnvironment&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可能你已经注意到 <code>let</code> 和 <code>const</code> 定义的变量并没有关联任何值，但 <code>var</code> 定义的变量被设成了 <code>undefined</code>。</p>
<p>这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 <code>undefined</code>（<code>var</code> 情况下），或者未初始化（<code>let</code> 和 <code>const</code> 情况下）。</p>
<p>这就是为什么你可以在声明之前访问 <code>var</code> 定义的变量（虽然是 <code>undefined</code>），但是在声明之前访问 <code>let</code> 和 <code>const</code> 的变量会得到一个引用错误。</p>
<p>这就是我们说的<strong>变量声明提升</strong>。</p>
<hr>
<p><strong>执行阶段</strong></p>
<p><strong>在此阶段完成对所有存储的变量的分配,最后执行代码.</strong></p>
<p><strong>注意:</strong> 在执行阶段,如果JavaScript引擎不能再源码中声明的实际位置找到<code>let</code>变量的值，那么他就会被赋值为<code>undefined</code></p>
<hr>
<hr>
<h4 id="2-作用域-Scope"><a href="#2-作用域-Scope" class="headerlink" title="2.作用域(Scope)"></a>2.作用域(Scope)</h4><p><strong>什么是作用域?</strong></p>
<p><strong>作用域是指程序源代码中定义变量的区域。</strong></p>
<p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>
<p>JavaScript 采用<strong>词法作用域</strong>(lexical scoping)，也就是静态作用域。</p>
<p>我们可以这样理解：<strong>作用域就是一个独立的地盘，让变量不会外泄、暴露出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong></p>
<p>ES6之前,JavaScript只有<strong>全局作用域</strong>和<strong>函数作用域</strong>,ES6之后，新增了<strong>块级作用域</strong>，可以通过<code>let</code>和<code>const</code>来创建</p>
<hr>
<p><strong>全局作用域和函数作用域</strong></p>
<p>**在代码中任何地方都能访问到的对象拥有全局作用域,**以下几种情况拥有全局作用域:</p>
<ul>
<li>最外层函数和在最外层函数外定义的变量拥有全局作用域</li>
<li>所有未定义直接赋值的变量默认为全局变量，拥有全局作用域</li>
<li>所有window对象的属性拥有全局作用域</li>
</ul>
<p>全局作用域的<strong>弊端</strong>:容易引发命名冲突，污染全局命名空间</p>
<hr>
<p><strong>函数作用域</strong></p>
<p><strong>在函数内部声明的变量</strong>拥有函数作用域,一般只能在固定的代码片段内可以访问到.</p>
<hr>
<p>作用域是分层的,内层作用域可以访问外层作用域的变量,反之则不行</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132100037.png" alt="image-20220308172822751"></p>
<p>值得注意的是：<strong>块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// &#x27;if&#x27; 条件语句块不会创建一个新的作用域</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;Hammad&#x27;</span>; <span class="comment">// name 依然在全局作用域中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// logs &#x27;Hammad&#x27;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>块级作用域</strong></p>
<p>块级作用域可以通过<code>let</code>和<code>const</code>声明,所声明的变量在指定块作用域·之外无法被访问。</p>
<p>块级作用域在如下情况被创建:</p>
<ol>
<li>在一个函数内部</li>
<li>在一个代码块内部(‘**{}**’)</li>
</ol>
<p>块级作用域有以下几个特点:</p>
<ul>
<li>声明变量不会提升的代码块顶部</li>
<li>禁止重复声明</li>
</ul>
<hr>
<p><strong>作用域链</strong></p>
<p>在JavaScript中,函数、块、模块都可以形成作用域,他们之间可以相互嵌套、作用域之间会形成引用关系，这条链叫做作用域链</p>
<p><strong>作用域链的创建和变化</strong></p>
<p><strong>函数创建时:</strong></p>
<p>JavaScript中使用的是词法作用域,<strong>函数的作用域在函数定义的时候就已经决定了</strong></p>
<p>函数有一个内部属性[[scope]]，当函数创建的时候,就会保存所有父变量对象到其中,可以理解为[[scope]]就是所有父变量对象的层级链,但是注意:[[scope]]并不代表完整的作用域链</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数创建时，各自的[[scope]]为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">    fooContext.AO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p><strong>函数被激活时:</strong></p>
<p>当函数被激活时,进入函数上下文,创建VO/AO后就会将活动对象添加到作用域的前端</p>
<p>这时候执行上下文的作用域链,我们命名为Scope</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure>

<p>至此,<strong>作用域链创建完毕</strong></p>
<hr>
<h4 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3.闭包"></a>3.闭包</h4><p><strong>什么是闭包?</strong></p>
<p>闭包就是同时含有对函数对象以及作用域对象引用的对象,实际上所有JavaScript对象都是闭包.</p>
<p><strong>本质</strong>:在一个函数内部创建另一个函数</p>
<p><strong>只要存在函数嵌套,并且内部函数调用了外部函数的属性,就产生了闭包.</strong></p>
<p>闭包的特性:</p>
<ul>
<li>函数嵌套函数</li>
<li>函数内部引用函数外部的参数和变量</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ul>
<hr>
<p><strong>闭包是什么时候被创建的？</strong></p>
<p>因为所有JavaScript对象都是闭包,所以当你定义一个函数时.就产生了闭包</p>
<hr>
<p><strong>闭包是什么时候被销毁的?</strong></p>
<p>当他不被任何其他的对象引用的时候，闭包就被销毁</p>
<hr>
<p><strong>闭包的好处</strong>:</p>
<ul>
<li>保护函数内的变量安全,实现封装,防止变量流入其他环境发生命名冲突</li>
<li>在内存中维持一个变量，延长变量的生命周期</li>
<li>匿名自执行函数可以减少内存消耗</li>
</ul>
<hr>
<p><strong>闭包的缺点:</strong></p>
<ul>
<li>被引用的私有变量不能被销毁，增大了内存的消耗，造成内存泄露</li>
<li>闭包涉及跨域访问，会导致性能损失</li>
</ul>
<hr>
<p><strong>闭包的作用</strong></p>
<ul>
<li>使得函数内部的变量在函数执行完之后，仍然存活在内存中(延长了局部变量的生命周期)</li>
<li>让函数外部可以操作到函数内部的数据</li>
</ul>
<hr>
<p><strong>闭包的原理</strong></p>
<p>当一个函数返回后，没有其他对象会保存对其的引用。所以，它就可能被<code>垃圾回收器</code>回收。</p>
<p>函数对象中总是有一个<code>[[scope]]</code>属性，保存着该函数被定义的时候所能够直接访问的作用域对象。所以，当我们在定义嵌套的函数的时候，这个嵌套的函数的<code>[[scope]]</code>就会引用外围函数（Outer function）的当前作用域对象。</p>
<p>如果我们将这个嵌套函数返回,并被另一个标识符所引用的话,那么这个嵌套函数及其[[scope]]所引用的作用作用域对象就不会被垃圾回收器所销毁,这个对象就会一直存活在内存中,我们可以通过这个作用于对象获取到外部函数的属性和值。</p>
<p>这就是闭包的原理</p>
<hr>
<h3 id="2-this-call-apply-bind"><a href="#2-this-call-apply-bind" class="headerlink" title="2.this/call/apply/bind"></a>2.this/call/apply/bind</h3><h4 id="1-this的指向"><a href="#1-this的指向" class="headerlink" title="1.this的指向"></a>1.this的指向</h4><blockquote>
<p>函数的this是在函数调用时才绑定的,它的指向完全取决于函数的调用位置(也就是函数的调用方法),为了搞清楚<code>this</code>的指向是什么，必须知道相关函数是如何调用的</p>
</blockquote>
<p><strong>在全局上下文中:</strong></p>
<p>非严格模式和严格模式中this都指向顶层对象(在浏览器中是<code>window</code>)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span> === <span class="built_in">window</span> <span class="comment">// true</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="built_in">this</span> === <span class="built_in">window</span>;</span><br><span class="line"><span class="built_in">this</span>.name = <span class="string">&#x27;若川&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// 若川</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>普通函数调用模式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 非严格模式</span><br><span class="line">var name = &#x27;window&#x27;;</span><br><span class="line">var doSth = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">doSth(); // &#x27;window&#x27;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>你可能会误以为<code>window.doSth()</code>是调用的，所以是指向<code>window</code>。虽然本例中<code>window.doSth</code>确实等于<code>doSth</code>。<code>name</code>等于<code>window.name</code>。上面代码中这是因为在<code>ES5</code>中，全局变量是挂载在顶层对象（浏览器是<code>window</code>）中。 事实上，并不是如此。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 非严格模式</span><br><span class="line">let name2 = &#x27;window2&#x27;;</span><br><span class="line">let doSth2 = function()&#123;</span><br><span class="line">    console.log(this === window);</span><br><span class="line">    console.log(this.name2);</span><br><span class="line">&#125;</span><br><span class="line">doSth2() // true, undefined</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这个例子中<code>let</code>没有给顶层对象中（浏览器是window）添加属性，<code>window.name2和window.doSth</code>都是<code>undefined</code>。</p>
<p>严格模式中，普通函数中的<code>this</code>则表现不同，表现为<code>undefined</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 严格模式</span><br><span class="line">&#x27;use strict&#x27;</span><br><span class="line">var name = &#x27;window&#x27;;</span><br><span class="line">var doSth = function()&#123;</span><br><span class="line">    console.log(typeof this === &#x27;undefined&#x27;);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">doSth(); // true，// 报错，因为this是undefined</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>看过的《你不知道的<code>JavaScript</code>》上卷的读者，应该知道书上将这种叫做默认绑定。 对<code>call</code>，<code>apply</code>熟悉的读者会类比为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">doSth.call(undefined);</span><br><span class="line">doSth.apply(undefined);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>效果是一样的，<code>call</code>，<code>apply</code>作用之一就是用来修改函数中的<code>this</code>指向为第一个参数的。 第一个参数是<code>undefined</code>或者<code>null</code>，非严格模式下，是指向<code>window</code>。严格模式下，就是指向第一个参数。后文详细解释。<br> 经常有这类代码（回调函数），其实也是普通函数调用模式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;若川&#x27;;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;, 0);</span><br><span class="line">// 语法</span><br><span class="line">setTimeout(fn | code, 0, arg1, arg2, ...)</span><br><span class="line">// 也可以是一串代码。也可以传递其他函数</span><br><span class="line">// 类比 setTimeout函数内部调用fn或者执行代码`code`。</span><br><span class="line">fn.call(undefined, arg1, arg2, ...);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>对象中的函数（方法）调用模式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var name = &#x27;window&#x27;;</span><br><span class="line">var doSth = function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var student = &#123;</span><br><span class="line">    name: &#x27;若川&#x27;,</span><br><span class="line">    doSth: doSth,</span><br><span class="line">    other: &#123;</span><br><span class="line">        name: &#x27;other&#x27;,</span><br><span class="line">        doSth: doSth,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">student.doSth(); // &#x27;若川&#x27;</span><br><span class="line">student.other.doSth(); // &#x27;other&#x27;</span><br><span class="line">// 用call类比则为：</span><br><span class="line">student.doSth.call(student);</span><br><span class="line">// 用call类比则为：</span><br><span class="line">student.other.doSth.call(student.other);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>但往往会有以下场景，把对象中的函数赋值成一个变量了。 这样其实又变成普通函数了，所以使用普通函数的规则（默认绑定）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var studentDoSth = student.doSth;</span><br><span class="line">studentDoSth(); // &#x27;window&#x27;</span><br><span class="line">// 用call类比则为：</span><br><span class="line">studentDoSth.call(undefined);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong><code>call、apply、bind</code> 调用模式</strong></p>
<p>上文提到<code>call</code>、<code>apply</code>，这里详细解读一下。先通过<code>MDN</code>认识下<code>call</code>和<code>apply</code> <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call">MDN 文档：Function.prototype.call()</a><br> <strong>语法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>thisArg</strong><br> 在<code>fun</code>函数运行时指定的<code>this</code>值。需要注意的是，指定的<code>this</code>值并不一定是该函数执行时真正的<code>this</code>值，如果这个函数处于<strong>非严格模式</strong>下，则指定为<code>null</code>和<code>undefined</code>的<code>this</code>值会自动指向全局对象(浏览器中就是<code>window</code>对象)，同时值为原始值(数字，字符串，布尔值)的<code>this</code>会指向该原始值的自动包装对象。<br> <strong>arg1, arg2, …</strong><br> 指定的参数列表<br> <strong>返回值</strong><br> 返回值是你调用的方法的返回值，若该方法没有返回值，则返回<code>undefined</code>。<br> <code>apply</code>和<code>call</code>类似。只是参数不一样。它的参数是数组（或者类数组）。</p>
<p>根据参数<code>thisArg</code>的描述，可以知道，<code>call</code>就是改变函数中的<code>this</code>指向为<code>thisArg</code>，并且执行这个函数，这也就使<code>JS</code>灵活很多。严格模式下，<code>thisArg</code>是原始值是值类型，也就是原始值。不会被包装成对象。举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var doSth = function(name)&#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(name);</span><br><span class="line">&#125;</span><br><span class="line">doSth.call(2, &#x27;若川&#x27;); // Number&#123;2&#125;, &#x27;若川&#x27;</span><br><span class="line">var doSth2 = function(name)&#123;</span><br><span class="line">    &#x27;use strict&#x27;;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(name);</span><br><span class="line">&#125;</span><br><span class="line">doSth2.call(2, &#x27;若川&#x27;); // 2, &#x27;若川&#x27;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>虽然一般不会把<code>thisArg</code>参数写成值类型。但还是需要知道这个知识。 之前写过一篇文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903728147857415">面试官问：能否模拟实现<code>JS</code>的<code>call</code>和<code>apply</code>方法</a> 就是利用对象上的函数<code>this</code>指向这个对象，来模拟实现<code>call</code>和<code>apply</code>的。感兴趣的读者思考如何实现，再去看看笔者的实现。</p>
<p><code>bind</code>和<code>call</code>和<code>apply</code>类似，第一个参数也是修改<code>this</code>指向，只不过返回值是新函数，新函数也能当做构造函数（<code>new</code>）调用。 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">MDN Function.prototype.bind</a></p>
<blockquote>
<p><code>bind()</code>方法创建一个新的函数， 当这个新函数被调用时<code>this</code>键值为其提供的值，其参数列表前几项值为创建时指定的参数序列。</p>
</blockquote>
<p><strong>语法：</strong> fun.bind(thisArg[, arg1[, arg2[, …]]])<br> <strong>参数：</strong> <strong>thisArg</strong> 调用绑定函数时作为this参数传递给目标函数的值。 如果使用<code>new</code>运算符构造绑定函数，则忽略该值。当使用<code>bind</code>在<code>setTimeout</code>中创建一个函数（作为回调提供）时，作为<code>thisArg</code>传递的任何原始值都将转换为<code>object</code>。如果没有提供绑定的参数，则执行作用域的<code>this</code>被视为新函数的<code>thisArg</code>。 <strong>arg1, arg2, …</strong> 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 <strong>返回值</strong> 返回由指定的<code>this</code>值和初始化参数改造的原函数拷贝。</p>
<p><strong>构造函数调用模式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Student(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    console.log(this); // &#123;name: &#x27;若川&#x27;&#125;</span><br><span class="line">    // 相当于返回了</span><br><span class="line">    // return this;</span><br><span class="line">&#125;</span><br><span class="line">var result = new Student(&#x27;若川&#x27;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>使用<code>new</code>操作符调用函数，会自动执行以下步骤。</p>
<blockquote>
<ol>
<li>创建了一个全新的对象。</li>
<li>这个对象会被执行<code>[[Prototype]]</code>（也就是<code>__proto__</code>）链接。</li>
<li>生成的新对象会绑定到函数调用的<code>this</code>。</li>
<li>通过<code>new</code>创建的每个对象将最终被<code>[[Prototype]]</code>链接到这个函数的<code>prototype</code>对象上。</li>
<li>如果函数没有返回对象类型<code>Object</code>(包含<code>Functoin</code>, <code>Array</code>, <code>Date</code>, <code>RegExg</code>, <code>Error</code>)，那么<code>new</code>表达式中的函数调用会自动返回这个新的对象。</li>
</ol>
</blockquote>
<p>由此可以知道：<code>new</code>操作符调用时，<code>this</code>指向生成的新对象。 <strong>特别提醒一下，<code>new</code>调用时的返回值，如果没有显式返回对象或者函数，才是返回生成的新对象</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Student(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    // return function f()&#123;&#125;;</span><br><span class="line">    // return &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">var result = new Student(&#x27;若川&#x27;);</span><br><span class="line">console.log(result); &#123;name: &#x27;若川&#x27;&#125;</span><br><span class="line">// 如果返回函数f，则result是函数f，如果是对象&#123;&#125;，则result是对象&#123;&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>很多人或者文章都忽略了这一点，直接简单用<code>typeof</code>判断对象。虽然实际使用时不会显示返回，但面试官会问到。</p>
<hr>
<p><strong>总结</strong></p>
<p>如果要判断一个运行中的函数的this绑定，就需要找到这个函数的直接调用位置.找到之后就可以顺序应用下面这四条规则来判断this的指向</p>
<ol>
<li><strong>普通函数调用</strong>:在严格模式下绑定到<code>undefined</code>,否则绑定到全局对象</li>
<li><strong>构造函数形式调用</strong>:绑定到新创建的实例对象</li>
<li><strong>对象上的函数调用</strong>:帮到到那个对象</li>
<li><strong>call、apply、bind调用</strong>:在非严格模式下,this为函数传入的第一个参数,如果第一个参数为<code>null</code>或者<code>undefined</code>，<code>this</code>会指向全局对象(浏览器中就是window对象)</li>
</ol>
<p><strong>箭头函数的this</strong>:不会使用上文的四条标准的绑定规则,而是<strong>根据当前的词法作用域来决定this。</strong></p>
<p>箭头函数没有自己的this、super、argument和new.target绑定,所以<strong>必须通过查找作用域链来决定其值</strong>.<strong>如果箭头函数被非箭头函数包含,则this绑定的是最近一层非箭头函数的this,否则this的值会被设置位全局对象.</strong></p>
<hr>
<h4 id="2-call"><a href="#2-call" class="headerlink" title="2.call"></a>2.call</h4><blockquote>
<p>call()方法的作用是在使用<strong>一个指定的this值</strong>和<strong>若干个指定的参数值</strong>的前提下调用某个函数或方法</p>
</blockquote>
<p>举个栗子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>手写实现call方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.ts_call(obj,...args)&#123;</span><br><span class="line">    obj = obj || <span class="built_in">window</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(); <span class="comment">//创建一个唯一变量,防止属性名冲突</span></span><br><span class="line">    </span><br><span class="line">    obj[fn] = <span class="built_in">this</span>; <span class="comment">//将属性指定为目标函数</span></span><br><span class="line">    </span><br><span class="line">    obj[fn](...args);<span class="comment">//执行函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> obj[fn];<span class="comment">//执行后将这个属性删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我叫<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testobj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zzm&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">fn.cs_call(testobj2,<span class="number">18</span>)<span class="comment">//我叫zzm今年18岁了!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="3-apply"><a href="#3-apply" class="headerlink" title="3.apply"></a>3.apply</h4><blockquote>
<p>apply的方法与call类似,不同之处在于<strong>apply参数以数组的方式传递</strong>,所以call能实现的需求，用apply也同样可以</p>
</blockquote>
<p>手写实现apply方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.cs_apply(obj,arg)&#123;</span><br><span class="line">    obj = obj || <span class="built_in">window</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    </span><br><span class="line">    obj[fn] = <span class="built_in">this</span>;</span><br><span class="line">    </span><br><span class="line">    obj[fn](...args);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> obj[fn];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">age,hobby</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我叫<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>今年<span class="subst">$&#123;age&#125;</span>岁了我喜欢<span class="subst">$&#123;hobby&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> testobj2 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zzm&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">fn.cs_apply(testobj2,[<span class="number">18</span>,<span class="string">&#x27;睡觉&#x27;</span>])<span class="comment">//我叫zzm今年18岁了我喜欢睡觉</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-bind"><a href="#4-bind" class="headerlink" title="4.bind"></a>4.bind</h4><blockquote>
<p>bind()函数会创建一个新函数(称之为绑定函数)</p>
</blockquote>
<ul>
<li>bind是ES5新增的一个方法</li>
<li>传参和call或apply类似</li>
<li>不会执行对应的函数，call或apply会自动执行对应的函数</li>
<li>返回对函数的引用</li>
</ul>
<p><strong>下面例子：</strong>当点击网页时，<code>EventClick</code>被触发执行，输出<code>JSLite.io p1 p2</code>, 说明<code>EventClick</code>中的<code>this</code>被<code>bind</code>改变成了<code>obj</code>对象。如果你将<code>EventClick.bind(obj,&#39;p1&#39;,&#39;p2&#39;)</code> 变成 <code>EventClick.call(obj,&#39;p1&#39;,&#39;p2&#39;)</code> 的话，页面会直接输出 <code>JSLite.io p1 p2</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;name:&#x27;JSLite.io&#x27;&#125;;</span><br><span class="line">/**</span><br><span class="line"> * 给document添加click事件监听，并绑定EventClick函数</span><br><span class="line"> * 通过bind方法设置EventClick的this为obj，并传递参数p1,p2</span><br><span class="line"> */</span><br><span class="line">document.addEventListener(&#x27;click&#x27;,EventClick.bind(obj,&#x27;p1&#x27;,&#x27;p2&#x27;),false);</span><br><span class="line">//当点击网页时触发并执行</span><br><span class="line">function EventClick(a,b)&#123;</span><br><span class="line">    console.log(</span><br><span class="line">            this.name, //JSLite.io</span><br><span class="line">            a, //p1</span><br><span class="line">            b  //p2</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">// JSLite.io p1 p2</span><br></pre></td></tr></table></figure>



<p>手写bind</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.cs_bind = <span class="function"><span class="keyword">function</span>(<span class="params">obj,...args</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    obj = obj || <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    obj[fn] = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _this = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> res = <span class="function"><span class="keyword">function</span>(<span class="params">...innerArgs</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> <span class="keyword">instanceof</span> _this)&#123;<span class="comment">//当作构造函数使用</span></span><br><span class="line">            <span class="built_in">this</span>[fn] = _this;</span><br><span class="line">            <span class="built_in">this</span>[fn](...[...args,...innerArgs]);</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>[fn];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//没有当作构造函数使用</span></span><br><span class="line">            obj[fn](...[...args,...innerArgs])</span><br><span class="line">            <span class="keyword">delete</span> obj[fn];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.prototype = <span class="built_in">Object</span>.create(<span class="built_in">this</span>.prototype);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-原型-继承"><a href="#3-原型-继承" class="headerlink" title="3.原型/继承"></a>3.原型/继承</h3><h4 id="1-原型"><a href="#1-原型" class="headerlink" title="1.原型"></a>1.原型</h4><p><strong>原型链经典神图</strong></p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131611904.png" alt="image-20220313161148825"></p>
<ul>
<li>function Foo 就是一个方法，比如JavaScript 中内置的 Array、String 等</li>
<li>function Object 就是一个 Object</li>
<li>function Function 就是 Function</li>
<li>以上都是 function，所以 <code>.__proto__</code>都是<code>Function.prototype</code></li>
<li>再次强调，String、Array、Number、Function、Object都是 function</li>
</ul>
<hr>
<p><strong>prototype的定义</strong></p>
<p>在规范里,prototype被定义为:<strong>给其他对象提供共享属性的对象</strong></p>
<p>也就是说prototype自己也是对象,只是被用来承担某个只能罢了</p>
<p><strong>prototype描述的是两个对象之间的某种关系(其中一个对象为另一个对象提供属性访问权限).所有对象都可以作为另一个对象的prototype来使用</strong></p>
<hr>
<p><strong>函数对象和普通对象</strong></p>
<p>在JavaScript中,<strong>万物皆对象</strong>,但是不同的对象是存在着差异性的.</p>
<p>在JavaScript中，我们将对象分为函数对象和普通对象,<strong>函数对象就是JavaScript用函数来模拟的类实现</strong>,<strong>Object</strong>和<strong>Function</strong>就是典型的函数对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> fun3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;console.log(name)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">const</span> obj3 = <span class="keyword">new</span> fun1();</span><br><span class="line"><span class="keyword">const</span> obj4 = <span class="keyword">new</span> <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fun1);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fun2);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fun3);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj1);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj2);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj3);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj4);<span class="comment">//object</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>obj1</code>，<code>obj2</code>，<code>obj3</code>，<code>obj4</code>都是普通对象，<code>fun1</code>，<code>fun2</code>，<code>fun3</code> 都是 <code>Function</code> 的实例，也就是函数对象。</p>
<p>总结:<strong>所有的Function的实例都是函数对象,其他的均为普通对象,包括Function实例的实例</strong></p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131629020.webp" alt="img"></p>
<p><strong>JavaScript中万物皆对象,而对象皆出自构造函数</strong></p>
<p>对于<strong>Function</strong>对象:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<hr>
<p><strong>__ proto__</strong></p>
<p>首先我们需要明确:</p>
<ul>
<li><strong>__ proto__<strong>和</strong>constructor</strong>是<strong>对象</strong>独有的</li>
<li><strong>prototype</strong>属性是<strong>函数</strong>独有的</li>
</ul>
<p>但是在JavaScript中,函数也是一种特殊的对象,<strong>所以函数也拥有<code>__proto__</code>和 <code>constructor</code>属性</strong></p>
<p>结合上面我们介绍的 <code>Object</code> 和 <code>Function</code> 的关系，看一下代码和关系图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;…&#125;;</span><br><span class="line">let nealyang = new Person(); </span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131647800.webp" alt="__proto__"></p>
<p>再梳理上图关系之前，我们再来讲解下<code>__proto__</code>。</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131647353.webp" alt="img"></p>
<p>这里我们需要知道的是，<code>__proto__</code>是对象所独有的，并且<code>__proto__</code>是<strong>一个对象指向另一个对象</strong>，也就是他的原型对象。我们也可以理解为父类对象。它的作用就是当你在访问一个对象属性的时候，如果该对象内部不存在这个属性，那么就回去它的<code>__proto__</code>属性所指向的对象（父类对象）上查找，如果父类对象依旧不存在这个属性，那么就回去其父类的<code>__proto__</code>属性所指向的父类的父类上去查找。以此类推，知道找到 <code>null</code>。而这个查找的过程，也就构成了我们常说的<strong>原型链</strong>。</p>
<p><strong>原型链就是根据对象的__ proto __指向,一层一层连接起来的具有关联性的对象集合</strong></p>
<hr>
<p><strong>prototype</strong></p>
<p>prototype 被定义为：<strong>给其它对象提供共享属性的对象</strong>。<code>prototype</code> 自己也是对象，只是被用以承担某个职能罢了</p>
<p>所有对象都可以作为另一个对象的<strong>prototype</strong>使用</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131651653.webp" alt="img"></p>
<p><strong>任何函数在创建的时候，都会默认给该函数添加 <code>prototype</code> 属性.</strong></p>
<hr>
<p><strong>constructor</strong></p>
<p><strong>constructor</strong>属性也是对象所独有的,<strong>他是一个对象指向同一个函数，这个函数就是该对象的构造函数</strong></p>
<p>每个对象都有其对应的构造函数,它由本身或者继承而来.</p>
<p><strong>函数.prototype.constructor</strong>===<strong>该函数本身</strong></p>
<p><strong>constructor属性只有prototype对象才有</strong>,函数在创建的时候,JavaScript会同时创建一个该函数对应的prototype对象,<strong>而函数创建的对象.proto === 该函数.prototype</strong></p>
<p>通过函数创建的对象即使自己没有<code>constructor</code>属性，它也能通过<code>__proto__</code>找到对应的<code>constructor</code>，所以<strong>任何对象最终都可以找到其对应的构造函数。</strong></p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131707239.webp" alt="img"></p>
<hr>
<p><strong>原型链</strong></p>
<p><strong>原型链就是根据对象的__ proto __指向,一层一层连接起来的具有关联性的对象集合</strong></p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131709481.webp" alt="img"></p>
<hr>
<p><strong>typeof</strong>&amp;&amp;<strong>instanceof</strong>原理</p>
<p><strong>typeof</strong></p>
<p>用于判断变量的类型,可以判断的类型有:<strong>number</strong>、<strong>undefined</strong>、<strong>String</strong>、<strong>Boolean</strong>、<strong>function</strong>、<strong>object</strong>、<strong>symbol</strong>，但是<strong>typeof在判断object时不能明确的告诉你属于哪一类object</strong></p>
<p>所以<strong>一般不用typeof来判断object的类型</strong></p>
<p>为什么<strong>typeof null</strong> 返回’<strong>object</strong>’？</p>
<p><strong>因为null代表的是空指针对象,所以typeof null 为object</strong></p>
<p>具体原因:在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 <code>null</code> 代表的是空指针（大多数平台下值为 0x00），因此，<code>null</code> 的类型标签是 0，<code>typeof null</code> 也因此返回 <code>&quot;object&quot;</code></p>
<hr>
<p><strong>instanceof</strong></p>
<p><code>instanceof</code> 运算符用来检测 <code>constructor.prototype</code> 是否存在于参数 <code>object</code> 的原型链上。与 <code>typeof</code> 方法不同的是，<code>instanceof</code> 方法要求开发者明确地确认对象为某特定类型。</p>
<p><strong>instanceof</strong>可以判断<strong>一个实例是否是其父类型或者祖先类型的实例。</strong></p>
<p><strong>instanceof</strong>是如何进行判断的?</p>
<ul>
<li>表达式**:A instanceof B**:如果B的显式原型(prototype)对象在A的原型链上,返回true,否则返回false</li>
</ul>
<p><strong>手写instanceof</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_instanceof</span>(<span class="params">child,father</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fp =  father.prototype   </span><br><span class="line">    <span class="keyword">let</span> cp = child.__proto__</span><br><span class="line">    <span class="keyword">while</span>(cp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cp.__proto__ === father.protype)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cp = cp.__proto__;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);<span class="comment">//false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);<span class="comment">//false </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Foo <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">//true </span></span><br><span class="line"><span class="built_in">console</span>.log(Foo <span class="keyword">instanceof</span> Foo);<span class="comment">//false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>为什么 <code>Object</code> 和 <code>Function</code> <code>instanceof</code> 自己等于 <code>true</code>，而其他类 <code>instanceof</code> 自己却又不等于 <code>true</code> 呢？如何解释？</strong></p>
<ul>
<li><p><code>Object instanceof Object</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了方便表述，首先区分左侧表达式和右侧表达式</span></span><br><span class="line">ObjectL = <span class="built_in">Object</span>, ObjectR = <span class="built_in">Object</span>; </span><br><span class="line"><span class="comment">// 下面根据规范逐步推演</span></span><br><span class="line">O = ObjectR.prototype = <span class="built_in">Object</span>.prototype </span><br><span class="line">L = ObjectL.__proto__ = <span class="built_in">Function</span>.prototype </span><br><span class="line"><span class="comment">// 第一次判断</span></span><br><span class="line">O != L </span><br><span class="line"><span class="comment">// 循环查找 L 是否还有 __proto__ </span></span><br><span class="line">L = <span class="built_in">Function</span>.prototype.__proto__ = <span class="built_in">Object</span>.prototype </span><br><span class="line"><span class="comment">// 第二次判断</span></span><br><span class="line">O == L </span><br><span class="line"><span class="comment">// 返回 true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>Function instanceof Function</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了方便表述，首先区分左侧表达式和右侧表达式</span></span><br><span class="line">FunctionL = <span class="built_in">Function</span>, FunctionR = <span class="built_in">Function</span>; </span><br><span class="line"><span class="comment">// 下面根据规范逐步推演</span></span><br><span class="line">O = FunctionR.prototype = <span class="built_in">Function</span>.prototype </span><br><span class="line">L = FunctionL.__proto__ = <span class="built_in">Function</span>.prototype </span><br><span class="line"><span class="comment">// 第一次判断</span></span><br><span class="line">O == L </span><br><span class="line"><span class="comment">// 返回 true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>Foo instanceof Foo</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了方便表述，首先区分左侧表达式和右侧表达式</span></span><br><span class="line">FooL = Foo, FooR = Foo; </span><br><span class="line"><span class="comment">// 下面根据规范逐步推演</span></span><br><span class="line">O = FooR.prototype = Foo.prototype </span><br><span class="line">L = FooL.__proto__ = <span class="built_in">Function</span>.prototype </span><br><span class="line"><span class="comment">// 第一次判断</span></span><br><span class="line">O != L </span><br><span class="line"><span class="comment">// 循环再次查找 L 是否还有 __proto__ </span></span><br><span class="line">L = <span class="built_in">Function</span>.prototype.__proto__ = <span class="built_in">Object</span>.prototype </span><br><span class="line"><span class="comment">// 第二次判断</span></span><br><span class="line">O != L </span><br><span class="line"><span class="comment">// 再次循环查找 L 是否还有 __proto__ </span></span><br><span class="line">L = <span class="built_in">Object</span>.prototype.__proto__ = <span class="literal">null</span> </span><br><span class="line"><span class="comment">// 第三次判断</span></span><br><span class="line">L == <span class="literal">null</span> </span><br><span class="line"><span class="comment">// 返回 false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<hr>
<h4 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h4><p>在JavaScript中,有两类原型继承的方式:<strong>显式继承</strong>和<strong>隐式继承</strong></p>
<hr>
<h5 id="new"><a href="#new" class="headerlink" title="new"></a><strong>new</strong></h5><p><strong>new用来创建构造函数的实例对象</strong></p>
<p><strong>手写new</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">fn,...args</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    obj.__proto__ = fn.prototype;<span class="comment">//将obj的__proto__赋值为fn的prototype</span></span><br><span class="line">    fn.apply(obj,args);<span class="comment">//将构造函数的this指向这个对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h5 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a><strong>类式继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.superValue = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.superValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subValue = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line"></span><br><span class="line">SubClass.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.subValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> SubClass();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( instance  <span class="keyword">instanceof</span> SuperClass);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log( instance  <span class="keyword">instanceof</span> SubClass);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(SubClass <span class="keyword">instanceof</span> SuperClass);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>虽然实现起来清晰简洁，但是这种继承方式有两个缺点：</p>
<ul>
<li>由于子类通过其原型prototype对父类实例化，继承了父类，所以说父类中如果共有属性是引用类型，就会在子类中被所有的实例所共享，因此一个子类的实例更改子类原型从父类构造函数中继承的共有属性就会直接影响到其他的子类</li>
<li>由于子类实现的继承是靠其原型prototype对父类进行实例化实现的，因此在创建父类的时候，是无法向父类传递参数的。因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化</li>
</ul>
<hr>
<h5 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a><strong>构造函数继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.books = [<span class="string">&#x27;js&#x27;</span>,<span class="string">&#x27;css&#x27;</span>];</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.showBooks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.books);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    SuperClass.call(<span class="built_in">this</span>,id)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> SubClass(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="keyword">new</span> SubClass(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">instance1.books.push(<span class="string">&#x27;html&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1)</span><br><span class="line"><span class="built_in">console</span>.log(instance2)</span><br><span class="line">instance1.showBooks();<span class="comment">//TypeError</span></span><br></pre></td></tr></table></figure>

<p><code>SuperClass.call(this,id)</code>当然就是构造函数继承的核心语句了.由于父类中给this绑定属性，因此子类自然也就继承父类的共有属性。由于这种类型的继承没有涉及到原型<code>prototype</code>，所以父类的原型方法自然不会被子类继承，而如果想被子类继承，就必须放到构造函数中，这样创建出来的每一个实例都会单独的拥有一份而不能共用，这样就违背了代码复用的原则，所以综合上述两种，我们提出了组合式继承方法</p>
<hr>
<h5 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a><strong>组合式继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name; </span><br><span class="line">  <span class="built_in">this</span>.books = [<span class="string">&#x27;Js&#x27;</span>,<span class="string">&#x27;CSS&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.getBooks = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.books);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name,time</span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="built_in">this</span>,name);</span><br><span class="line">  <span class="built_in">this</span>.time = time;</span><br><span class="line">&#125;</span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass();</span><br><span class="line"></span><br><span class="line">SubClass.prototype.getTime = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，我们就解决了之前说到的一些问题，但是是不是从代码看，还是有些不爽呢？至少这个<code>SuperClass</code>的构造函数执行了两遍就感觉非常的不妥.</p>
<h5 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a><strong>原型式继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//声明一个过渡对象</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">  <span class="comment">//过渡对象的原型继承父对象</span></span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="comment">//返回过渡对象的实例，该对象的原型继承了父对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原型式继承大致的实现方式如上，是不是想到了我们<code>new</code>关键字模拟的实现？</p>
<p>其实这种方式和类式继承非常的相似，他只是对类式继承的一个封装，其中的过渡对象就相当于类式继承的子类，只不过在原型继承中作为一个普通的过渡对象存在，目的是为了创建要返回的新的实例对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">    name:&#x27;js book&#x27;,</span><br><span class="line">    likeBook:[&#x27;css Book&#x27;,&#x27;html book&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">var newBook = inheritObject(book);</span><br><span class="line">newBook.name = &#x27;ajax book&#x27;;</span><br><span class="line">newBook.likeBook.push(&#x27;react book&#x27;);</span><br><span class="line">var otherBook = inheritObject(book);</span><br><span class="line">otherBook.name = &#x27;canvas book&#x27;;</span><br><span class="line">otherBook.likeBook.push(&#x27;node book&#x27;);</span><br><span class="line">console.log(newBook,otherBook);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如上代码我们可以看出，原型式继承和类式继承一个样子，对于引用类型的变量，还是存在子类实例共享的情况。</p>
<p>所以，我们还有下面的寄生式继承</p>
<hr>
<h5 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a><strong>寄生式继承</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;    <span class="attr">name</span>:<span class="string">&#x27;js book&#x27;</span>,    <span class="attr">likeBook</span>:[<span class="string">&#x27;html book&#x27;</span>,<span class="string">&#x27;css book&#x27;</span>]&#125;<span class="function"><span class="keyword">function</span> <span class="title">createBook</span>(<span class="params">obj</span>) </span>&#123;    <span class="comment">//通过原型方式创建新的对象  var o = new inheritObject(obj);  // 拓展新对象  o.getName = function(name) &#123;    console.log(name)  &#125;  // 返回拓展后的新对象  return o;&#125;</span></span><br></pre></td></tr></table></figure>

<p>其实寄生式继承就是对原型继承的拓展，一个二次封装的过程，这样新创建的对象不仅仅有父类的属性和方法，还新增了别的属性和方法。</p>
<h5 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a><strong>寄生组合式继承</strong></h5><p>回到之前的组合式继承，那时候我们将类式继承和构造函数继承组合使用，但是存在的问题就是子类不是父类的实例，而子类的原型是父类的实例，所以才有了寄生组合式继承</p>
<p>而寄生组合式继承是寄生式继承和构造函数继承的组合。但是这里寄生式继承有些特殊，这里他处理不是对象，而是类的原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritObject</span>(<span class="params">o</span>) </span>&#123;  <span class="comment">//声明一个过渡对象  function F() &#123; &#125;  //过渡对象的原型继承父对象  F.prototype = o;  //返回过渡对象的实例，该对象的原型继承了父对象  return new F();&#125;function inheritPrototype(subClass,superClass) &#123;    // 复制一份父类的原型副本到变量中  var p = inheritObject(superClass.prototype);  // 修正因为重写子类的原型导致子类的constructor属性被修改  p.constructor = subClass;  // 设置子类原型  subClass.prototype = p;&#125;</span></span><br></pre></td></tr></table></figure>

<p>组合式继承中，通过构造函数继承的属性和方法都是没有问题的，所以这里我们主要探究通过寄生式继承重新继承父类的原型。</p>
<p>我们需要继承的仅仅是父类的原型，不用去调用父类的构造函数。换句话说，在构造函数继承中，我们已经调用了父类的构造函数。因此我们需要的就是父类的原型对象的一个副本，而这个副本我们可以通过原型继承拿到，但是这么直接赋值给子类会有问题，因为对父类原型对象复制得到的复制对象p中的<code>constructor</code>属性指向的不是<code>subClass</code>子类对象，因此在寄生式继承中要对复制对象p做一次增强，修复起<code>constructor</code>属性指向性不正确的问题，最后将得到的复制对象p赋值给子类原型，这样子类的原型就继承了父类的原型并且没有执行父类的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;  <span class="built_in">this</span>.name = name;  <span class="built_in">this</span>.books=[<span class="string">&#x27;js book&#x27;</span>,<span class="string">&#x27;css book&#x27;</span>];&#125;SuperClass.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);&#125;<span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name,time</span>) </span>&#123;  SuperClass.call(<span class="built_in">this</span>,name);  <span class="built_in">this</span>.time = time;&#125;inheritPrototype(SubClass,SuperClass);SubClass.prototype.getTime = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="built_in">this</span>.time);&#125;<span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubClass(<span class="string">&#x27;React&#x27;</span>,<span class="string">&#x27;2017/11/11&#x27;</span>)<span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubClass(<span class="string">&#x27;Js&#x27;</span>,<span class="string">&#x27;2018/22/33&#x27;</span>);instance1.books.push(<span class="string">&#x27;test book&#x27;</span>);<span class="built_in">console</span>.log(instance1.books,instance2.books);instance2.getName();instance2.getTime();</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203131828871.webp" alt="img"></p>
<p>这种方式继承其实如上图所示，其中最大的改变就是子类原型中的处理，被赋予父类原型中的一个引用，这是一个对象，因此有一点你需要注意，就是子类在想添加原型方法必须通过prototype.来添加，否则直接赋予对象就会覆盖从父类原型继承的对象了.</p>
<h3 id="4-promise"><a href="#4-promise" class="headerlink" title="4.promise"></a>4.promise</h3><h4 id="1-什么是promise-它用来解决什么问题"><a href="#1-什么是promise-它用来解决什么问题" class="headerlink" title="1.什么是promise?它用来解决什么问题?"></a>1.<strong>什么是promise?它用来解决什么问题?</strong></h4><blockquote>
<p>Promise是异步编程的一种解决方案:从语法上讲，promise是一个对象,可以通过它获取异步操作的消息；从本意上讲，他是承诺，承诺他过一段时间会给你一个结果。promise有三种状态:<strong>pending</strong>(等待态)，<strong>fulfiled</strong>(成功态),<strong>rejected</strong>(失败态);<strong>状态一旦改变，就不会再改变</strong>(也就是说promise的操作是不可逆的)，<strong>创造promise实例后，他会立即执行</strong></p>
</blockquote>
<p>promise是用来解决两个问题:</p>
<ul>
<li><strong>回调地狱</strong>，减少多层回调嵌套</li>
<li><strong>异步执行</strong>(但是不能说promise是异步的)</li>
</ul>
<hr>
<h4 id="2-promise用法"><a href="#2-promise用法" class="headerlink" title="2.promise用法"></a>2.<strong>promise用法</strong></h4><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132032800.png" alt="image-20220313203224725"></p>
<h5 id="创建promise对象"><a href="#创建promise对象" class="headerlink" title="创建promise对象"></a><strong>创建promise对象</strong></h5><p>promise是一个<strong>构造函数</strong>，可以通过<strong>new</strong>来创建实例对象</p>
<p>Promise的构造函数接收<strong>一个参数</strong>:函数,并且这个函数需要传入<strong>两个参数</strong>:</p>
<ul>
<li><strong>resolve</strong>:异步操作执行成功后的回调函数</li>
<li><strong>reject</strong>:异步操作执行失败后的回调函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;    <span class="comment">//做一些异步操作    setTimeout(() =&gt; &#123;        console.log(&#x27;执行完成&#x27;);        resolve(&#x27;我是成功！！&#x27;);    &#125;, 2000);&#125;);</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="then链式调用"><a href="#then链式调用" class="headerlink" title="then链式调用"></a><strong>then链式调用</strong></h5><p>promise可以通过链式调用来减少多层回调嵌套</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,rehect</span>) =&gt;</span>&#123;     resolve(<span class="string">&#x27;ok&#x27;</span>);          &#125;);p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(data);&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(data);&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(data);&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="reject的用法"><a href="#reject的用法" class="headerlink" title="reject的用法"></a><strong>reject的用法</strong></h5><p>把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;        <span class="comment">//做一些异步操作      setTimeout(function()&#123;            var num = Math.ceil(Math.random()*10); //生成1-10的随机数            if(num&lt;=5)&#123;                resolve(num);            &#125;            else&#123;                reject(&#x27;数字太大了&#x27;);            &#125;      &#125;, 2000);    &#125;);    p.then((data) =&gt; &#123;            console.log(&#x27;resolved&#x27;,data);        &#125;,(err) =&gt; &#123;            console.log(&#x27;rejected&#x27;,err);        &#125;    ); </span></span><br></pre></td></tr></table></figure>



<p>then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132043346.webp" alt="img">或者<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/19/16377e4fd8619228~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p>
<hr>
<h5 id="catch的用法"><a href="#catch的用法" class="headerlink" title="catch的用法"></a><strong>catch的用法</strong></h5><p>catch的作用与then的第二个参数类似,用于捕获失败的回调,不过与后者不同的是，在链式调用时，如果代码出错了，他不会报错使js执行停止，而是会进入到catch方法中,并捕获到异常</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>,data);    <span class="built_in">console</span>.log(somedata); <span class="comment">//此处的somedata未定义&#125;).catch((err) =&gt; &#123;    console.log(&#x27;rejected&#x27;,err);&#125;);</span></span><br></pre></td></tr></table></figure>

<p>在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203132046474.webp" alt="img"></p>
<p>也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能</p>
<hr>
<h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a><strong>Promise.all()</strong></h5><p><strong>用法</strong>:接受一个<strong>数组</strong>参数，里面的值最终都返回Promise对象</p>
<p><strong>特点</strong>:谁执行<strong>慢</strong>,以谁为准执行回调</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;&#125;)<span class="keyword">let</span> Promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;&#125;)<span class="keyword">let</span> Promise3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;&#125;)<span class="keyword">let</span> p = <span class="built_in">Promise</span>.all([Promise1, Promise2, Promise3])p.then(<span class="function"><span class="title">funciton</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 三个都成功则成功  &#125;, function()&#123;  // 只要有失败，则失败 &#125;)</span></span><br></pre></td></tr></table></figure>

<p>应用场景:<em>一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。</em></p>
<hr>
<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a><strong>Promise.race()</strong></h5><p><strong>用法</strong>:接受一个数组参数,里面的值最终都返回Promise对象</p>
<p><strong>特点</strong>:谁执行<strong>快</strong>，以谁为准执行回调</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;    <span class="comment">// resolve(1);    reject(1);&#125;)const promise2 = new Promise(function(resolve, reject) &#123;    resolve(2);&#125;)const promise3 = new Promise(function(resolve, reject) &#123;    resolve(3);&#125;)const p = Promise.race([promise1,promise2,promise3])p.then((data) =&gt; &#123;    console.log(&quot;data&quot;,data);&#125;).catch((err) =&gt; &#123;    console.log(&quot;err&quot;,err);&#125;)</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a><strong>Promise.any()</strong></h5><p><strong>注意</strong>:<strong>Promise.any()尚未被所有浏览器所支持</strong>,node环境下不能使用这个API</p>
<p><strong>用法</strong>:接受一个数组参数,里面的值最终都返回Promise对象</p>
<p><strong>特点</strong>:只要有一个promise执行成功,那么就返回那个成功的promise</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;    <span class="comment">// resolve(1);    reject(1);&#125;)const promise2 = new Promise(function(resolve, reject) &#123;    resolve(2);&#125;)const promise3 = new Promise(function(resolve, reject) &#123;    resolve(3);&#125;)const p = Promise.any([promise1,promise2,promise3])p.then((data) =&gt; &#123;    console.log(&quot;data&quot;,data);&#125;).catch((err) =&gt; &#123;    console.log(&quot;err&quot;,err);&#125;)</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-async-await"><a href="#3-async-await" class="headerlink" title="3.async/await"></a>3.<strong>async/await</strong></h4><h5 id="1-什么是async"><a href="#1-什么是async" class="headerlink" title="1.什么是async?"></a>1.什么是async?</h5><p><strong>介绍</strong>:async函数是使用<code>async</code>关键字声明的函数。 async函数是<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction"><code>AsyncFunction</code></a>构造函数的实例， 并且其中允许使用<code>await</code>关键字。<code>async</code>和<code>await</code>关键字让我们可以用一种更简洁的方式写出基于<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>的异步行为，而无需刻意地链式调用<code>promise</code>。</p>
<p><strong>特性</strong>:async函数可能包含0个或者多个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await"><code>await</code></a>表达式。await表达式会暂停整个async函数的执行进程并出让其控制权，只有当其等待的基于promise的异步操作被兑现或被拒绝之后才会恢复进程。promise的解决值会被当作该await表达式的返回值。使用<code>async</code> / <code>await</code>关键字就可以在异步代码中使用普通的<code>try</code> / <code>catch</code>代码块。</p>
<p><code>async</code> 函数是 <code>Generator</code> 函数的语法糖。使用 关键字 <code>async</code> 来表示，在函数内部使用 <code>await</code> 来表示异步。相较于 <code>Generator</code>，<code>async</code> 函数的改进在于下面四点：</p>
<ul>
<li><strong>内置执行器</strong>。<code>Generator</code> 函数的执行必须依靠执行器，而 <code>async</code> 函数自带执行器，调用方式跟普通函数的调用一样</li>
<li><strong>更好的语义</strong>。<code>async</code> 和 <code>await</code> 相较于 <code>*</code> 和 <code>yield</code> 更加语义化</li>
<li><strong>更广的适用性</strong>。<code>co</code> 模块约定，<code>yield</code> 命令后面只能是 Thunk 函数或 Promise对象。而 <code>async</code> 函数的 <code>await</code> 命令后面则可以是 Promise 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作）</li>
<li><strong>返回值是 Promise</strong>。<code>async</code> 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 <code>then()</code> 方法进行调用</li>
</ul>
<p><code>async</code>是ES7新出的特性，表明当前函数是异步函数，不会阻塞线程导致后续代码停止运行。</p>
<hr>
<h5 id="2-async函数怎么用"><a href="#2-async函数怎么用" class="headerlink" title="2.async函数怎么用?"></a>2.async函数怎么用?</h5><p><strong>async</strong>用来声明函数是一个异步函数</p>
<p><strong>await</strong>表示紧跟在后面的表达式需要等待结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span>(<span class="params"></span>)</span>&#123;    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;&#125;asuncFn();</span><br></pre></td></tr></table></figure>



<p><strong>async</strong>函数返回的是一个<strong>promise</strong>对象,状态为<strong>resolved</strong>,参数是<strong>return</strong>的值,所以async函数可以链式调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">return</span> <span class="string">&#x27;我后执行&#x27;</span>&#125;asyncFn().then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;    <span class="built_in">console</span>.log(result);<span class="comment">//我后执行&#125;)console.log(&#x27;我先执行&#x27;);</span></span><br></pre></td></tr></table></figure>



<p><strong>async</strong>函数返回的是一个promise对象，如果再执行过程中函数<strong>内部抛出异常</strong>或者返回<strong>reject</strong>，都会是的函数的promise状态变为失败<strong>rejected</strong>，函数抛出异常后，可以通过<strong>catch</strong>接收到返回的错误信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">return</span>  <span class="built_in">Promise</span>.reject(<span class="string">&#x27;reason&#x27;</span>)    <span class="comment">// throw new Error(&#x27;has error&#x27;)&#125;asyncFn().then(result =&gt; &#123;    console.log(result);&#125;,reason =&gt; &#123;    console.log(reason);&#125;).catch(err =&gt; &#123;    console.log(err);&#125;)console.log(&#x27;我先执行&#x27;);</span></span><br></pre></td></tr></table></figure>

<p>async函数接收到的返回值,如果不是<strong>异常</strong>或者<strong>reject</strong>，则判定成功,即<strong>resolve</strong></p>
<p>以下结果会使async函数判定<strong>失败</strong>:</p>
<ul>
<li>内部含有直接使用并且未声明的变量或者函数。</li>
<li>内部抛出一个错误<code>throw new Error</code>或者返回<code>reject</code>状态<code>return Promise.reject(&#39;执行失败&#39;)</code></li>
<li>函数方法执行出错（🌰：Object使用push()）等等…</li>
</ul>
<p>async函数如果需要返回结果,都必须使用<strong>return</strong>来返回,不论是<strong>reject</strong>还是<strong>resolve</strong>都需要使用return，不然就会返回一个值为<strong>undefined</strong> 的<strong>resolved</strong>(成功)状态</p>
<hr>
<h5 id="3-await是什么"><a href="#3-await是什么" class="headerlink" title="3.await是什么"></a>3.await是什么</h5><p><strong>await</strong>的意思是<strong>async wait</strong>(异步等待),<strong>await必须配合async使用</strong>，<strong>async函数必须等到内部所有的await命令的promise执行完,才会返回结果</strong></p>
<p><strong>打个比方，await是学生，async是校车，必须等人齐了再开车。</strong></p>
<p>就是说，必须等所有<code>await</code> 函数执行完毕后，才会告诉<code>promise</code>我成功了还是失败了，执行<code>then</code>或者<code>catch</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async function awaitReturn() &#123;         return await 1&#125;;awaitReturn().then(success =&gt; console.log(&#x27;成功&#x27;, success))             .catch(error =&gt; console.log(&#x27;失败&#x27;,error))</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203141014457.webp" alt="img"></p>
<p>async中的await会返回一个<strong>promise</strong>,<strong>下一个await必须等待上一个await返回promise结果状态才会开始执行</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> time1;<span class="keyword">let</span> time2;<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;    time1 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();    <span class="built_in">console</span>.log(<span class="string">&quot;第一个函数执行完毕&quot;</span>);&#125;, <span class="number">1000</span>);<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;    time2 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();    <span class="built_in">console</span>.log(<span class="string">&quot;第二个函数执行完毕&quot;</span>,time2-time1);&#125;, <span class="number">2000</span>);<span class="keyword">const</span> timeoutFn = <span class="function"><span class="keyword">function</span>(<span class="params">timeout</span>)</span>&#123; 	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;		<span class="keyword">return</span> <span class="built_in">setTimeout</span>(resolve, timeout);    &#125;);&#125;<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeOut</span>(<span class="params"></span>) </span>&#123;    <span class="keyword">await</span> timeoutFn(<span class="number">1000</span>);    <span class="keyword">await</span> timeoutFn(<span class="number">2000</span>);    <span class="built_in">console</span>.log(<span class="string">&quot;完成&quot;</span>);&#125;timeOut()</span><br></pre></td></tr></table></figure>

<p>不考虑<strong>event loop</strong>(事件循环)</p>
<p>上面的例子中 两个<strong>setTimeout</strong>函数会在<strong>2s</strong>左右(之所以说左右这个词,是因为函数执行会消耗几毫秒时间)，</p>
<p>而<strong>timeOut</strong>函数则需要<strong>3s</strong>左右的时间才会执行完成,这也说明了下一个<strong>await</strong>必须等待上一个<strong>await</strong>返回promise结果状态才会开始执行的结论是正确的</p>
<hr>
<p><strong>await后面的表达式应该返回一个promise，如果不是promise，js内部也会将其转换为一个resolved状态的 promise</strong></p>
<h3 id="5-深浅拷贝"><a href="#5-深浅拷贝" class="headerlink" title="5.深浅拷贝"></a>5.深浅拷贝</h3><p>JavaScript的数据类型分为<strong>基本数据类型</strong>和<strong>引用数据类型</strong>。</p>
<p>对于<strong>基本数据类型</strong>的拷贝，并没有深浅拷贝的区别，我们所说的<strong>深浅拷贝都是对于引用数据类型而言的</strong>。</p>
<h4 id="什么是浅拷贝"><a href="#什么是浅拷贝" class="headerlink" title="什么是浅拷贝?"></a>什么是浅拷贝?</h4><p>浅拷贝的意思就是只复制引用，而未复制真正的值。</p>
<p>当我们浅拷贝一个数组或者对象后，改变这个新的数组或对象,那么被我们拷贝的数组和对象也会改变</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];<span class="comment">//数组是引用类型const originObj = &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;//对象是引用类型let originType = [1,2,3];let originNumber = 1; //基本值类型,不存在深浅拷贝之分const clonedArray = originArray;const clonedObj = originObj;let cloneNumber = originNumber;let cloneType = originType;clonedArray.push(6);clonedObj.a = &#x27;aa&#x27;;cloneNumber = 2;cloneType = &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,b:&#x27;c&#x27;&#125;console.log(originArray);//[ 1, 2, 3, 4, 5, 6 ]console.log(originObj);//&#123; a: &#x27;aa&#x27;, b: &#x27;b&#x27;, c: [ 1, 2, 3 ], d: &#123; dd: &#x27;dd&#x27; &#125; &#125;console.log(originNumber);//1console.log(originType);//当我们改变了变量引用的类型时,这个新变量和被拷贝的变量就没有了任何联系(二者指向不同引用)</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="什么是深拷贝？"><a href="#什么是深拷贝？" class="headerlink" title="什么是深拷贝？"></a>什么是深拷贝？</h4><p>深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。</p>
<p><strong>只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。</strong></p>
<p>目前实现深拷贝的方法不多，主要是两种：</p>
<ol>
<li>利用 <code>JSON</code> 对象中的 <code>parse</code> 和 <code>stringify</code></li>
<li>利用递归来实现每一层都重新创建对象并赋值</li>
</ol>
<hr>
<p><strong>利用JSON.stringify/parse的方法实现深拷贝</strong></p>
<p>JSON.stringify的作用是<strong>将一个javascript值转换成json字符串</strong></p>
<p>JSON.parse的作用是<strong>将一个JSON字符串转换成javascript值或对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];<span class="keyword">const</span> cloneArray = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(originArray));<span class="built_in">console</span>.log(cloneArray === originArray); <span class="comment">// falseconst originObj = &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;const cloneObj = JSON.parse(JSON.stringify(originObj));console.log(cloneObj === originObj); // falsecloneObj.a = &#x27;aa&#x27;;cloneObj.c = [1,1,1];cloneObj.d.dd = &#x27;doubled&#x27;;console.log(cloneObj); // &#123;a:&#x27;aa&#x27;,b:&#x27;b&#x27;,c:[1,1,1],d:&#123;dd:&#x27;doubled&#x27;&#125;&#125;;console.log(originObj); // &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子可以实现深拷贝,但是这种方式只能适用于一些简单的情况，因为<strong>在使用HSON.stringify()时，<code>undefined</code>、<code>function</code>、<code>symbol</code> 会在转换过程中被忽略。。</strong></p>
<p>如果对象中含有以上几种类型时，就不能用这个方法进行深拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originObj = &#123;  <span class="attr">name</span>:<span class="string">&#x27;axuebin&#x27;</span>,  <span class="attr">sayHello</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);  &#125;&#125;<span class="built_in">console</span>.log(originObj); <span class="comment">// &#123;name: &quot;axuebin&quot;, sayHello: ƒ&#125;const cloneObj = JSON.parse(JSON.stringify(originObj));console.log(cloneObj); // &#123;name: &quot;axuebin&quot;&#125;</span></span><br></pre></td></tr></table></figure>



<hr>
<p><strong>使用递归的方法实现深拷贝</strong></p>
<p>递归的思想就很简单了，就是对每一层的数据都实现一次 <code>创建对象-&gt;对象赋值</code> 的操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现深拷贝function  deepClone(source) &#123;    const targetObj = source.constructor === Array ? [] : &#123;&#125;; // 判断复制的目标是数组还是对象        for (const key in source) &#123;        if (source.hasOwnProperty(key)) &#123;                        if(source[key] &amp;&amp; typeof source[key] === &#x27;object&#x27;)&#123;//如果值是对象就递归                targetObj[key] = source[key].constructor === &#x27;Array&#x27; ? [] : &#123;&#125;;                deepClone(targetObj[key]);            &#125;else&#123;//如果不是就直接赋值                targetObj[key] = source[key];            &#125;                    &#125;    &#125;    return targetObj;&#125;const originObj = &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;const cloneObj = deepClone(originObj);console.log(cloneObj === originObj); // falsecloneObj.a = &#x27;aa&#x27;;cloneObj.c = [1,1,1];cloneObj.d.dd = &#x27;doubled&#x27;;console.log(cloneObj); // &#123;a:&#x27;aa&#x27;,b:&#x27;b&#x27;,c:[1,1,1],d:&#123;dd:&#x27;doubled&#x27;&#125;&#125;;console.log(originObj); // &#123;a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:&#123;dd:&#x27;dd&#x27;&#125;&#125;;const originObj2 = &#123;    name:&#x27;张振明&#x27;,    sayHello:function()&#123;      console.log(&#x27;Hello World&#x27;);    &#125;  &#125;  console.log(originObj2); // &#123;name: &quot;张振明&quot;, sayHello: ƒ&#125;  const cloneObj2 = deepClone(originObj2);  console.log(cloneObj2); // &#123;name: &quot;张振明&quot;, sayHello: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="JavaScript中的拷贝方法"><a href="#JavaScript中的拷贝方法" class="headerlink" title="JavaScript中的拷贝方法"></a>JavaScript中的拷贝方法</h4><p>JavaScript数组中有两个方法,<strong>concat</strong>和<strong>slice</strong>,他们都<strong>不会改变原数组</strong>，而是返回一个新数组</p>
<p>所以他们是可以实现对原数组的拷贝的,另外es6新增的<code>Object.assgn</code> 方法和 <code>...</code> 展开运算符也能实现对对象的拷贝</p>
<p>这里只说明结论,不解释详细过程</p>
<p><strong>concat</strong></p>
<p>该方法可以连接两个或者更多的数组，但是它不会修改已存在的数组，而是返回一个新数组。</p>
<p><strong>结论：<code>concat</code> 只是对数组的第一层进行深拷贝。</strong></p>
<hr>
<p><strong>slice</strong></p>
<p><strong>结论：<code>slice</code> 只是对数组的第一层进行深拷贝。</strong></p>
<hr>
<p><strong>Object.assign()</strong></p>
<p><strong>结论：<code>Object.assign()</code> 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值</strong></p>
<hr>
<p><strong>… 展开运算符</strong></p>
<p><strong>结论：<code>...</code> 实现的是对象第一层的深拷贝。后面的只是拷贝的引用值。</strong></p>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>赋值运算符 <code>=</code> 实现的是浅拷贝，只拷贝对象的引用值；</li>
<li>JavaScript 中数组和对象自带的拷贝方法都是“首层浅拷贝”；</li>
<li><code>JSON.stringify</code> 实现的是深拷贝，但是对目标对象有要求；</li>
<li>若想真正意义上的深拷贝，请递归。</li>
</ol>
<hr>
<hr>
<h3 id="6-event-loop-事件循环"><a href="#6-event-loop-事件循环" class="headerlink" title="6.event loop(事件循环)"></a>6.event loop(事件循环)</h3><p>在学习事件循环之前,我们应该明白:<strong>JavaScript本质上就是一个单线程语言,一切JavaScript的所谓“多线程”都是用单线程模拟出来的</strong></p>
<h4 id="什么是事件循环"><a href="#什么是事件循环" class="headerlink" title="什么是事件循环?"></a><strong>什么是事件循环?</strong></h4><p>因为js是单线程的,js的任务是按顺序一个一个执行的。但一个任务耗时过长,后面的任务将被阻塞,这是我们不想看到的。所以程序员将任务分为两类:</p>
<ul>
<li><strong>同步任务</strong></li>
<li><strong>异步任务</strong></li>
</ul>
<p><strong>任务执行机制:</strong></p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203141841788.webp" alt="img"></p>
<p>导图要表达的内容用文字来表述的话：</p>
<ul>
<li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入<strong>Event Table</strong>并注册函数。</li>
<li>当指定的事情完成时，<strong>Event Table</strong>会将这个函数移入<strong>Event Queue</strong>。</li>
<li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li>
<li>上述过程会不断重复，也就是常说的<strong>Event Loop</strong>(事件循环)。</li>
</ul>
<hr>
<h4 id="事件循环的一些举例"><a href="#事件循环的一些举例" class="headerlink" title="事件循环的一些举例"></a>事件循环的一些举例</h4><h5 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a><strong>setTimeout</strong></h5><p>setTimeout表示执行一个延时函数,他的特点是可以异步延时执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;延时3秒&#x27;</span>);&#125;,<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<p>但是在有些情况下,延时并不准确</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;    task()&#125;,<span class="number">3000</span>)sleep(<span class="number">10000000</span>)<span class="comment">//消耗很多的时间</span></span><br></pre></td></tr></table></figure>



<p>上例中,sleep()函数是一个<strong>同步任务</strong>,他直接在主线程中执行,而setTimeout是个<strong>异步任务</strong>,在任务执行过程中，task()执行的时间却远远大于3s,这时候延时并不准确,这是什么原因?</p>
<ul>
<li><code>task()</code>进入Event Table并注册,计时开始。</li>
<li>执行<code>sleep</code>函数，很慢，非常慢，计时仍在继续。</li>
<li>3秒到了，计时事件<code>timeout</code>完成，<code>task()</code>进入Event Queue，但是<code>sleep</code>也太慢了吧，还没执行完，只好等着。</li>
<li><code>sleep</code>终于执行完了，<code>task()</code>终于从Event Queue进入了主线程执行。</li>
</ul>
<hr>
<p><strong>setTimeout(fn,0)</strong></p>
<p>当setTimeout的延时为0时,是不是意味着他会立即执行呢?</p>
<p>答案是:<strong>NO!</strong></p>
<p><code>setTimeout(fn,0)</code>的含义是，<strong>指定某个任务在主线程最早可得的空闲时间执行</strong>，意思就是不用再等多少秒了，<strong>只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行</strong></p>
<p>关于<code>setTimeout</code>要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。</p>
<hr>
<h5 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h5><p><strong>setTimeout表示执行一个定时函数,每经过单位时间,就执行一次回调函数</strong></p>
<p>上面说完了<code>setTimeout</code>，当然不能错过它的孪生兄弟<code>setInterval</code>。他俩差不多，只不过后者是循环的执行。对于执行顺序来说，<code>setInterval</code>会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p>
<p>唯一需要注意的一点是，对于<code>setInterval(fn,ms)</code>来说，我们已经知道不是每过<code>ms</code>秒会执行一次<code>fn</code>，而是每过<code>ms</code>秒，会有<code>fn</code>进入Event Queue。一旦**<code>setInterval</code>的回调函数<code>fn</code>执行时间超过了延迟时间<code>ms</code>，那么就完全看不出来有时间间隔了**。</p>
<hr>
<h4 id="宏任务-macro-task-和微任务-micro-task"><a href="#宏任务-macro-task-和微任务-micro-task" class="headerlink" title="宏任务(macro-task)和微任务(micro-task)"></a>宏任务(macro-task)和微任务(micro-task)</h4><p>除了广义上的同步任务和异步任务,我们对任务有更精细的定义:</p>
<ul>
<li><strong>macro-task(宏任务)</strong>:包括整体代码script,setTimeout\setInterval…</li>
<li><strong>micro-task(微任务)</strong>:Promise,Process.nextTick….</li>
</ul>
<p>核心知识点伪代码;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> macroTask <span class="keyword">of</span> macroTaskQueue) &#123;<span class="comment">//先执行宏任务  handleMacroTask();    for (const microTask of microTaskQueue) &#123;//再执行宏任务中的微任务    handleMicroTask(microTask);  &#125;&#125;</span></span><br></pre></td></tr></table></figure>





<p>事件循环,宏任务,微任务的关系图:</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151437172.webp" alt="img"></p>
<p>用一段代码来说明:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);    &#125;)    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);        resolve();    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)    &#125;)&#125;)process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);&#125;)<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>);    resolve();&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>)&#125;)<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>);    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>);    &#125;)    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);        resolve();    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        <span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span>)    &#125;)&#125;)</span><br></pre></td></tr></table></figure>

<p>第一轮事件循环流程分析如下：</p>
<ul>
<li>整体script作为第一个宏任务进入主线程，遇到<code>console.log</code>，输出1。</li>
<li>遇到<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中。我们暂且记为<code>setTimeout1</code>。</li>
<li>遇到<code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。我们记为<code>process1</code>。</li>
<li>遇到<code>Promise</code>，<code>new Promise</code>直接执行，输出7。<code>then</code>被分发到微任务Event Queue中。我们记为<code>then1</code>。</li>
<li>又遇到了<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中，我们记为<code>setTimeout2</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th>微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout1</td>
<td>process1</td>
</tr>
<tr>
<td>setTimeout2</td>
<td>then1</td>
</tr>
</tbody></table>
<ul>
<li>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。</li>
<li>我们发现了<code>process1</code>和<code>then1</code>两个微任务。</li>
<li>执行<code>process1</code>,输出6。</li>
<li>执行<code>then1</code>，输出8。</li>
</ul>
<p>好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从<code>setTimeout1</code>宏任务开始：</p>
<ul>
<li>首先输出2。接下来遇到了<code>process.nextTick()</code>，同样将其分发到微任务Event Queue中，记为<code>process2</code>。<code>new Promise</code>立即执行输出4，<code>then</code>也分发到微任务Event Queue中，记为<code>then2</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th>微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout2</td>
<td>process2</td>
</tr>
<tr>
<td></td>
<td>then2</td>
</tr>
</tbody></table>
<ul>
<li>第二轮事件循环宏任务结束，我们发现有<code>process2</code>和<code>then2</code>两个微任务可以执行。</li>
<li>输出3。</li>
<li>输出5。</li>
<li>第二轮事件循环结束，第二轮输出2，4，3，5。</li>
<li>第三轮事件循环开始，此时只剩setTimeout2了，执行。</li>
<li>直接输出9。</li>
<li>将<code>process.nextTick()</code>分发到微任务Event Queue中。记为<code>process3</code>。</li>
<li>直接执行<code>new Promise</code>，输出11。</li>
<li>将<code>then</code>分发到微任务Event Queue中，记为<code>then3</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th>微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>process3</td>
</tr>
<tr>
<td></td>
<td>then3</td>
</tr>
</tbody></table>
<ul>
<li>第三轮事件循环宏任务执行结束，执行两个微任务<code>process3</code>和<code>then3</code>。</li>
<li>输出10。</li>
<li>输出12。</li>
<li>第三轮事件循环结束，第三轮输出9，11，10，12。</li>
</ul>
<p>整段代码，共进行了三次事件循环，完整的输出为<strong>1，7，6，8，2，4，3，5，9，11，10，12</strong>。 (请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</p>
<h4 id="如何实现一个事件的订阅与发布"><a href="#如何实现一个事件的订阅与发布" class="headerlink" title="?如何实现一个事件的订阅与发布"></a>?如何实现一个事件的订阅与发布</h4><h3 id="7-函数式编程"><a href="#7-函数式编程" class="headerlink" title="7.函数式编程"></a>7.函数式编程</h3><h4 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h4><p>函数式编程（Functional Programming，后面简称FP），维基百科的定义是：</p>
<blockquote>
<p>是一种编程范型，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。比起命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。</p>
</blockquote>
<p>我来尝试理解下这个定义，好像就是说，在敲代码的时候，我要<strong>把过程逻辑写成函数，定义好输入参数，只关心它的输出结果。而且可以把函数作为输入输出</strong>。感觉好像平常写js时，就是这样的嘛！</p>
<p><strong>特性:</strong></p>
<ol>
<li><strong>函数是一等公民</strong>。就是说函数可以跟其他变量一样，可以作为其他函数的输入输出。喔，回调函数就是典型应用。</li>
<li><strong>不可变量</strong>。就是说，不能用var跟let咯。按这要求，我似乎有点难写代码。</li>
<li><strong>纯函数</strong>。就是没有副作用的函数。这个好理解，就是不修改函数外部的变量。</li>
<li><strong>引用透明</strong>。这个也好理解，就是说同样的输入，必定是同样的输出。函数内部不依赖外部状态，如一些全局变量。</li>
<li><strong>惰性计算</strong>。大意就是：一个表达式绑定的变量，不是声明的时候就计算出来，而是真正用到它的时候才去计算。</li>
</ol>
<h4 id="函数式编程的优劣势"><a href="#函数式编程的优劣势" class="headerlink" title="函数式编程的优劣势"></a>函数式编程的优劣势</h4><p><strong>优势</strong></p>
<ol>
<li><strong>更好的管理状态</strong>。因为它的宗旨是无状态，或者说更少的状态。而平常DOM的开发中，因为DOM的视觉呈现依托于状态变化，所以不可避免的产生了非常多的状态，而且不同组件可能还相互依赖。以FP来编程，能最大化的减少这些未知、优化代码、减少出错情况。</li>
<li><strong>更简单的复用</strong>。极端的FP代码应该是每一行代码都是一个函数，当然我们不需要这么极端。我们尽量的把过程逻辑以更纯的函数来实现，固定输入-&gt;固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响。</li>
<li><strong>更优雅的组合</strong>。往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。参考上面第二点，更强的复用性，带来更强大的组合性。</li>
<li>隐性好处。减少代码量，提高维护性。</li>
</ol>
<p><strong>劣势</strong></p>
<ol>
<li>JavaScript不能算是严格意义上的函数式语言，很多函数式编程的特性并没有。比如上文说的数组的惰性链求值。为了实现它就得上工具库，或者自己封装实现，提高了代码编写成本。</li>
<li>跟过程式相比，它并没有提高性能。有些地方，如果强制用FP去写，由于没有中间变量，还可能会降低性能。</li>
<li>代码不易读。这个因人而异，因码而已。特别熟悉FP的人可能会觉得这段代码一目了然。而不熟悉的人，遇到写的晦涩的代码，看着一堆堆lambda演算跟匿名函数 <code>() =&gt; () =&gt; ()</code> 瞬间就懵逼了。看懂代码，得脑子里先演算半小时。</li>
<li>学习成本高。一方面继承于上一点。另一方面，很多前端coder，就是因为相对不喜欢一些底层的抽象的编程语言，才来踏入前端坑，你现在又让他们一头扎入FP，显得手足无措。</li>
</ol>
<h4 id="函数柯里化-curry"><a href="#函数柯里化-curry" class="headerlink" title="函数柯里化(curry)"></a>函数柯里化(curry)</h4><p>curry 的概念很简单：<strong>只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</strong></p>
<p> <strong>函数柯里化是指一个函数接收参数但不执行,知道所有参数都接到之后再执行</strong></p>
<p><strong>实现一个curry函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn,...args</span>)</span>&#123;    <span class="keyword">const</span> length = fn.length    <span class="keyword">let</span> argArray = [...args]    <span class="keyword">const</span> res = <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>)</span>&#123;        argArray = [...argArray,...args2]        <span class="comment">//长度相等或者大于fn所需参数就返回执行结果        if(argArray.length &gt;= length)&#123;            return fn(...argArray)        &#125;else&#123;            //长度不相等继续返回函数            return  res        &#125;    &#125;    return res  &#125;      const add = (a,b,c) =&gt;  a+b+c  const a = currying(add,1)  console.log(a(2,3));//output: 6</span></span><br></pre></td></tr></table></figure>

<h3 id="8-Service-Worker-PWA"><a href="#8-Service-Worker-PWA" class="headerlink" title="8.Service Worker/PWA"></a>8.Service Worker/PWA</h3><h3 id="9-Web-Worker"><a href="#9-Web-Worker" class="headerlink" title="9.Web Worker"></a>9.Web Worker</h3><h3 id="10-ES6知识"><a href="#10-ES6知识" class="headerlink" title="10.ES6知识"></a>10.ES6知识</h3><p>ES6所增加的知识太多了,给一个传送口</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903959283367950">1.5万字概括ES6全部特性(已更新ES2020) - 掘金 (juejin.cn)</a></p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151505211.webp" alt="ES6缩略"></p>
<h2 id="2-CSS基础"><a href="#2-CSS基础" class="headerlink" title="2.CSS基础"></a>2.CSS基础</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151559504.webp" alt="img"></p>
<h3 id="1-position"><a href="#1-position" class="headerlink" title="1.position"></a>1.position</h3><h4 id="什么是position"><a href="#什么是position" class="headerlink" title="什么是position?"></a>什么是position?</h4><p>CSS **<code>position</code>**属性用于指定一个元素在文档中的定位方式。<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/top"><code>top</code></a>，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/right"><code>right</code></a>，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/bottom"><code>bottom</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/left"><code>left</code></a> 属性则决定了该元素的最终位置。</p>
<iframe class="interactive is-default-height" height="200" src="https://interactive-examples.mdn.mozilla.net/pages/css/position.html" title="MDN Web Docs Interactive Example" loading="lazy" style="box-sizing: border-box; max-width: 100%; width: 637.156px; border: 1px solid var(--border-primary); background-color: var(--background-secondary); border-radius: var(--elem-radius); color: var(--text-primary); padding: 0px; height: 375px;"></iframe>

<p><strong>position的属性</strong></p>
<ul>
<li><strong>static</strong>:表示元素按文档流中本应该放置的位置来排版</li>
<li><strong>relative</strong>:表示相对定位</li>
<li><strong>absolute</strong>:表示绝对定位</li>
<li><strong>fixed</strong>：固定定位</li>
<li><strong>sticky</strong>:表示粘性定位</li>
</ul>
<p><strong>relative</strong></p>
<p><strong>特性</strong>:</p>
<ul>
<li><strong>不脱离文档流</strong></li>
<li>默认参照物为此元素<strong>原位置</strong></li>
</ul>
<hr>
<p><strong>absolute</strong></p>
<p>特性:</p>
<ul>
<li><strong>脱离文档流</strong></li>
<li>默认参照物为浏览器视窗的<strong>左上角</strong></li>
</ul>
<p>绝对定位元素相对于<em>最近的非 <code>static</code> 祖先元素</em>定位。当这样的祖先元素不存在时，则相对于ICB（inital container block, 初始包含块）。</p>
<p>可以查看示例</p>
<p><a target="_blank" rel="noopener" href="https://codepen.io/zhangzhenming20020615/pen/mdpJeRe">A Pen by 张振明 (codepen.io)</a></p>
<hr>
<p><strong>fixed</strong></p>
<p><strong>特性</strong></p>
<ul>
<li><strong>脱离文档流</strong></li>
<li>默认参照物为浏览器<strong>视窗位置</strong></li>
</ul>
<hr>
<p><strong>sticky(粘性定位)</strong></p>
<p>单词sticky的中文意思是“粘性的”，<code>position:sticky</code>表现也符合这个粘性的表现。基本上，可以看出是<code>position:relative</code>和<code>position:fixed</code>的结合体——当元素在屏幕内，表现为relative，就要滚出显示器屏幕的时候，表现为fixed。</p>
<p><strong>特性</strong>:</p>
<ul>
<li><strong>当元素没有到达指定的位置时</strong>,position为<strong>relative</strong></li>
<li><strong>当元素到达指定的位置</strong>,position为<strong>fixed</strong>，也就是固定住</li>
<li>sticky元素的父级元素不能有任何<code>overflow:visible</code>以外的overflow设置,否则没有粘滞效果</li>
</ul>
<h3 id="2-行内元素-块级元素"><a href="#2-行内元素-块级元素" class="headerlink" title="2.行内元素/块级元素"></a>2.行内元素/块级元素</h3><h4 id="什么是行内元素？"><a href="#什么是行内元素？" class="headerlink" title="什么是行内元素？"></a>什么是行内元素？</h4><p><strong>行内元素只占据它对应标签的边框所包含的空间</strong></p>
<p><strong>一般情况下，行内元素只能包含数据和其他行内元素。</strong></p>
<p>行内元素列表:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/b">b</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/big">big</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/i">i</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/small">small</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/tt">tt</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/abbr">abbr</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/acronym">acronym</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/cite">cite</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/code">code</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/dfn">dfn</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/em">em</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/kbd">kbd</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/strong">strong</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/samp">samp</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/var">var</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a">a</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/bdo">bdo</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/br">br</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img">img</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/map">map</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object">object</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/q">q</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script">script</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/span">span</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/sub">sub</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/sup">sup</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button">button</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input">input</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/label">label</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/select">select</a>, <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/textarea">textarea</a></li>
</ul>
<h4 id="什么是块级元素"><a href="#什么是块级元素" class="headerlink" title="什么是块级元素"></a>什么是块级元素</h4><p>块级元素占据其父元素（容器）的整个水平空间，垂直空间等于其内容高度，因此创建了一个“块”</p>
<p>通常浏览器会在块级元素前后另起一个新行</p>
<h4 id="行内元素与块级元素的区别"><a href="#行内元素与块级元素的区别" class="headerlink" title="行内元素与块级元素的区别"></a>行内元素与块级元素的区别</h4><p>块级元素与行内元素有几个关键区别：</p>
<ul>
<li><p>格式</p>
<p>默认情况下，块级元素会新起一行。</p>
</li>
<li><p>内容模型</p>
<p>一般块级元素可以包含行内元素和其他块级元素。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。</p>
</li>
</ul>
<p>HTML 标准中块级元素和行内元素的区别至高出现在 4.01 标准中。在 HTML5，这种区别被一个更复杂的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories">内容类别 (en-US)</a>代替。”块级“类别大致相当于 HTML5 中的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#flow_content">流内容 (en-US)</a>类别，而”行内“类别相当于 HTML5 中的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#phrasing_content">措辞内容 (en-US)</a>类别，不过除了这两个还有其他类别。</p>
<hr>
<h4 id="BFC-块格式化上下文"><a href="#BFC-块格式化上下文" class="headerlink" title="BFC(块格式化上下文)"></a>BFC(块格式化上下文)</h4><p><strong>块格式化上下文（Block Formatting Context，BFC）</strong> 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p>
<p>下列方式会创建<strong>块格式化上下文</strong>：</p>
<ul>
<li>根元素（<code>&lt;html&gt;）</code></li>
<li>浮动元素（元素的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a> 不是 <code>none</code>）</li>
<li>绝对定位元素（元素的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position"><code>position</code></a> 为 <code>absolute</code> 或 <code>fixed</code>）</li>
<li>行内块元素（元素的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>inline-block</code>）</li>
<li>表格单元格（元素的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>table-cell</code>，HTML表格单元格默认为该值）</li>
<li>表格标题（元素的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>table-caption</code>，HTML表格标题默认为该值）</li>
<li>匿名表格单元格元素（元素的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>table、``table-row</code>、 <code>table-row-group、``table-header-group、``table-footer-group</code>（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 <code>inline-table</code>）</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow"><code>overflow</code></a> 计算值(Computed)不为 <code>visible</code> 的块元素</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 值为 <code>flow-root</code> 的元素</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/contain"><code>contain</code></a> 值为 <code>layout</code>、<code>content </code>或 paint 的元素</li>
<li>弹性元素（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>flex</code> 或 <code>inline-flex </code>元素的直接子元素）</li>
<li>网格元素（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display"><code>display</code></a> 为 <code>grid</code> 或 <code>inline-grid</code> 元素的直接子元素）</li>
<li>多列容器（元素的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/column-count"><code>column-count</code></a> 或 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/column-width"><code>column-width</code> (en-US)</a> 不为 <code>auto，包括 ``column-count</code> 为 <code>1</code>）</li>
<li><code>column-span</code> 为 <code>all</code> 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（<a target="_blank" rel="noopener" href="https://github.com/w3c/csswg-drafts/commit/a8634b96900279916bd6c505fda88dda71d8ec51">标准变更</a>，<a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/chromium/issues/detail?id=709362">Chrome bug</a>）。</li>
</ul>
<p>块格式化上下文包含创建它的元素内部的所有内容.</p>
<p>块格式化上下文对浮动定位（参见 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/float"><code>float</code></a>）与清除浮动（参见 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear"><code>clear</code></a>）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing">Margin collapsing</a>）也只会发生在属于同一BFC的块级元素之间。</p>
<hr>
<h3 id="3-flex布局"><a href="#3-flex布局" class="headerlink" title="3.flex布局"></a>3.flex布局</h3><h4 id="什么是flex布局"><a href="#什么是flex布局" class="headerlink" title="什么是flex布局?"></a>什么是flex布局?</h4><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151551342.png" alt="img"></p>
<p>顾名思义,flex布局就是弹性布局,在flex容器中默认存在两条轴，<strong>水平主轴(main axis)<strong>和</strong>垂直的交叉轴(cross axis)</strong>,我们可以通过设置属性将垂直方向变为主轴,水平方向变为交叉轴</p>
<p>在容器内的每个单元块被称为<strong>flex item</strong>,每个项目占据的主轴空间为(main size)，占据的交叉轴的空间为(cross size)</p>
<h5 id="flex容器"><a href="#flex容器" class="headerlink" title="flex容器"></a>flex容器</h5><p>实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    <span class="attribute">display</span>: flex | inline-flex;       //可以有两种取值&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是：当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。</strong></p>
<p>有下面六种属性可以设置在容器上，它们分别是：</p>
<ol>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ol>
<hr>
<p><strong>flex-direction</strong>:决定主轴的方向</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>row</strong>：默认值,主轴为水平方向,起点在左端</p>
<p><strong>row-reverse</strong>:主轴为水平方向,起点在右端</p>
<p><strong>column</strong>:主轴为垂直方向,起点在上沿</p>
<p><strong>column-reverse</strong>：主轴为垂直方向,起点在下端</p>
<hr>
<p><strong>flex-wrap</strong>：决定容器内项目是否可以换行</p>
<p>默认情况下，项目都排在主轴线上，使用 flex-wrap 可实现项目的换行。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>nowrap</strong>:<strong>默认值</strong>，不换行,即当主轴尺寸固定时，当空间不足时，项目尺寸会随之调整而并不会挤到下一行。</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151603139.png" alt="img"></p>
<p><strong>wrap</strong>：换行,当项目主轴总尺寸超过容器时换行,第一行在上方</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151604830.png" alt="img"></p>
<p><strong>wrap-reverse</strong>:换行，第一行在下方</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151605328.png" alt="img"></p>
<hr>
<p> <strong>flex-flow</strong>:<strong>flex-direction 和 flex-wrap 的简写形式</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>默认值</strong>为: row nowrap</p>
<hr>
<p> <strong>justify-content：定义了项目在主轴的对齐方式。</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;&#125;</span><br></pre></td></tr></table></figure>

<p>假设主轴是<strong>水平方向</strong>,垂直方向同理(左右改为上下)</p>
<p><strong>flex-start</strong>:左对齐</p>
<p><strong>flex-end</strong>:右对齐</p>
<p><strong>center</strong>：居中</p>
<p><strong>space-between</strong>：两端对齐,项目之间的间隔相等，即剩余空间等分成间隙。</p>
<p><strong>space-around</strong>：每个项目两侧的间隔相等，所以项目之间的间隔比项目与边缘的间隔大一倍。</p>
<hr>
<p><strong>align-items: 定义了项目在交叉轴上的对齐方式</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>baseline</strong>:项目的第一行文字的基线对齐</p>
<p><strong>stretch</strong>:<strong>默认值</strong>  即如果项目未设置高度或者设为 auto，将占满整个容器的高度</p>
<hr>
<p><strong>align-content: 定义了多根轴线的对齐方式，如果项目只有一根轴线，那么该属性将不起作用</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;    <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;&#125;</span><br></pre></td></tr></table></figure>

<p>当你 flex-wrap 设置为 <strong>nowrap</strong> 的时候，容器仅存在一根轴线，因为项目不会换行，就不会产生多条轴线。</p>
<p>当你 flex-wrap 设置为 <strong>wrap</strong> 的时候，容器可能会出现多条轴线，这时候你就需要去设置多条轴线之间的对齐方式了。</p>
<h5 id="flex元素属性"><a href="#flex元素属性" class="headerlink" title="flex元素属性"></a>flex元素属性</h5><p>有六种属性可运用在 item 项目上：</p>
<ol>
<li>order</li>
<li>flex-basis</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex</li>
<li>align-self</li>
</ol>
<p> <strong>order: 定义项目在容器中的排列顺序，数值越小，排列越靠前，默认值为 0</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;    <span class="attribute">order</span>: &lt;integer&gt;;&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151616010.png" alt="img"></p>
<hr>
<p><strong>flex-basis: 定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否有多余空间</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;    <span class="attribute">flex-basis</span>: &lt;length&gt; | auto;&#125;</span><br></pre></td></tr></table></figure>

<p>默认值：<strong>auto</strong>，即项目本来的大小, 这时候 item 的宽高取决于 width 或 height 的值。</p>
<iframe class="interactive is-default-height" height="200" src="https://interactive-examples.mdn.mozilla.net/pages/css/flex-basis.html" title="MDN Web Docs Interactive Example" loading="lazy" style="box-sizing: border-box; max-width: 100%; width: 639.297px; border: 1px solid var(--border-primary); background-color: var(--background-secondary); border-radius: var(--elem-radius); color: var(--text-primary); padding: 0px; height: 375px;"></iframe>

<p><strong>当主轴为水平方向的时候，当设置了 flex-basis，项目的宽度设置值会失效，flex-basis 需要跟 flex-grow 和 flex-shrink 配合使用才能发挥效果。</strong></p>
<ul>
<li>当 flex-basis 值为 0 % 时，是把该项目视为零尺寸的，故即使声明该尺寸为 140px，也并没有什么用。</li>
<li>当 flex-basis 值为 auto 时，则跟根据尺寸的设定值(假如为 100px)，则这 100px 不会纳入剩余空间。</li>
</ul>
<p> <strong>flex-grow: 定义项目的放大比例</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;    <span class="attribute">flex-grow</span>: &lt;number&gt;;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>默认值为 0，即如果存在剩余空间，也不放大</strong></p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151627863.png" alt="img"></p>
<p>当所有的项目都以 flex-basis 的值进行排列后，仍有剩余空间，那么这时候 flex-grow 就会发挥作用了。</p>
<p>如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间。(如果有的话)</p>
<p>如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p>
<p>当然如果当所有项目以 flex-basis 的值排列完后发现空间不够了，且 flex-wrap：nowrap 时，此时 flex-grow 则不起作用了，这时候就需要接下来的这个属性。</p>
<p><strong>flex-shrink: 定义了项目的缩小比例</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;    <span class="attribute">flex-shrink</span>: &lt;number&gt;;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>默认值: 1，即如果空间不足，该项目将缩小，负值对该属性无效。</strong></p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151628761.png" alt="img"></p>
<p>这里可以看出，虽然每个项目都设置了宽度为 50px，但是由于自身容器宽度只有 200px，这时候每个项目会被同比例进行缩小，因为默认值为 1。</p>
<p>同理可得：</p>
<p>如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。</p>
<p>如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。</p>
<hr>
<p><strong>flex: flex-grow, flex-shrink 和 flex-basis的简写</strong></p>
<p>flex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 <strong>flex 的默认值是 0 1 auto</strong>。</p>
<p>grow 和 shrink 是一对双胞胎，grow 表示伸张因子，shrink 表示是收缩因子。</p>
<p>grow 在 flex 容器下的子元素的宽度和比容器和小的时候起作用。 grow 定义了子元素的尺寸增长因子，容器中除去子元素之和剩下的尺寸会按照各个子元素的 grow 值进行平分加大各个子元素上。</p>
<hr>
<p><strong>lign-self: 允许单个项目有与其他项目不一样的对齐方式</strong></p>
<p>单个项目覆盖 align-items 定义的属性</p>
<p>默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">     <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个跟 align-items 属性时一样的，只不过 align-self 是对单个项目生效的，而 align-items 则是对容器下的所有项目生效的。</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203151642611.png" alt="img"></p>
<hr>
<p><a target="_blank" rel="noopener" href="https://codepen.io/pen/">A Pen by 张振明 (codepen.io)</a></p>
<h4 id="如何用flex实现九宫格布局"><a href="#如何用flex实现九宫格布局" class="headerlink" title="如何用flex实现九宫格布局"></a>如何用flex实现九宫格布局</h4><p><a target="_blank" rel="noopener" href="https://codepen.io/zhangzhenming20020615/pen/YzYXqWj">flex实现九宫格布局 (codepen.io)</a></p>
<h4 id="flex-1指的是什么？flex属性默认值是什么"><a href="#flex-1指的是什么？flex属性默认值是什么" class="headerlink" title="flex:1指的是什么？flex属性默认值是什么"></a>flex:1指的是什么？flex属性默认值是什么</h4><p><code>flex:1</code> 为：<code>flex: 1 1 0</code>;</p>
<p>flex属性默认值为:<code>0 1 auto</code></p>
<p>具体代表什么属性 上文有说明</p>
<h4 id="介绍一下flex-shrink和flex-basis属性"><a href="#介绍一下flex-shrink和flex-basis属性" class="headerlink" title="介绍一下flex-shrink和flex-basis属性"></a>介绍一下flex-shrink和flex-basis属性</h4><hr>
<hr>
<h3 id="4-1px问题"><a href="#4-1px问题" class="headerlink" title="4.1px问题"></a>4.1px问题</h3><h3 id="5-重绘与回流"><a href="#5-重绘与回流" class="headerlink" title="5.重绘与回流"></a>5.重绘与回流</h3><p>参考:[浏览器的重绘和回流](<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903569087266823">浏览器的回流与重绘 (Reflow &amp; Repaint) - 掘金 (juejin.cn)</a>)</p>
<p>在讨论回流与重绘之前，我们要知道：</p>
<ol>
<li>浏览器使用流式布局模型 (Flow Based Layout)。</li>
<li>浏览器会把<code>HTML</code>解析成<code>DOM</code>，把<code>CSS</code>解析成<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并就产生了<code>Render Tree</code>。</li>
<li>有了<code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</li>
<li>由于浏览器使用流式布局，对<code>Render Tree</code>的计算通常只需要遍历一次就可以完成，但<code>table</code>及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用<code>table</code>布局的原因之一。</li>
</ol>
<p><strong>一句话：回流必将引起重绘，重绘不一定会引起回流。</strong></p>
<h4 id="1-回流-Reflow"><a href="#1-回流-Reflow" class="headerlink" title="1.回流 (Reflow)"></a>1.回流 (Reflow)</h4><p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p>
<p>会导致回流的操作：</p>
<ul>
<li>页面首次渲染</li>
<li>浏览器窗口大小发生改变</li>
<li>元素尺寸或位置发生改变</li>
<li>元素内容变化（文字数量或图片大小等等）</li>
<li>元素字体大小变化</li>
<li>添加或者删除<strong>可见</strong>的<code>DOM</code>元素</li>
<li>激活<code>CSS</code>伪类（例如：<code>:hover</code>）</li>
<li>查询某些属性或调用某些方法</li>
</ul>
<p>一些常用且会导致回流的属性和方法：</p>
<ul>
<li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li>
<li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li>
<li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li>
<li><code>scrollIntoView()</code>、<code>scrollIntoViewIfNeeded()</code></li>
<li><code>getComputedStyle()</code></li>
<li><code>getBoundingClientRect()</code></li>
<li><code>scrollTo()</code></li>
</ul>
<h4 id="2-重绘-Repaint"><a href="#2-重绘-Repaint" class="headerlink" title="2.重绘 (Repaint)"></a>2.重绘 (Repaint)</h4><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code>color</code>、<code>background-color</code>、<code>visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p>
<h4 id="3-性能影响"><a href="#3-性能影响" class="headerlink" title="3.性能影响"></a>3.性能影响</h4><p><strong>回流比重绘的代价要更高。</strong></p>
<p>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。</p>
<p>现代浏览器会对频繁的回流或重绘操作进行优化：</p>
<p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p>
<p>当你访问以下属性或方法时，浏览器会立刻清空队列：</p>
<ul>
<li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li>
<li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li>
<li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li>
<li><code>width</code>、<code>height</code></li>
<li><code>getComputedStyle()</code></li>
<li><code>getBoundingClientRect()</code></li>
</ul>
<p>因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</p>
<h4 id="4-如何避免"><a href="#4-如何避免" class="headerlink" title="4.如何避免"></a>4.如何避免</h4><h5 id="1-CSS"><a href="#1-CSS" class="headerlink" title="1.CSS"></a>1.CSS</h5><ul>
<li>避免使用<code>table</code>布局。</li>
<li>尽可能在<code>DOM</code>树的最末端改变<code>class</code>。</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上。</li>
<li>避免使用<code>CSS</code>表达式（例如：<code>calc()</code>）。</li>
</ul>
<h5 id="2-JavaScript"><a href="#2-JavaScript" class="headerlink" title="2.JavaScript"></a>2.JavaScript</h5><ul>
<li>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li>
<li>避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM操作</code>，最后再把它添加到文档中。</li>
<li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行的<code>DOM</code>操作不会引发回流和重绘。</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
<hr>
<p><strong>总结</strong>:会引起元素位置变化的就会reflow，如博主上面介绍的，窗口大小改变、字体大小改变、以及元素位置改变，都会引起周围的元素改变他们以前的位置；不会引起位置变化的，只是在以前的位置进行改变背景颜色等，只会repaint；</p>
<hr>
<hr>
<h3 id="6-居中布局"><a href="#6-居中布局" class="headerlink" title="6.居中布局"></a>6.居中布局</h3><h3 id="7-层叠上下文"><a href="#7-层叠上下文" class="headerlink" title="7.层叠上下文"></a>7.层叠上下文</h3><blockquote>
<p>参考:<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903667175260174#heading-1">彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index - 掘金 (juejin.cn)</a></p>
</blockquote>
<p>首先，<code>z-index</code>属性值并不是在任何元素上都有效果。它<strong>仅在</strong>定位元素（定义了<code>position</code>属性，且属性值为非<code>static</code>值的元素）上有效果。</p>
<p>判断元素在<code>Z轴</code>上的堆叠顺序，不仅仅是直接比较两个元素的<code>z-index</code>值的大小，这个堆叠顺序实际由元素的<strong>层叠上下文</strong>、<strong>层叠等级</strong>共同决定。</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181527715.png" alt="image-20220226103650745"></p>
<h4 id="1-什么是层叠上下文"><a href="#1-什么是层叠上下文" class="headerlink" title="1.什么是层叠上下文"></a>1.什么是层叠上下文</h4><p>层叠上下文(stacking context)，是HTML中一个三维的概念。在CSS2.1规范中，每个盒模型的位置是三维的，分别是平面画布上的<code>X轴</code>，<code>Y轴</code>以及表示层叠的<code>Z轴</code>。一般情况下，元素在页面上沿<code>X轴Y轴</code>平铺，我们察觉不到它们在<code>Z轴</code>上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。</p>
<p>如果一个元素含有层叠上下文，(也就是说它是层叠上下文元素)，我们可以理解为这个元素在<code>Z轴</code>上就“高人一等”，最终表现就是它离屏幕观察者更近。</p>
<blockquote>
<p><strong>具象的比喻</strong>：你可以把层叠上下文元素理解为理解为<strong>该元素当了官</strong>，而其他非层叠上下文元素则可以理解为普通群众。凡是“当了官的元素”就比普通元素等级要高，也就是说元素在<code>Z轴</code>上更靠上，更靠近观察者。</p>
</blockquote>
<h4 id="2-什么是层叠等级"><a href="#2-什么是层叠等级" class="headerlink" title="2.什么是层叠等级"></a>2.什么是层叠等级</h4><p>那么，层叠等级指的又是什么？层叠等级(stacking level，叫“层叠级别”/“层叠水平”也行)</p>
<ul>
<li>在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在<code>Z轴</code>上的上下顺序。</li>
<li>在其他普通元素中，它描述定义的是这些普通元素在<code>Z轴</code>上的上下顺序。</li>
</ul>
<p>说到这，可能很多人疑问了，不论在层叠上下文中还是在普通元素中，层叠等级都表示元素在<code>Z轴</code>上的上下顺序，那就直接说它描述定义了所有元素在<code>Z轴</code>上的上下顺序就OK啊！为什么要分开描述？</p>
<p>为了说明原因，先举个栗子：</p>
<blockquote>
<p><strong>具象的比喻</strong>：我们之前说到，处于层叠上下文中的元素，就像是元素当了官，等级自然比普通元素高。再想象一下，假设一个官员A是个省级领导，他下属有一个秘书a-1，家里有一个保姆a-2。另一个官员B是一个县级领导，他下属有一个秘书b-1，家里有一个保姆b-2。a-1和b-1虽然都是秘书，但是你想一个省级领导的秘书和一个县级领导的秘书之间有可比性么？甚至保姆a-2都要比秘书b-1的等级高得多。谁大谁小，谁高谁低一目了然，所以根本没有比较的意义。只有在A下属的a-1、a-2以及B下属的b-1、b-2中相互比较大小高低才有意义。</p>
</blockquote>
<p><strong>再类比回“层叠上下文”和“层叠等级”，就得出一个结论：</strong></p>
<ol>
<li>普通元素的层叠等级优先由其所在的层叠上下文决定。</li>
<li>层叠等级的比较只有在当前层叠上下文元素中才有意义。不同层叠上下文中比较层叠等级是没有意义的。</li>
</ol>
<h4 id="3-如何产生“层叠上下文”"><a href="#3-如何产生“层叠上下文”" class="headerlink" title="3.如何产生“层叠上下文”"></a>3.如何产生“层叠上下文”</h4><p>前面说了那么多，知道了“层叠上下文”和“层叠等级”，其中还有一个最关键的问题：到底如何产生层叠上下文呢？如何让一个元素变成层叠上下文元素呢？</p>
<p>其实，层叠上下文也基本上是有一些特定的CSS属性创建的，一般有3种方法：</p>
<ol>
<li><code>HTML</code>中的根元素<code>&lt;html&gt;&lt;/html&gt;</code>本身j就具有层叠上下文，称为“根层叠上下文”。</li>
<li>普通元素设置<code>position</code>属性为<strong>非</strong><code>static</code>值并设置<code>z-index</code>属性为具体数值，产生层叠上下文。</li>
<li>CSS3中的新属性也可以产生层叠上下文。</li>
</ol>
<hr>
<p>上面说了那么多，可能你还是有点懵。这么多概念规则，来点最实际的，有没有一个“套路”当遇到元素层叠时，能很清晰地判断出他们谁在上谁在下呢？答案是——肯定有啊！</p>
<ol>
<li>首先先看要比较的两个元素是否处于同一个层叠上下文中<ol>
<li>如果是，谁的层叠等级大，谁在上面</li>
<li>如果两个元素不在统一层叠上下文中，请先比较他们所处的层叠上下文的层叠等级</li>
</ol>
</li>
<li>当两个元素层叠等级相同、层叠顺序相同时，在DOM结构中后面的元素层叠等级在前面元素之上</li>
</ol>
<hr>
<hr>
<h3 id="8-sass-less"><a href="#8-sass-less" class="headerlink" title="8.sass/less"></a>8.sass/less</h3><h3 id="9-对盒模型的理解"><a href="#9-对盒模型的理解" class="headerlink" title="9.对盒模型的理解"></a>9.对盒模型的理解</h3><p>盒模型</p>
<p>盒模型共有两种:</p>
<ul>
<li>标准盒模型</li>
<li>IE盒模型</li>
</ul>
<h2 id="3-Vue"><a href="#3-Vue" class="headerlink" title="3.Vue"></a>3.Vue</h2><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181857871.webp" alt="img"></p>
<h3 id="1-MVVM"><a href="#1-MVVM" class="headerlink" title="1.MVVM"></a>1.MVVM</h3><h4 id="1-什么是MVVM"><a href="#1-什么是MVVM" class="headerlink" title="1.什么是MVVM?"></a>1.什么是MVVM?</h4><blockquote>
<p>Model–View–ViewModel （MVVM） 是一个软件架构设计模式，源于经典的Model-View-Controller(MVC)模式,MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率.</p>
</blockquote>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181527689.awebp" alt="1.png"></p>
<p><strong>MVVM</strong>的核心是<strong>ViewModel</strong>层,它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，<strong>该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互</strong>，起呈上启下作用。</p>
<p><strong>View层</strong></p>
<p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。</p>
<p><strong>Model 层</strong></p>
<p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</p>
<p><strong>ViewModel 层</strong></p>
<p><strong><code>ViewModel</code> 是由前端开发人员组织生成和维护的视图数据层</strong>。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。</p>
<h4 id="2-ViewModel有什么好处"><a href="#2-ViewModel有什么好处" class="headerlink" title="2.ViewModel有什么好处?"></a>2.ViewModel有什么好处?</h4><p>MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p>
<h3 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2.生命周期"></a>2.生命周期</h3><h4 id="1-介绍一下Vue生命周期"><a href="#1-介绍一下Vue生命周期" class="headerlink" title="1.介绍一下Vue生命周期"></a>1.介绍一下Vue生命周期</h4><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181527157.awebp" alt="1.png"></p>
<p>Vue 实例有一个完整的生命周期，也就是从开始创建实例、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p>
<p><strong>各个生命周期的作用</strong></p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>组件实例被创建之初，组件的属性生效之前</td>
</tr>
<tr>
<td>created</td>
<td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td>
</tr>
<tr>
<td>beforeMount</td>
<td>在挂载开始之前被调用：相关的 render 函数首次被调用</td>
</tr>
<tr>
<td>mounted</td>
<td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td>
</tr>
<tr>
<td>updated</td>
<td>组件数据更新之后</td>
</tr>
<tr>
<td>activited</td>
<td>keep-alive 专属，组件被激活时调用</td>
</tr>
<tr>
<td>deactivated</td>
<td>keep-alive 专属，组件被销毁时调用</td>
</tr>
<tr>
<td>beforeDestory</td>
<td>组件销毁前调用</td>
</tr>
<tr>
<td>destoryed</td>
<td>组件销毁后调用</td>
</tr>
</tbody></table>
<p><strong>beforeCreate</strong>:此时生命周期以及事件已经被初始化但是数据代理还未开始，无法通过vm访问到data中的数据、methods中的方法</p>
<p><strong>created</strong>：此时数据监测和数据代理已经初始化，可以通过访问vm访问到data中的数据</p>
<p><strong>beforeMount</strong>：此阶段Vue开始解析模板，生成虚拟DOM(内存中)，但是页面还不能显示解析好的内容，</p>
<p>此时页面呈现的时未经Vue编译的DOM结构，所有对DOM的操作，最终都不奏效</p>
<p><strong>mouted</strong>:此阶段内存中的虚拟DOM已经转成真实DOM插入页面。页面中呈现的时经过Vue编译的DOM，此时对DOM的操作均有效。至此初始化过程结束，一般再次进行:开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作、</p>
<p><strong>beforeUpdate</strong>:此时数据是新的，但是页面是旧的，页面尚未和数据保持同步</p>
<p><strong>updated</strong>:此时页面已经完成了从Model到View的更新，页面数据是新的，页面也是新的，即页面和数据保持同步</p>
<p><strong>beforeDestory</strong>：此时vm中所有的data、methods、指令等等都处于可用状态，但是马上要执行销毁过程，一般在此阶段:关闭定时器，取消订阅消息、解绑自定义事件等收尾操作</p>
<p><strong>destoryed</strong>:销毁vm实例</p>
<h4 id="2-nextTick是如何实现的"><a href="#2-nextTick是如何实现的" class="headerlink" title="2.nextTick是如何实现的"></a>2.nextTick是如何实现的</h4><p><strong>什么是nextTick?</strong></p>
<blockquote>
<p>nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用nextTick，则可以在回调中获取更新后的 DOM</p>
</blockquote>
<p><strong>nextTick原理</strong></p>
<h4 id="3-父子组件挂载时-生命周期的顺序是怎么样的"><a href="#3-父子组件挂载时-生命周期的顺序是怎么样的" class="headerlink" title="3.父子组件挂载时,生命周期的顺序是怎么样的"></a>3.父子组件挂载时,生命周期的顺序是怎么样的</h4><p>vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>
<ul>
<li><p>加载渲染过程</p>
<p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
</li>
<li><p>子组件更新过程</p>
<p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
</li>
<li><p>父组件更新过程</p>
<p>父 beforeUpdate -&gt; 父 updated</p>
</li>
<li><p>销毁过程</p>
<p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
</li>
</ul>
<h3 id="3-数据绑定"><a href="#3-数据绑定" class="headerlink" title="3.数据绑定"></a>3.数据绑定</h3><h4 id="1-Vue的双向绑定如何实现"><a href="#1-Vue的双向绑定如何实现" class="headerlink" title="1.Vue的双向绑定如何实现"></a>1.Vue的双向绑定如何实现</h4><p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191107846.webp" alt="1.png"></p>
<p>即：</p>
<ul>
<li>输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。</li>
<li>Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。</li>
</ul>
<p>其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。</p>
<p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p>
<p>实现一个监听器 <strong>Observer</strong>：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</p>
<p>实现一个解析器 <strong>Compile</strong>：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</p>
<p>实现一个订阅者 <strong>Watcher：Watcher</strong> 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</p>
<p>实现一个订阅器 <strong>Dep</strong>：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191112642.webp" alt="1.png"></p>
<p>按我自己的理解就是:当修改数据时,vue会调用dep.notify通知相应的wathcer执行它的update函数,update函数会执行compile中绑定的回调,然会修改dom的值.当修改视图层的数据时,vue通过监听input来获取input中的值并将其赋值给data中的对应属性，修改属性又会触发setter，于是又会执行dep.notify等一系列操作,从而达到双向绑定.</p>
<h4 id="2-Vue如何监听数组或对象的改变"><a href="#2-Vue如何监听数组或对象的改变" class="headerlink" title="2.Vue如何监听数组或对象的改变"></a>2.Vue如何监听数组或对象的改变</h4><p><strong>1.vue会监视data中所有层次的数据</strong></p>
<p><strong>2.如何监测对象中的数据？</strong></p>
<p>​    通过setter事件监视，且要在newVue时就传入要监测的数据</p>
<p>​        (1).在对象后追加的属性，Vue默认不做响应式处理</p>
<p>​         (2).如需给后添加的属性做响应式，需要使用以下API:</p>
<p>​                Vue.set(target,propertyName/index,value)</p>
<p>​                vm.$set(target,propertyName/index,value)</p>
<p> <strong>3.如何监测数组中的数据?</strong></p>
<p>​     通过包裹数组更新元素的方法实现，本质就是做了两件事:</p>
<p>​            (1).调用原生对应的方法对数组进行更新</p>
<p>​            (2).重新解析模板，进而更新页面</p>
<p><strong>4.在Vue修改数组中的某个元素需要用到以下方法:</strong></p>
<p>​        1.使用这些API:push(),pop(),shift(),unshift(),splice(),sort(),erverse()</p>
<p>​        2.Vue.set()或vm.$set</p>
<hr>
<h4 id="3-defineProperty和proxy的区别"><a href="#3-defineProperty和proxy的区别" class="headerlink" title="3.defineProperty和proxy的区别"></a>3.defineProperty和proxy的区别</h4><p><strong>Proxy 的优势如下:</strong></p>
<ul>
<li>Proxy 可以直接监听对象而非属性；</li>
<li>Proxy 可以直接监听数组的变化；</li>
<li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li>
<li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li>
<li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li>
</ul>
<p><strong>Object.defineProperty 的优势如下:</strong></p>
<ul>
<li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平</li>
</ul>
<h4 id="4-Vue中的数据为什么频繁变化但只会更新一次"><a href="#4-Vue中的数据为什么频繁变化但只会更新一次" class="headerlink" title="4.Vue中的数据为什么频繁变化但只会更新一次"></a>4.Vue中的数据为什么频繁变化但只会更新一次</h4><h3 id="4-状态管理"><a href="#4-状态管理" class="headerlink" title="4.状态管理"></a>4.状态管理</h3><h4 id="1-vuex是什么"><a href="#1-vuex是什么" class="headerlink" title="1.vuex是什么"></a>1.vuex是什么</h4><blockquote>
<p>专门在Vue中实现集中式状态(数据)管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理(读/写),也是一种组件间通信的方式，且适用于任意组件间通信</p>
</blockquote>
<ul>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li>
</ul>
<h4 id="2-什么时候使用vuex"><a href="#2-什么时候使用vuex" class="headerlink" title="2.什么时候使用vuex?"></a>2.什么时候使用vuex?</h4><ul>
<li>​    多个组件依赖同一状态</li>
<li>​    来自不同组件的行为需要变更同一状态</li>
</ul>
<h4 id="3-vuex的工作原理"><a href="#3-vuex的工作原理" class="headerlink" title="3.vuex的工作原理"></a>3.vuex的工作原理</h4><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181658280.png" alt="vuex"></p>
<p>vuex包括以下几个模块:</p>
<ul>
<li><p><strong>State</strong>：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</p>
<p>1.vuex管理的状态对象(存放数据的对象)</p>
<p>2.它应该时唯一的</p>
<p>3.示例代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">   <span class="comment">// key:value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Getter</strong>：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</p>
<p>当state中的数据需要经过加工后再使用时，可以使用getters加工,类似于组件中的计算属性</p>
</li>
<li><p><strong>Mutation</strong>：是唯一更改 store 中状态的方法，且必须是同步函数。</p>
<p>1.值是一个对象，包含多个直接更新state的方法</p>
<p>2.谁能调用mutations中的方法？如何让调用？</p>
<p>​    在action中使用:**commit(‘对应的mutations方法名’)**触发</p>
<p>3.mutations中方法的特点：不能写异步代码、只能单纯的操作state</p>
<p>4.示例代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">   <span class="comment">//函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Action</strong>：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</p>
<p>1.值为一个对象，包含多个响应用户动作的回调函数</p>
<p>2.通过commit()来触发mutation中函数的调用，间接更新state</p>
<p>3.示例代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">	<span class="comment">//函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Module</strong>：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</p>
</li>
</ul>
<hr>
<h4 id="4-vuex中4个map方法的使用"><a href="#4-vuex中4个map方法的使用" class="headerlink" title="4.vuex中4个map方法的使用"></a>4.<strong>vuex中4个map方法的使用</strong></h4><p>定义:使用vuex提供的map方法可以对组件中的计算属性和方法进行映射，可以大大的减少代码量，提高代码的复用率</p>
<h5 id="1-mapState"><a href="#1-mapState" class="headerlink" title="1.mapState"></a>1.mapState</h5><p>理解:用于帮助我们映射state中的数据为计算属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    <span class="comment">//借助mapState生成计算属性:count,student,school(对象写法)</span></span><br><span class="line">    <span class="comment">//对象中的key是我们在自己的组件中渲染时需要调用的值，value是我们在store中state内定义的值</span></span><br><span class="line">     ...mapState(&#123;<span class="attr">count</span>:<span class="string">&#x27;count&#x27;</span>,<span class="attr">student</span>:<span class="string">&#x27;student&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>&#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//借助mapState生成计算属性:count,student,school(数组写法)</span></span><br><span class="line">     ...mapState([<span class="string">&#x27;count&#x27;</span>,<span class="string">&#x27;student&#x27;</span>,<span class="string">&#x27;school&#x27;</span>]),</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>



<h5 id="2-mapGetters"><a href="#2-mapGetters" class="headerlink" title="2.mapGetters"></a>2.mapGetters</h5><p>理解:用于帮助我们映射getters中的数据为计算属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性:bigCount(对象写法)</span></span><br><span class="line">    <span class="comment">//对象中的key是我们在自己的组件中渲染时需要调用的值，value是我们在store中getters内定义的值</span></span><br><span class="line">     ...mapState(&#123;<span class="attr">count</span>:<span class="string">&#x27;count&#x27;</span>,<span class="attr">student</span>:<span class="string">&#x27;student&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>&#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性:bigCount(数组写法)</span></span><br><span class="line">     ...mapGetters([<span class="string">&#x27;bigCount&#x27;</span>])</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>



<h5 id="3-mapActions"><a href="#3-mapActions" class="headerlink" title="3.mapActions"></a>3.mapActions</h5><p>理解:用于帮助我们生成与action对话的方法，即：包含$store.dispatch(xxx)的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  <span class="comment">//借助mapActions生成方法:addOdd，addWait(对象写法)</span></span><br><span class="line">  <span class="comment">//对象中的key是我们在自己的组件中需要调用的方法，value是我们在store中actions内定义的方法名</span></span><br><span class="line">  ...mapActions(&#123;<span class="attr">addOdd</span>:<span class="string">&#x27;addOdd&#x27;</span>,<span class="attr">addWait</span>:<span class="string">&#x27;addWait&#x27;</span>&#125;),</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//借助mapActions生成方法:addOdd，addWait(数组写法)</span></span><br><span class="line">   ...mapActions([<span class="string">&#x27;addOdd&#x27;</span>,<span class="string">&#x27;addWait&#x27;</span>])</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-mapMutations"><a href="#4-mapMutations" class="headerlink" title="4.mapMutations"></a>4.mapMutations</h5><p>理解：用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">   <span class="comment">//借助mapActions生成方法:Add，Reduce(对象写法)</span></span><br><span class="line">   <span class="comment">//对象中的key是我们在自己的组件中需要调用的方法，value是我们在store中mutations内定义的方法名</span></span><br><span class="line">   ...mapMutations(&#123;<span class="attr">add</span>:<span class="string">&#x27;Add&#x27;</span>,<span class="attr">reduce</span>:<span class="string">&#x27;Reduce&#x27;</span>&#125;),</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//借助mapActions生成方法:Add，Reduce(数组写法)</span></span><br><span class="line">    ...mapActions([<span class="string">&#x27;Add&#x27;</span>,<span class="string">&#x27;Reduce&#x27;</span>])</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>注意:当我们使用<strong>mapActions</strong>和<strong>mapMutations</strong>方法时，我们需要将dispatch和commit中需要传递的值通过组件中方法传参，例如:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add(n)&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-vuex的基本使用"><a href="#5-vuex的基本使用" class="headerlink" title="5.vuex的基本使用"></a>5.vuex的基本使用</h4><p>案例:点击按钮对数字进行各种操作</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181716339.png" alt="image-20210911201800277"></p>
<p>我们将求和之后的数字定义为count，存入vuex的临时组件中，每次进行操作从原组件中调用vuex的api，最终完成求和的计算</p>
<p>Count.vue组件:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>当前求和为:&#123;&#123;$store.state.count&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model.number</span>=<span class="string">&quot;n&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;reduce&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addOdd&quot;</span>&gt;</span>当前求和为奇数再加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addWait&quot;</span>&gt;</span>等一等再加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span>&#123;</span><br><span class="line">       <span class="attr">n</span>:<span class="number">1</span>,<span class="comment">//选择框中选择的数字</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">      <span class="function"><span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;Add&#x27;</span>,<span class="built_in">this</span>.n)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">reduce</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;Reduce&#x27;</span>,<span class="built_in">this</span>.n)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">addOdd</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;addOdd&#x27;</span>,<span class="built_in">this</span>.n)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">addWait</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;addWait&#x27;</span>,<span class="built_in">this</span>.n)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>store中index.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该文件用于创建Vuex中最核心的store</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="comment">//准备actions--用于响应组件中的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;<span class="comment">//action中可以进行异步操作,例如从请求服务器接口</span></span><br><span class="line">    <span class="function"><span class="title">addOdd</span>(<span class="params">context,value</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(context.state.count % <span class="number">2</span>)&#123;</span><br><span class="line">           context.commit(<span class="string">&#x27;AddOdd&#x27;</span>,value) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">addWait</span>(<span class="params">context,value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            context.commit(<span class="string">&#x27;AddWait&#x27;</span>,value) </span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备mutations--用于操作数据(state)</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="function"><span class="title">Add</span>(<span class="params">state,value</span>)</span>&#123;</span><br><span class="line">        state.count += value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">Reduce</span>(<span class="params">state,value</span>)</span>&#123;</span><br><span class="line">        state.count -= value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">AddOdd</span>(<span class="params">state,value</span>)</span>&#123;</span><br><span class="line">        state.count += value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">AddWait</span>(<span class="params">state,value</span>)</span>&#123;</span><br><span class="line">        state.count += value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备state--用于存储数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">    <span class="attr">count</span>:<span class="number">1</span>  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>效果</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181716612.gif" alt="GIF 2021-9-11 20-22-35"></p>
<h4 id="6-vuex中的数据在页面刷新后消失怎么办"><a href="#6-vuex中的数据在页面刷新后消失怎么办" class="headerlink" title="6.vuex中的数据在页面刷新后消失怎么办?"></a>6.vuex中的数据在页面刷新后消失怎么办?</h4><p>用sessionstorage 或者 localstorage 存储数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">存储： sessionStorage.setItem( &#x27;名&#x27;, JSON.stringify(值) )</span><br><span class="line">使用： sessionStorage.getItem(&#x27;名&#x27;) ---得到的值为字符串类型，用JSON.parse()去引号；</span><br></pre></td></tr></table></figure>




<h3 id="5-组件通信"><a href="#5-组件通信" class="headerlink" title="5.组件通信"></a>5.组件通信</h3><h4 id="1-vue组件间通信有哪几种方式"><a href="#1-vue组件间通信有哪几种方式" class="headerlink" title="1.vue组件间通信有哪几种方式?"></a>1.<strong>vue组件间通信有哪几种方式?</strong></h4><h5 id="1-props-emit"><a href="#1-props-emit" class="headerlink" title="1.props/$emit"></a>1.<strong>props/$emit</strong></h5><p>适用:<strong>父子组件通信</strong></p>
<p><strong>父传子</strong>:父组件通过往子组件标签中添加需要传递的数据，子组件使用<strong>props</strong>来接收,<strong>prop只读，不可修改,即单向数据流</strong></p>
<p><strong>子传父</strong>:<code>$emit</code>绑定一个自定义事件, 当这个语句被执行时, 就会将参数arg传递给父组件,父组件通过v-on监听并接收参数</p>
<h5 id="2-ref"><a href="#2-ref" class="headerlink" title="2.ref"></a><strong>2.ref</strong></h5><p>适用:<strong>父子组件通信</strong></p>
<p>如果ref挂载在普通的DOM元素上,引用指向的就是DOM元素;如<strong>果挂载在子组件上,引用就指向组件实例</strong></p>
<p><strong>父组件可以通过this.$ref.xxx来获取子组件实例</strong></p>
<h5 id="3-parent-children"><a href="#3-parent-children" class="headerlink" title="3.$parent/$children"></a>3.$parent/$children</h5><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181616964.webp" alt="image"></p>
<p>适用于:<strong>父子组件通信</strong></p>
<p>通过<strong>this.$parent</strong>和<strong>this.$children</strong>来获取对应的父子组件实例</p>
<h5 id="4-EventBus"><a href="#4-EventBus" class="headerlink" title="4.EventBus"></a>4.EventBus</h5><p>适用于:<strong>任意组件间通信</strong></p>
<p>这种方法通过一个空的Vue实例作为中央<strong>事件总线</strong>，用它来触发事件和监听事件，从而实现任意组件之间的通信</p>
<p>发布事件:通过$emit来发布事件</p>
<p>订阅事件:通过$on来订阅事件,当监听到发布的事件后,执行相应的回调</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组件1 发布事件</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">emit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.bus.$emit.sayhello(<span class="string">&#x27;say&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>)<span class="comment">//发布事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//组件2 订阅事件</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">data</span>:&#123;&#125;,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.bus.$on(<span class="string">&#x27;say&#x27;</span>,<span class="built_in">this</span>.say)<span class="comment">//订阅事件  </span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">say</span>(<span class="params">word</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(word);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>eventBus也有不方便之处, 当项目较大,就容易造成难以维护的灾难</p>
</blockquote>
<h5 id="5-attrs-listeners"><a href="#5-attrs-listeners" class="headerlink" title="5.$attrs/$listeners"></a>5.$attrs/$listeners</h5><p>适用于:<strong>隔代组件通信</strong></p>
<p><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件。通常配合 inheritAttrs 选项一起使用。</p>
<p><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的)  v-on 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件</p>
<h5 id="6-provide-inject"><a href="#6-provide-inject" class="headerlink" title="6.provide/inject"></a>6.provide/inject</h5><p>适用于:<strong>隔代组件通信</strong></p>
<p><code>provide</code>/ <code>inject</code> 是<code>vue2.2.0</code>新增的api, 简单来说就是父组件中通过<code>provide</code>来提供变量, 然后再子组件中通过<code>inject</code>来注入变量。</p>
<blockquote>
<p>注意: 这里不论子组件嵌套有多深, 只要调用了<code>inject</code> 那么就可以注入<code>provide</code>中的数据，而不局限于只能从当前父组件的props属性中回去数据</p>
</blockquote>
<h5 id="7-vuex"><a href="#7-vuex" class="headerlink" title="7.vuex"></a>7.vuex</h5><p>适用于:<strong>任意组件间通信</strong></p>
<p><strong>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. Vuex 解决了<code>多个视图依赖于同一状态</code>和<code>来自不同视图的行为需要变更同一状态</code>的问题，将开发者的精力聚焦于数据的更新而不是数据在组件之间的传递上</p>
<p>Vuex的各个模块:</p>
<ul>
<li><code>state</code>：用于数据的存储，是store中的唯一数据源</li>
<li><code>getters</code>：如vue中的计算属性一样，基于state数据的二次包装，常用于数据的筛选和多个数据的相关性计算</li>
<li><code>mutations</code>：类似函数，改变state数据的唯一途径，且不能用于处理异步事件</li>
<li><code>actions</code>：类似于<code>mutation</code>，用于提交<code>mutation</code>来改变状态，而不直接变更状态，可以包含任意异步操作</li>
<li><code>modules</code>：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护</li>
</ul>
<h5 id="8-localStorage-sessionStorage"><a href="#8-localStorage-sessionStorage" class="headerlink" title="8.localStorage/sessionStorage"></a>8.localStorage/sessionStorage</h5><p>通过浏览器缓存来实现组件间通信</p>
<h3 id="6-Virtual-DOM"><a href="#6-Virtual-DOM" class="headerlink" title="6.Virtual DOM"></a>6.Virtual DOM</h3><h4 id="1-虚拟dom是什么"><a href="#1-虚拟dom是什么" class="headerlink" title="1.虚拟dom是什么"></a>1.虚拟dom是什么</h4><p><strong>虚拟DOM</strong>简而言之就是，用JS去按照DOM结构来实现的树形结构对象，你也可以叫做<strong>DOM对象</strong></p>
<h4 id="2-为什么需要虚拟dom"><a href="#2-为什么需要虚拟dom" class="headerlink" title="2.为什么需要虚拟dom"></a>2.为什么需要虚拟dom</h4><p><strong>优点：</strong></p>
<ul>
<li><strong>保证性能下限：</strong> 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li>
<li><strong>无需手动操作 DOM：</strong> 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li>
<li><strong>跨平台：</strong> 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li><strong>无法进行极致优化：</strong> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li>
</ul>
<h4 id="3-vue的虚拟dom解决了什么问题"><a href="#3-vue的虚拟dom解决了什么问题" class="headerlink" title="3.vue的虚拟dom解决了什么问题"></a>3.vue的虚拟dom解决了什么问题</h4><ul>
<li><strong>无需手动操纵dom</strong></li>
<li>虚拟dom可以方便的进行<strong>跨平台</strong>操作，例如在node环境中无法应用真实dom，但是可以使用虚拟dom</li>
</ul>
<h4 id="4-虚拟DOM的实现原理"><a href="#4-虚拟DOM的实现原理" class="headerlink" title="4.虚拟DOM的实现原理"></a>4.虚拟DOM的实现原理</h4><p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p>
<ul>
<li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li>
<li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li>
<li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li>
</ul>
<h3 id="7-diff"><a href="#7-diff" class="headerlink" title="7.diff"></a>7.diff</h3><h4 id="1-实现diff的思路"><a href="#1-实现diff的思路" class="headerlink" title="1.实现diff的思路"></a>1.实现diff的思路</h4><ul>
<li>用JS模拟真实DOM节点</li>
<li>把虚拟DOM转换成真实DOM插入页面中</li>
<li>发生变化时，比较两棵树的差异，生成差异对象</li>
<li>根据差异对象更新真实DOM</li>
</ul>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181739970.webp" alt="img"></p>
<h4 id="2-vue中的key的作用"><a href="#2-vue中的key的作用" class="headerlink" title="2.vue中的key的作用"></a>2.vue中的key的作用</h4><p>1.key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据<strong>新数据</strong>生成<strong>新的虚拟DOM</strong>，随后Vue进行<strong>新虚拟DOM</strong>与<strong>旧虚拟DOM</strong>的差异比较</p>
<p>2.对比规则:</p>
<p>​    (1).<strong>旧虚拟DOM</strong>中找到了与<strong>新虚拟DOM</strong>相同的<strong>key</strong>:</p>
<p>​          ①.若<strong>虚拟DOM</strong>中内容<strong>没有变化</strong>，直接使用之前的<strong>真实DOM</strong></p>
<p>​          ②.若<strong>虚拟DOM</strong>中<strong>内容变了</strong>，则生成<strong>新的真实DOM</strong>，随后替换掉页面中之前的<strong>真实DOM</strong></p>
<p>​    (2).<strong>旧虚拟DOM</strong>中未找到与<strong>新虚拟DOM</strong>相同的<strong>key</strong></p>
<p>​            创建新的<strong>真实DOM</strong>,随后渲染到页面</p>
<p>   3.用<strong>index</strong>作为<strong>key</strong>可能会引发的问题:</p>
<p>​      (1).若对数据进行<strong>逆序添加</strong>、<strong>逆序删除</strong>等<strong>破坏顺序的操作</strong>会产生<strong>没有必要的真实DOM更新</strong>，界                    面效果没有问题，<strong>但是执行效率很低</strong></p>
<p>​      (2).如果结构中还包含<strong>输入类的DOM</strong>:会产生<strong>错误DOM更新</strong>，<strong>界面有问题</strong></p>
<p>​    4.开发中如何选择key？</p>
<p>​        (1).最好使用<strong>每条数据的唯一标识</strong>作为<strong>key</strong>，比如id、手机号、身份证号、学号等唯一值</p>
<p>​        (2).如果不存在对数据的<strong>逆序添加</strong>、<strong>逆序删除</strong>等<strong>破坏顺序的操作</strong>，仅用于渲染列表用于展示，                    <strong>使用index作为key是没有问题的</strong></p>
<p><strong>index作为key和id作为key的区别</strong></p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181741532.png" alt="image-20210819211653838"></p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203181741864.png" alt="image-20210819211812731"></p>
<h3 id="8-Vue-computed-watch"><a href="#8-Vue-computed-watch" class="headerlink" title="8.Vue computed/watch"></a>8.Vue computed/watch</h3><h4 id="1-computed-和-watch-的区别和运用的场景？"><a href="#1-computed-和-watch-的区别和运用的场景？" class="headerlink" title="1.computed 和 watch 的区别和运用的场景？"></a>1.computed 和 watch 的区别和运用的场景？</h4><p><strong>computed：</strong> 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；</p>
<p><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>
<p><strong>运用场景：</strong></p>
<ul>
<li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h3 id="9-Vue和React有什么不同"><a href="#9-Vue和React有什么不同" class="headerlink" title="9.Vue和React有什么不同"></a>9.Vue和React有什么不同</h3><h5 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h5><p>1，都使用了<strong>Virtual DOM</strong>。</p>
<p>2，都提供了响应式和组件化的视图组件。</p>
<p>3，都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关库。</p>
<h5 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h5><p>1，React中，当某组件的状态发生改变时，它会以该组件为根，重新渲染整个组件子树，而在Vue中，组件的依赖是在渲染的过程中自动追踪的，所以系统能准确知晓哪个组件确实需要被重新渲染。</p>
<p>2，Vue的路由库和状态管理库都由官方维护支持且与核心库同步更新，而React选择把这些问题交给社区维护，因此生态更丰富。</p>
<p>3，Vue-cli脚手架可进行配置</p>
<hr>
<hr>
<h2 id="4-网络"><a href="#4-网络" class="headerlink" title="4.网络"></a>4.网络</h2><h3 id="1-HTTP"><a href="#1-HTTP" class="headerlink" title="1.HTTP"></a>1.HTTP</h3><h4 id="1-常见的状态码和作用"><a href="#1-常见的状态码和作用" class="headerlink" title="1.常见的状态码和作用"></a>1.常见的状态码和作用</h4><p><strong>1xx</strong></p>
<hr>
<p><strong>1xx：表示请求已经被接收,但需要进行后续处理</strong></p>
<p><strong>100</strong>:表示客户端应该继续发送请求</p>
<p><strong>101</strong>:表示需要切换协议</p>
<p><strong>2xx</strong></p>
<hr>
<p><strong>请求已成功被服务器接收</strong></p>
<p><strong>200</strong>:请求已经成功,请求所希望的响应头或数据体将随此响应返回</p>
<p><strong>201</strong>：请求已经被实现,并且有一个新的资源已经依据请求的需要而创建</p>
<p><strong>202</strong>：服务器已经接受请求,但尚未处理</p>
<p><strong>204</strong>:服务器成功处理了请求,但不需要返回任何实体内容</p>
<p><strong>205</strong>：服务器成功处理了请求，但不需要返回任何实体内容</p>
<p><strong>3xx</strong></p>
<hr>
<p><strong>通常这类状态码用来重定向,重定向目标在本次响应的location头字段中指明</strong></p>
<p>**301(永久重定向)**：被请求的资源已经永久的移动到新位置，301通常用于网站迁移时，服务器对旧的URL进行301重定向到新的URL。</p>
<p>**302(临时重定向)**：请求的资源现在临时从不同的uri响应请求</p>
<p><strong>303</strong>：请求的响应可以在另一个uri上被找到</p>
<p>**★304(资源未被修改)**：表示上次请求至今，文档的内容并没有改变，客户端可以利用这个状态码做出相应的缓存处理</p>
<p><strong>4xx</strong></p>
<hr>
<p><strong>表示客户端发生了错误妨碍了服务器的处理</strong></p>
<p><strong>400</strong>：发生了语法错误导致当前请求无法被服务器理解.</p>
<p><strong>401</strong>:表示当前请求需要用户验证</p>
<p><strong>403</strong>：表示服务器已经理解请求但是拒绝执行它</p>
<p><strong>404</strong>：表示请求的资源没有在服务器上被发现</p>
<p><strong>405</strong>:表示请求的方法不能被用于请求相应的资源</p>
<p><strong>413</strong>：表示服务器拒绝处理当前请求,因为该请求提交的实体数据大小超过了服务器愿意或者能处理的范围</p>
<p><strong>5xx</strong></p>
<hr>
<p><strong>表示服务器在处理请求的过程中出现了错误</strong></p>
<p><strong>500</strong>：通常是代码出错，后台出现bug</p>
<p><strong>502</strong>：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p>
<p><strong>504</strong>：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器收到响应。注意与502的区别：502是接收到了无效响应比如<code>Connection Refused</code>； 504是响应超时，通常是被墙了。</p>
<hr>
<h4 id="2-介绍一下http缓存策略"><a href="#2-介绍一下http缓存策略" class="headerlink" title="2.介绍一下http缓存策略"></a>2.介绍一下http缓存策略</h4><p>HTTP的缓存属于客户端缓存,我们人为浏览器存在一个缓存数据库，用于储存一些不经常变化的静态文件(图片，css，js等)，我们将缓存分为<strong>强制缓存</strong>和<strong>协商缓存</strong></p>
<h5 id="缓存规则"><a href="#缓存规则" class="headerlink" title="缓存规则"></a>缓存规则</h5><h6 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h6><p>当缓存数据库中已经有所请求的数据时，客户端直接从缓存数据库中获取数据，当缓存数据库中没有所请求的数据时，客户端才会从服务端获取数据</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191430961.webp" alt="img"></p>
<h6 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h6><p>客户端会从缓存数据库中获取到一个缓存数据的标识,得到标识后请求服务端验证是否失效。如果没有失效服务端会返回304状态码，说明客户端请求的文档还是新鲜的(与缓存文档相同),此时客户端直接从缓存中获取所请求的数据,如果标识失效，服务端会返回更新后的数据</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191439631.webp" alt="img"></p>
<p>两类缓存机制可以同时存在,强制缓存的优先级高于协商缓存，浏览器在加载资源时，会先判断是否命中<strong>强缓存</strong>再验证是命中<strong>协商缓存</strong>。</p>
<hr>
<h5 id="缓存方案"><a href="#缓存方案" class="headerlink" title="缓存方案"></a>缓存方案</h5><h6 id="强制缓存-1"><a href="#强制缓存-1" class="headerlink" title="强制缓存"></a>强制缓存</h6><p>对于强制缓存，服务器响应的header中会用两个字段来表明——Expires和Cache-Control。</p>
<p><strong>Expires</strong></p>
<p>这个字段包含了一个时间，过了这个时间，响应将会失效。</p>
<p>也就是说，<code>Expire</code> 这个字段表示缓存到期时间，我们来打开一个网站并查看 <code>Response Header</code> 看看这个字段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires:Fri, 27 Oct 2017 07:55:30 GMT</span><br></pre></td></tr></table></figure>

<p>可能在你查看这的时候发现时间不对啊，怎么都已经是过去了 ~</p>
<p><code>GMT</code> 表示的是格林威治时间，和北京时间相差8小时。</p>
<p>上面的这个时间表示的是 <code>2017年10月27日15:55:30</code>。</p>
<p>通过设置 <code>Expire</code> 来设置缓存有一个致命缺点：</p>
<p>可以看出，这个是个绝对时间，也就是说，如果我修改了客户端的本地时间，是不是就会导致判断缓存失效了呢。</p>
<p><strong>Cache-Control</strong></p>
<p>既然不能设置绝对时间，那我就设置个相对时间呗。</p>
<p>在 <code>HTTP/1.1</code> 中，增加了一个字段 <code>Cache-Control</code> ，它包含一个 <code>max-age</code> 属性，该字段表示资源缓存的最大有效时间，这就是一个相对时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:max-age=600</span><br></pre></td></tr></table></figure>

<p>这个表示的就是最大有效时间是 <code>600s</code> ，对的，它的单位是秒。</p>
<p><code>Cache-Control</code> 除了 <code>max-age</code> 属性之外还有一些属性：</p>
<ul>
<li>no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。</li>
<li>no-store：禁止使用缓存，每一次都要重新请求数据。</li>
<li>public：默认设置。</li>
<li>private：不能被多用户共享。</li>
</ul>
<p>现在基本上都会同时设置 <code>Expire</code> 和 <code>Cache-Control</code> ，<code>Cache-Control</code> 的优先级别更高。</p>
<hr>
<h6 id="协商缓存-1"><a href="#协商缓存-1" class="headerlink" title="协商缓存"></a>协商缓存</h6><p>协商缓存需要进行对比判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。若未失效，返回304状态码，浏览器拿到此状态码就可以直接使用缓存数据了。 对于协商缓存来说，缓存标识我们需要着重理解一下，下面我们将着重介绍它的两种缓存方案。</p>
<p><strong>Last-Modified，If-Modified-Since</strong></p>
<p>浏览器第一次请求资源的时候，服务器返回的 <code>header</code> 上会带有一个 <code>Last-Modified</code> 字段，表示资源<strong>最后修改</strong>的时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Fri, 27 Oct 2017 07:55:30 GMT</span><br></pre></td></tr></table></figure>

<p>同样的，这是一个 <code>GMT</code> 的绝对时间。</p>
<p>当浏览器再次请求该资源时，请求头中会带有一个 <code>If-Modified-Since</code> 字段，这个值是第一次请求返回的 <code>Last-Modified</code> 的值。服务器收到这个请求后，将 <code>If-Modified-Since</code> 和当前的 <code>Last-Modified</code> 进行对比。如果相等，则说明资源未修改，返回 <code>304</code>，浏览器使用本地缓存。</p>
<p>well，这个方法也是有缺点的：</p>
<ul>
<li>最小单位是秒。也就是说如果我短时间内资源发生了改变，<code>Last-Modified</code> 并不会发生变化；</li>
<li>周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 <code>Last-Modified</code> 可不这样认为。</li>
</ul>
<p>所以，后来又引入一个 <code>Etag</code>。</p>
<p><strong>Etag</strong></p>
<p><code>Etag</code> 一般是由文件内容 <code>hash</code> 生成的，也就是说它可以保证资源的唯一性，资源发生改变就会导致 <code>Etag</code> 发生改变。</p>
<p>同样地，在浏览器第一次请求资源时，服务器会返回一个 <code>Etag</code> 标识。当再次请求该资源时， 会通过 <code>If-no-match</code> 字段将 <code>Etag</code> 发送回服务器，然后服务器进行比较，如果相等，则返回 <code>304</code> 表示未修改。</p>
<p><strong><code>Last-Modified</code> 和 <code>Etag</code> 是可以同时设置的，服务器会优先校验 <code>Etag</code>，如果 <code>Etag</code> 相等就会继续比对 <code>Last-Modified</code>，最后才会决定是否返回 <code>304</code>。</strong></p>
<hr>
<h5 id="缓存的优点"><a href="#缓存的优点" class="headerlink" title="缓存的优点"></a><strong>缓存的优点</strong></h5><ul>
<li>减少了冗余的数据传递，节省宽带流量</li>
<li>减少了服务器的负担，大大提高了网站性能</li>
<li>加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因。</li>
</ul>
<hr>
<p>当浏览器再次访问一个已经访问过的资源时，它会这样做：</p>
<ol>
<li>看看是否命中强缓存，如果命中，就直接使用缓存了；</li>
<li>如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存；</li>
<li>如果命中协商缓存，服务器会返回 <code>304</code> 告诉浏览器使用本地缓存；</li>
<li>否则，返回最新的资源。</li>
</ol>
<hr>
<h4 id="3-介绍一下keep-alive"><a href="#3-介绍一下keep-alive" class="headerlink" title="3.介绍一下keep-alive"></a>3.介绍一下keep-alive</h4><h5 id="1-什么是keep-alive"><a href="#1-什么是keep-alive" class="headerlink" title="1.什么是keep-alive?"></a>1.<strong>什么是keep-alive?</strong></h5><p>keep-alive 是客户端和服务端的一个约定，如果开启 keep-alive，则服务端在返回 response 后不关闭 TCP 连接；同样的，在接收完响应报文后，客户端也不关闭连接，发送下一个 HTTP 请求时会重用该连接。</p>
<p>在 HTTP/1.0 协议中，如果请求头中包含：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>则代表开启 keep-alive，而服务端的返回报文头中，也会包含相同的内容。</p>
<p>在 HTTP/1.1 协议中，默认开启 keep-alive，除非显式地关闭它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: close</span><br></pre></td></tr></table></figure>

<p>keep-alive 技术创建的目的，就是能在多次 HTTP 之间重用同一个 TCP 连接，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等），参考如下示意图（来源：维基百科）：</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191521396.png" alt="image-20220319152129292"></p>
<p>然而天下没有免费的午餐，如果客户端在接收完所有的信息之后还没有关闭连接，则服务端相应的资源还在被占用（尽管已经没用了）。例如 Tomcat 的 BIO 实现中，未关闭的连接会占用对应的处理线程，如果一个长连接实际上已经处理完毕，但关闭的超时时间未到，则该线程会一直被占用（使用 NIO 的实现没有该问题）。</p>
<p>显然，如果客户端和服务端的确需要进行多次通信，则开启 keep-alive 是更好的选择，例如在微服务架构中，通常微服务的使用方和提供方会长期有交流，此时最好开启 keep-alive。</p>
<p>在一些 TPS/QPS 很高的 REST 服务中，如果使用的是短连接（即没有开启keep-alive），则很可能发生客户端端口被占满的情形。这是由于短时间内会创建大量TCP 连接，而在 TCP 四次挥手结束后，客户端的端口会处于 TIME_WAIT一段时间(2*MSL)，这期间端口不会被释放，从而导致端口被占满。这种情况下最好使用长连接。</p>
<h3 id="2-DNS"><a href="#2-DNS" class="headerlink" title="2.DNS"></a>2.DNS</h3><h4 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS?"></a>什么是DNS?</h4><p><strong>DNS（Domain Name System，域名系统）</strong>，最初，由于ip长且难记，通过ip访问网站不方便。。所以后来通过发明了DNS服务器，这个时候我们访问网站输入网站域名，DNS服务器就解析我们的域名为ip。这样我们实际访问的就是对应的ip地址啦。</p>
<p>抽象点<strong>DNS就是 一个记录ip地址的超级分布式数据库。</strong></p>
<h4 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h4><p>当用户在浏览器中输入<a target="_blank" rel="noopener" href="http://www.baidu.com时/">www.baidu.com时</a></p>
<ul>
<li><p>第1步，查找<strong>浏览器缓存</strong>。</p>
<blockquote>
<p>浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制，通常情况下为几分钟到几小时不等。这个缓存时间太长和太短都不好，如果缓存时间太长，一旦域名被解析到的IP有变化，会导致被客户端缓存的域名无法解析到变化后的IP地址，以致该域名不能正常解析，这段时间内有可能会有一部分用户无法访问网站。如果时间设置太短，会导致用户每次访问网站都要重新解析一次域名。</p>
</blockquote>
</li>
<li><p>第2步，查找<strong>系统缓存</strong>。</p>
<blockquote>
<p>如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果。其实操作系统也会有一个域名解析的过程，在Windows中可以通过C:\Windows\System32\drivers\etc\hosts文件来设置，你可以将任何域名解析到任何能够访问的IP地址。如果你在这里指定了一个域名对应的IP地址，那么浏览器会首先使用这个IP地址。例如，我们在测试时可以将一个域名解析到一台测试服务器上，这样不用修改任何代码就能测试到单独服务器上的代码的业务逻辑是否正确。正是因为有这种本地DNS解析的规程，所以黑客就有可能通过修改你的域名解析来把特定的域名解析到它指定的IP地址上，导致这些域名被劫持。</p>
</blockquote>
</li>
<li><p>第3步，查找<strong>路由器缓存</strong>。</p>
<blockquote>
<p>如果系统缓存中也找不到，那么查询请求就会发向路由器，它一般会有自己的DNS缓存。</p>
</blockquote>
</li>
<li><p>第4步，查找<strong>ISP DNS 缓存</strong>。</p>
<blockquote>
<p>运气实在不好，就只能查询ISP DNS 缓存服务器了。在我们的网络配置中都会有”DNS服务器地址”这一项，操作系统会把这个域名发送给这里设置的DNS，也就是本地区的域名服务器，通常是提供给你接入互联网的应用提供商。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约80%的域名解析都到这里就已经完成了，所以ISP DNS主要承担了域名的解析工作。</p>
</blockquote>
</li>
<li><p>第5步，<strong>递归搜索</strong>。</p>
<blockquote>
<p>　最无奈的情况发生了, 在前面都没有办法命中的DNS缓存的情况下,(1)本地 DNS服务器即将该请求转发到互联网上的根域（即一个完整域名最后面的那个点，通常省略不写）。(2)根域将所要查询域名中的顶级域（假设要查询ke.qq.com，该域名的顶级域就是com）的服务器IP地址返回到本地DNS。(3) 本地DNS根据返回的IP地址，再向顶级域（就是com域）发送请求。(4) com域服务器再将域名中的二级域（即ke.qq.com中的qq）的IP地址返回给本地DNS。(5) 本地DNS再向二级域发送请求进行查询。(6) 之后不断重复这样的过程，直到本地DNS服务器得到最终的查询结果，并返回到主机。这时候主机才能通过域名访问该网站。</p>
</blockquote>
</li>
</ul>
<h4 id="DNS的安全问题"><a href="#DNS的安全问题" class="headerlink" title="DNS的安全问题"></a>DNS的安全问题</h4><p>1、DNS欺骗：DNS欺骗即域名信息欺骗是最常见的DNS安全问题。当一个DNS服务器掉入陷阱，使用了来自一个恶意DNS服务器的错误信息，那么该DNS服务器就被欺骗了。DNS欺骗会使那些易受攻击的DNS服务器产生许多安全问题，例如：将用户引导到错误的互联网站点，或者发送一个电子邮件到一个未经授权的邮件服务器。网络攻击者通常通过两种方法进行DNS欺骗。</p>
<ul>
<li>缓存感染：黑客会熟练的使用DNS请求，将数据放入一个没有设防的DNS服务器的缓存当中。这些缓存信息会在客户进行DNS访问时返回给客户，从而将客户引导到入侵者所设置的运行木马的Web服务器或邮件服务器上，然后黑客从这些服务器上获取用户信息。<ul>
<li>DNS信息劫持：入侵者通过监听客户端和DNS服务器的对话，通过猜测服务器响应给客户端的DNS查询ID。每个DNS报文包括一个相关联的16位ID号，DNS服务器根据这个ID号获取请求源位置。黑客在DNS服务器之前将虚假的响应交给用户，从而欺骗客户端去访问恶意的网站。</li>
<li>DNS重定向：攻击者能够将DNS名称查询重定向到恶意DNS服务器。这样攻击者可以获得DNS服务器的写权限</li>
</ul>
</li>
</ul>
<p>2、拒绝服务攻击 　　黑客主要利用一些DNS软件的漏洞，如在BIND 9版本（版本9.2.0以前的 9系列）如果有人向运行BIND的设备发送特定的DNS数据包请求，BIND就会自动关闭。攻击者只能使BIND关闭，而无法在服务器上执行任意命令。如果得不到DNS服务，那么就会产生一场灾难：由于网址不能解析为IP地址，用户将无方访问互联网。这样，DNS产生的问题就好像是互联网本身所产生的问题，这将导致大量的混乱。</p>
<p>3、分布式拒绝服务攻击 　　DDOS 攻击通过使用攻击者控制的几十台或几百台计算机攻击一台主机，使得服务拒绝攻击更难以防范，更难以通过阻塞单一攻击源主机的数据流，来防范服务拒绝攻击。</p>
<p>4、缓冲区漏洞溢出攻击 　　黑客利用DNS服务器软件存在漏洞，比如对特定的输入没有进行严格检查，那幺有可能被攻击者利用，攻击者构造特殊的畸形数据包来对DNS服务器进行缓冲区溢出攻击。如果这一攻击成功，就会造成DNS服务停止，或者攻击者能够在DNS服务器上执行其设定的任意代码。</p>
<h4 id="DNS有关的网络性能优化"><a href="#DNS有关的网络性能优化" class="headerlink" title="DNS有关的网络性能优化"></a>DNS有关的网络性能优化</h4><p>1、减少DNS查找，避免重定向 　　浏览器DNS缓存 、计算机DNS缓存、 服务器DNS缓存、使用Keep-Alive特性 来减少DNS查找。考虑影响DNS缓存的因素：</p>
<ul>
<li><p>服务器可以设置TTL值表示DNS记录的存活时间。本机DNS缓存将根据这个TTL值判断DNS记录什么时候被抛弃，这个TTL值一般都不会设置很大，主要是考虑到快速故障转移的问题。</p>
</li>
<li><p>浏览器DNS缓存也有自己的过期时间，这个时间是独立于本机DNS缓存的，相对也比较短，例如chrome只有1分钟左右。</p>
</li>
<li><p>浏览器DNS记录的数量也有限制，如果短时间内访问了大量不同域名的网站，则较早的DNS记录将被抛弃，必须重新查找。不过即使浏览器丢弃了DNS记录，操作系统的DNS缓存也有很大机率保留着该记录，这样可以避免通过网络查询而带来的延迟。</p>
<p>2、DNS的预解析</p>
<ul>
<li>可以通过用meta信息来告知浏览器, 我这页面要做DNS预解析</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用link标签来强制对DNS做预解析:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://ke.qq.com/&quot; /&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等。减少唯一主机名的数量就可以减少DNS查找的数量。较少的域名来减少DNS查找（2-4个主机）</li>
</ul>
<p>本文是前端与计算机网络培训的一点总结，关于DNS解析过程做了简短的介绍，相关的安全防范和网络性能优化，还需要更多的学习。</p>
<h3 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3.TCP"></a>3.TCP</h3><h4 id="什么是TCP-IP"><a href="#什么是TCP-IP" class="headerlink" title="什么是TCP/IP?"></a>什么是TCP/IP?</h4><p><strong>TCP/IP是一类协议系统。他是用于网络通信的一套协议集合</strong></p>
<p>传统上来说TCP/IP被认为是一个四层协议</p>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191608064.webp" alt="img"></p>
<p><strong>1网络接口层:</strong></p>
<p><strong>主要是指物理层次的一些接口,比如电缆等．</strong></p>
<ol start="2">
<li><strong>网络层:</strong></li>
</ol>
<p><strong>提供独立于硬件的逻辑寻址,实现物理地址与逻辑地址的转换．</strong></p>
<p><strong>在 TCP / IP 协议族中，网络层协议包括 IP 协议（网际协议），ICMP 协议（ Internet 互联网控制报文协议），以及 IGMP 协议（ Internet 组管理协议）.</strong></p>
<ol start="3">
<li><strong>传输层:</strong></li>
</ol>
<p><strong>为网络提供了流量控制,错误控制和确认服务.</strong></p>
<p><strong>在 TCP / IP 协议族中有两个互不相同的传输协议： TCP（传输控制协议）和 UDP（用户数据报协议）.</strong></p>
<ol start="4">
<li><strong>应用层:</strong></li>
</ol>
<p><strong>为网络排错,文件传输,远程控制和 Internet 操作提供具体的应用程序</strong></p>
<h4 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h4><h5 id="三次握手流程"><a href="#三次握手流程" class="headerlink" title="三次握手流程"></a>三次握手流程</h5><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191611193.webp" alt="img"></p>
<ul>
<li>客户端发送SYN，表明要向服务器建立连接。同时带上序列号ISN</li>
<li>服务器返回ACK（序号为客户端序列号+1）作为确认。同时发送SYN作为应答（SYN的序列号为服务端唯一的序号）</li>
<li>客户端发送ACK确认收到回复（序列号为服务端序列号+1）</li>
</ul>
<h5 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手?"></a>为什么是三次握手?</h5><p>tcp连接是全双工的，数据在两个方向上能同时传递。</p>
<p>所以要<strong>确保双方，同时能发数据和收数据</strong></p>
<p><strong>第一次握手</strong>：证明了发送方能发数据</p>
<p><strong>第二次握手</strong>：ack确保了接收方能收数据，syn确保了接收方能发数据</p>
<p><strong>第三次握手</strong>：确保了发送方能收数据</p>
<p>实际上是四个维度的信息交换，不过中间两步合并为一次握手了。</p>
<p>四次握手浪费，两次握手不能保证“双方同时具备收发功能”</p>
<h4 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h4><h5 id="四次挥手流程"><a href="#四次挥手流程" class="headerlink" title="四次挥手流程"></a>四次挥手流程</h5><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191637291.webp" alt="img"></p>
<ul>
<li>主动关闭的一方发送FIN，表示要单方面关闭数据的传输</li>
<li>服务端收到FIN后，发送一个ACK作为确认（序列号为收到的序列号+1）</li>
<li>等服务器数据传输完毕，也发送一个FIN标识，表示关闭这个方向的数据传输</li>
<li>客户端回复ACK以确认回复</li>
</ul>
<h5 id="为什么是四次挥手"><a href="#为什么是四次挥手" class="headerlink" title="为什么是四次挥手?"></a>为什么是四次挥手?</h5><ul>
<li>因为tcp连接是全双工的，数据在两个方向上能同时传递。</li>
<li>同时tcp支持半关闭（发送一方结束发送还能接收数据的功能）。</li>
<li>因此每个方向都要单独关闭，且收到关系通知需要发送确认回复</li>
</ul>
<h3 id="TCP建立连接和关闭连接对应的状态"><a href="#TCP建立连接和关闭连接对应的状态" class="headerlink" title="TCP建立连接和关闭连接对应的状态"></a>TCP建立连接和关闭连接对应的状态</h3><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203191643424.webp" alt="img"></p>
<h3 id="4-HTTPS"><a href="#4-HTTPS" class="headerlink" title="4.HTTPS"></a>4.HTTPS</h3><h4 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h4><p><strong>什么是HTTPS?</strong></p>
<p><strong>HTTPS是在HTTP上建立SSL加密层并对传输数据进行加密。是HTTP协议的安全版</strong></p>
<p>现在他被广泛用于万维网上安全敏感的通讯，例如交易支付方面</p>
<p>HTTPS的主要作用是:</p>
<ul>
<li>对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全</li>
<li>对网站服务器进行真实身份认证</li>
</ul>
<p><strong>为什么需要https?</strong></p>
<p>原本的http协议中有可能存在信息窃取或者身份伪装等安全问题。使用https通信机制可以有效地结解决这个问题。</p>
<p><strong>http协议存在的问题:</strong></p>
<ul>
<li>通信使用明文(不加密),可能会被窃听</li>
<li>无法证明报文的完整性，所以可能遭篡改</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
</ul>
<p><strong>https的优势:</strong></p>
<ul>
<li><strong>数据隐私性</strong>：内容经过堆成加密，每个连接生成一个唯一的加密密匙</li>
<li><strong>数据完整性</strong>：内容传输经过完整性校验</li>
<li><strong>身份认证</strong>：第三方无法伪造服务器(客户端)身份</li>
</ul>
<h4 id="HTTPS和HTTP有什么区别"><a href="#HTTPS和HTTP有什么区别" class="headerlink" title="HTTPS和HTTP有什么区别"></a>HTTPS和HTTP有什么区别</h4><p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203201056419.webp" alt="img"></p>
<p>HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。</p>
<p>通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，<strong>所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP</strong>。</p>
<p>在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。也就是说<strong>HTTP加上加密处理和认证以及完整性保护后即是HTTPS</strong>。</p>
<ul>
<li>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li>
</ul>
<p><img src="https://gitee.com/hnistzzm/typora-cloud-img/raw/master/202203201057264.webp" alt="img"></p>
<p>关于安全性，用最简单的比喻形容两者的关系就是卡车运货，HTTP下的运货车是敞篷的，货物都是暴露的。而https则是封闭集装箱车，安全性自然提升不少。</p>
<ul>
<li>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;</li>
<li>HTTPS需要用到SSL证书，而HTTP不用;</li>
<li>HTTPS标准端口443，HTTP标准端口80;</li>
<li>HTTPS基于传输层，HTTP基于应用层;</li>
<li>HTTPS在浏览器显示绿色安全锁，HTTP没有显示;</li>
</ul>
<h3 id="5-CDN"><a href="#5-CDN" class="headerlink" title="5.CDN"></a>5.CDN</h3><h4 id="CDN是什么"><a href="#CDN是什么" class="headerlink" title="CDN是什么?"></a>CDN是什么?</h4><p>CDN的全称是Content Delivery Network，即<strong>内容分发网络</strong>。</p>
<p><strong>其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定</strong>。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</p>
<p>在不同地域的用户访问网站的响应速度存在差异,为了提高用户访问的响应速度、优化现有Internet中信息的流动,需要在用户和服务器间加入中间层CDN. 使用户能以最快的速度，从最接近用户的地方获得所需的信息，彻底解决网络拥塞，提高响应速度，是目前大型网站使用的流行的应用方案.</p>
<p><strong>CDN的基本工作过程：</strong></p>
<ul>
<li>当用户点击网站页面上的内容URL，先经过本地DNS系统解析，如果本地DNS服务器没有相应域名的缓存，则本地DNS系统会将域名的解析权交给CNAME指向的CDN专用DNS服务器。</li>
<li>CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回给用户。</li>
<li>用户向CDN的全局负载均衡设备发起URL访问请求。</li>
<li>CDN全局负载均衡设备根据用户IP地址，以及用户请求的URL，选择一台用户所属区域的区域负载均衡设备，并将请求转发到此设备上。</li>
<li>基于以下这些条件的综合分析之后，区域负载均衡设备会选择一个最优的缓存服务器节点，并从缓存服务器节点处得到缓存服务器的IP地址，最终将得到的IP地址返回给全局负载均衡设备：</li>
<li>根据用户IP地址，判断哪一个边缘节点距用户最近；</li>
<li>根据用户所请求的URL中携带的内容名称，判断哪一个边缘节点上有用户所需内容；</li>
<li>查询各个边缘节点当前的负载情况，判断哪一个边缘节点尚有服务能力。</li>
<li>全局负载均衡设备把服务器的IP地址返回给用户。</li>
<li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</li>
</ul>
<p><strong>CDN的应用场景:</strong></p>
<ul>
<li>用户量大的直播平台，需要快速、低延迟的获取各类直播信息</li>
<li>电子商务网站</li>
<li>大型企业</li>
</ul>
<p>既然CDN的核心作用是提高网络的访问速度，那么其用户也就是访问量很大的网站，例如ICP 、ISP、大型企业、电子商务网站和政府网站等。利用CDN技术，这些网站无需投资昂贵的各类服务器，设立分站点。通过采用CDN，CDN将负责信息传递工作，保证信息正常传输，而技术人员只需要维护网站内容，不需要考虑流量问题。这样，网站可保证用户得到更多的新业务，可以快速访问网络上的内容，获得更好的服务质量。举个例子来讲，对于访问量比较大，而被访问内容更新周期比较长的网站，如政府网站，用户往往进行大量的查询工作。这类网站比较适合采用CDN。还有，大家是否注意到，在所谓的宽带社区中，瓶颈是社区的对外出口。这样，如果采用CDN无疑对社区用户使用视频点播、网络教育等宽带应用提供了保证。</p>
<h3 id="6-从输入url到页面展示发生了什么"><a href="#6-从输入url到页面展示发生了什么" class="headerlink" title="6.从输入url到页面展示发生了什么"></a>6.从输入url到页面展示发生了什么</h3><p>总体来说分为以下几个过程:</p>
<ol>
<li><strong>DNS解析</strong></li>
<li><strong>TCP连接</strong></li>
<li><strong>发送HTTP请求</strong></li>
<li><strong>服务器处理请求并返回HTTP报文</strong></li>
<li><strong>浏览器解析渲染页面</strong></li>
<li><strong>连接结束</strong></li>
</ol>
<p>具体过程：</p>
<ol>
<li>用户输入URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL </li>
<li>用户输入完内容，按下回车键，浏览器导航栏显示loading状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得</li>
<li>浏览器进程浏览器构建请求行信息，会通过进程间通信（IPC）将URL请求发送给网络进程 GET /index.html HTTP1.1 </li>
<li>网络进程获取到URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接200返回；否则，进入网络请求过程</li>
<li>网络进程请求DNS返回域名对应的IP和端口号，如果之前DNS数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的IP和端口号，如果没有端口号，http默认80，https默认443。如果是https请求，还需要建立TLS连接。</li>
<li>Chrome 有个机制，同一个域名同时最多只能建立 6 个TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立TCP连接。</li>
<li>TCP三次握手建立连接，http请求加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输</li>
<li>网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层</li>
<li>底层通过物理网络传输给目的服务器主机 </li>
<li>目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层 </li>
<li>目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层 </li>
<li>应用层HTTP解析请求头和请求体，如果需要重定向，HTTP直接返回HTTP响应数据的状态code301或者302，同时在请求头的Location字段中附上重定向地址，浏览器会根据code和Location进行重定向操作；如果不是重定向，首先服务器会根据 请求头中的If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；否则，返回新数据，200的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段： Cache-Control:Max-age=2000 响应数据又顺着应用层——传输层——网络层——网络层——传输层——应用层的顺序返回到网络进程 </li>
<li><strong>数据传输完成，TCP四次挥手断开连接</strong>。如果，浏览器或者服务器在HTTP头部加上如下信息，TCP就一直保持连接。保持TCP连接可以省下下次需要建立连接的时间，提示资源加载速度 Connection:Keep-Alive </li>
<li>网络进程将获取到的数据包进行解析，根据响应头中的Content-type来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是text/html类型，就通知浏览器进程获取到文档准备渲染 </li>
<li>浏览器进程获取到通知，根据当前页面B是否是从页面A打开的并且和页面A是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程</li>
<li>浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程 </li>
<li>浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页 </li>
<li>渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成DOM Tree（二叉树类似结构的东西），CSS按照CSS 规则和CSS解释器转成CSSOM TREE，两个tree结合，形成render tree（不包含HTML的具体元素和元素要画的具体位置），通过Layout可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:957957209@qq.com">zzm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/03/13/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">http://example.com/2022/03/13/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">AstronautBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/HTML/">HTML</a><a class="post-meta__tags" href="/tags/Http/">Http</a><a class="post-meta__tags" href="/tags/CSS/">CSS</a><a class="post-meta__tags" href="/tags/Webpack/">Webpack</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440795.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/19/vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"><img class="prev-cover" src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041355284.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">vue面试题整理</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"><img class="next-cover" src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440795.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面试题整理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/03/04/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="面试题整理"><img class="cover" src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440795.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-04</div><div class="title">面试题整理</div></div></a></div><div><a href="/2022/03/01/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/" title="JavaScript深入之作用域链"><img class="cover" src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440862.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-01</div><div class="title">JavaScript深入之作用域链</div></div></a></div><div><a href="/2022/03/22/javaScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="javaScript面试题整理"><img class="cover" src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440795.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-22</div><div class="title">javaScript面试题整理</div></div></a></div><div><a href="/2022/03/22/javaScript%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="javaScript面试手写知识点整理"><img class="cover" src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440862.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-22</div><div class="title">javaScript面试手写知识点整理</div></div></a></div><div><a href="/2022/03/22/css%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="css面试题整理"><img class="cover" src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041439031.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-22</div><div class="title">css面试题整理</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NTEyNi8zMTU5NA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/avater1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">zzm</div><div class="author-info__description">好久不见</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hnistzzm"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hnistzzm" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://gitee.com/hnistzzm" target="_blank" title="Gitee"><i class="fab fa-git-alt"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=957957209" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客网站</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JavaScript-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">1.JavaScript 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E9%97%AD%E5%8C%85"><span class="toc-number">1.1.</span> <span class="toc-text">1.执行上下文&#x2F;作用域&#x2F;闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.什么是执行上下文?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%9C%E7%94%A8%E5%9F%9F-Scope"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.作用域(Scope)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%97%AD%E5%8C%85"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.闭包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-this-call-apply-bind"><span class="toc-number">1.2.</span> <span class="toc-text">2.this&#x2F;call&#x2F;apply&#x2F;bind</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-this%E7%9A%84%E6%8C%87%E5%90%91"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.this的指向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-call"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.call</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-apply"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.apply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-bind"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.bind</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8E%9F%E5%9E%8B-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.</span> <span class="toc-text">3.原型&#x2F;继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.原型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#new"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">类式继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">构造函数继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">组合式继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">原型式继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">寄生式继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">寄生组合式继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-promise"><span class="toc-number">1.4.</span> <span class="toc-text">4.promise</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFpromise-%E5%AE%83%E7%94%A8%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.什么是promise?它用来解决什么问题?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-promise%E7%94%A8%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.promise用法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BApromise%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">创建promise对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#then%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">then链式调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reject%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">reject的用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#catch%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">catch的用法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-all"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">Promise.all()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-race"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">Promise.race()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-any"><span class="toc-number">1.4.2.7.</span> <span class="toc-text">Promise.any()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-async-await"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.async&#x2F;await</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFasync"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">1.什么是async?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-async%E5%87%BD%E6%95%B0%E6%80%8E%E4%B9%88%E7%94%A8"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">2.async函数怎么用?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-await%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">3.await是什么</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.5.</span> <span class="toc-text">5.深浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.5.1.</span> <span class="toc-text">什么是浅拷贝?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">1.5.2.</span> <span class="toc-text">什么是深拷贝？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">JavaScript中的拷贝方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-event-loop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.6.</span> <span class="toc-text">6.event loop(事件循环)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.6.1.</span> <span class="toc-text">什么是事件循环?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">事件循环的一些举例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#setTimeout"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">setTimeout</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#setInterval"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">setInterval</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1-macro-task-%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1-micro-task"><span class="toc-number">1.6.3.</span> <span class="toc-text">宏任务(macro-task)和微任务(micro-task)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83"><span class="toc-number">1.6.4.</span> <span class="toc-text">?如何实现一个事件的订阅与发布</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">1.7.</span> <span class="toc-text">7.函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.7.1.</span> <span class="toc-text">什么是函数式编程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%A3%E5%8A%BF"><span class="toc-number">1.7.2.</span> <span class="toc-text">函数式编程的优劣势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96-curry"><span class="toc-number">1.7.3.</span> <span class="toc-text">函数柯里化(curry)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Service-Worker-PWA"><span class="toc-number">1.8.</span> <span class="toc-text">8.Service Worker&#x2F;PWA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Web-Worker"><span class="toc-number">1.9.</span> <span class="toc-text">9.Web Worker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-ES6%E7%9F%A5%E8%AF%86"><span class="toc-number">1.10.</span> <span class="toc-text">10.ES6知识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-CSS%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">2.CSS基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-position"><span class="toc-number">2.1.</span> <span class="toc-text">1.position</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFposition"><span class="toc-number">2.1.1.</span> <span class="toc-text">什么是position?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.</span> <span class="toc-text">2.行内元素&#x2F;块级元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="toc-number">2.2.1.</span> <span class="toc-text">什么是行内元素？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.2.</span> <span class="toc-text">什么是块级元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E4%B8%8E%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.3.</span> <span class="toc-text">行内元素与块级元素的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFC-%E5%9D%97%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.2.4.</span> <span class="toc-text">BFC(块格式化上下文)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-flex%E5%B8%83%E5%B1%80"><span class="toc-number">2.3.</span> <span class="toc-text">3.flex布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFflex%E5%B8%83%E5%B1%80"><span class="toc-number">2.3.1.</span> <span class="toc-text">什么是flex布局?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#flex%E5%AE%B9%E5%99%A8"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">flex容器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#flex%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">flex元素属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8flex%E5%AE%9E%E7%8E%B0%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%B8%83%E5%B1%80"><span class="toc-number">2.3.2.</span> <span class="toc-text">如何用flex实现九宫格布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flex-1%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Fflex%E5%B1%9E%E6%80%A7%E9%BB%98%E8%AE%A4%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.3.3.</span> <span class="toc-text">flex:1指的是什么？flex属性默认值是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bflex-shrink%E5%92%8Cflex-basis%E5%B1%9E%E6%80%A7"><span class="toc-number">2.3.4.</span> <span class="toc-text">介绍一下flex-shrink和flex-basis属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1px%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.</span> <span class="toc-text">4.1px问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81"><span class="toc-number">2.5.</span> <span class="toc-text">5.重绘与回流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9B%9E%E6%B5%81-Reflow"><span class="toc-number">2.5.1.</span> <span class="toc-text">1.回流 (Reflow)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%87%8D%E7%BB%98-Repaint"><span class="toc-number">2.5.2.</span> <span class="toc-text">2.重绘 (Repaint)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D"><span class="toc-number">2.5.3.</span> <span class="toc-text">3.性能影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="toc-number">2.5.4.</span> <span class="toc-text">4.如何避免</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-CSS"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">1.CSS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-JavaScript"><span class="toc-number">2.5.4.2.</span> <span class="toc-text">2.JavaScript</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80"><span class="toc-number">2.6.</span> <span class="toc-text">6.居中布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.7.</span> <span class="toc-text">7.层叠上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">2.7.1.</span> <span class="toc-text">1.什么是层叠上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B1%82%E5%8F%A0%E7%AD%89%E7%BA%A7"><span class="toc-number">2.7.2.</span> <span class="toc-text">2.什么是层叠等级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E2%80%9C%E5%B1%82%E5%8F%A0%E4%B8%8A%E4%B8%8B%E6%96%87%E2%80%9D"><span class="toc-number">2.7.3.</span> <span class="toc-text">3.如何产生“层叠上下文”</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-sass-less"><span class="toc-number">2.8.</span> <span class="toc-text">8.sass&#x2F;less</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%AF%B9%E7%9B%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.9.</span> <span class="toc-text">9.对盒模型的理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Vue"><span class="toc-number">3.</span> <span class="toc-text">3.Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-MVVM"><span class="toc-number">3.1.</span> <span class="toc-text">1.MVVM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFMVVM"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.什么是MVVM?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ViewModel%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.ViewModel有什么好处?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2.生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BVue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">1.介绍一下Vue生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-nextTick%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.nextTick是如何实现的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%8C%82%E8%BD%BD%E6%97%B6-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.父子组件挂载时,生命周期的顺序是怎么样的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="toc-number">3.3.</span> <span class="toc-text">3.数据绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.1.</span> <span class="toc-text">1.Vue的双向绑定如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Vue%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E6%88%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%94%B9%E5%8F%98"><span class="toc-number">3.3.2.</span> <span class="toc-text">2.Vue如何监听数组或对象的改变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-defineProperty%E5%92%8Cproxy%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.defineProperty和proxy的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Vue%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E9%A2%91%E7%B9%81%E5%8F%98%E5%8C%96%E4%BD%86%E5%8F%AA%E4%BC%9A%E6%9B%B4%E6%96%B0%E4%B8%80%E6%AC%A1"><span class="toc-number">3.3.4.</span> <span class="toc-text">4.Vue中的数据为什么频繁变化但只会更新一次</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">4.状态管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-vuex%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.4.1.</span> <span class="toc-text">1.vuex是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8vuex"><span class="toc-number">3.4.2.</span> <span class="toc-text">2.什么时候使用vuex?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-vuex%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.vuex的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-vuex%E4%B8%AD4%E4%B8%AAmap%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.4.4.</span> <span class="toc-text">4.vuex中4个map方法的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-mapState"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">1.mapState</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-mapGetters"><span class="toc-number">3.4.4.2.</span> <span class="toc-text">2.mapGetters</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-mapActions"><span class="toc-number">3.4.4.3.</span> <span class="toc-text">3.mapActions</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-mapMutations"><span class="toc-number">3.4.4.4.</span> <span class="toc-text">4.mapMutations</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-vuex%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">3.4.5.</span> <span class="toc-text">5.vuex的基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-vuex%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9C%A8%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E5%90%8E%E6%B6%88%E5%A4%B1%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">3.4.6.</span> <span class="toc-text">6.vuex中的数据在页面刷新后消失怎么办?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">3.5.</span> <span class="toc-text">5.组件通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.5.1.</span> <span class="toc-text">1.vue组件间通信有哪几种方式?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-props-emit"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">1.props&#x2F;$emit</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-ref"><span class="toc-number">3.5.1.2.</span> <span class="toc-text">2.ref</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-parent-children"><span class="toc-number">3.5.1.3.</span> <span class="toc-text">3.$parent&#x2F;$children</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-EventBus"><span class="toc-number">3.5.1.4.</span> <span class="toc-text">4.EventBus</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-attrs-listeners"><span class="toc-number">3.5.1.5.</span> <span class="toc-text">5.$attrs&#x2F;$listeners</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-provide-inject"><span class="toc-number">3.5.1.6.</span> <span class="toc-text">6.provide&#x2F;inject</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-vuex"><span class="toc-number">3.5.1.7.</span> <span class="toc-text">7.vuex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-localStorage-sessionStorage"><span class="toc-number">3.5.1.8.</span> <span class="toc-text">8.localStorage&#x2F;sessionStorage</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Virtual-DOM"><span class="toc-number">3.6.</span> <span class="toc-text">6.Virtual DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%99%9A%E6%8B%9Fdom%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.6.1.</span> <span class="toc-text">1.虚拟dom是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9Fdom"><span class="toc-number">3.6.2.</span> <span class="toc-text">2.为什么需要虚拟dom</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-vue%E7%9A%84%E8%99%9A%E6%8B%9Fdom%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">3.6.3.</span> <span class="toc-text">3.vue的虚拟dom解决了什么问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%99%9A%E6%8B%9FDOM%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.4.</span> <span class="toc-text">4.虚拟DOM的实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-diff"><span class="toc-number">3.7.</span> <span class="toc-text">7.diff</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9E%E7%8E%B0diff%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">3.7.1.</span> <span class="toc-text">1.实现diff的思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-vue%E4%B8%AD%E7%9A%84key%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.7.2.</span> <span class="toc-text">2.vue中的key的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Vue-computed-watch"><span class="toc-number">3.8.</span> <span class="toc-text">8.Vue computed&#x2F;watch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-computed-%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%BF%90%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">3.8.1.</span> <span class="toc-text">1.computed 和 watch 的区别和运用的场景？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Vue%E5%92%8CReact%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-number">3.9.</span> <span class="toc-text">9.Vue和React有什么不同</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-number">3.9.0.1.</span> <span class="toc-text">相同点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-number">3.9.0.2.</span> <span class="toc-text">不同点：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%BD%91%E7%BB%9C"><span class="toc-number">4.</span> <span class="toc-text">4.网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-HTTP"><span class="toc-number">4.1.</span> <span class="toc-text">1.HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.常见的状态码和作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bhttp%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="toc-number">4.1.2.</span> <span class="toc-text">2.介绍一下http缓存策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%A7%84%E5%88%99"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">缓存规则</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="toc-number">4.1.2.1.1.</span> <span class="toc-text">强制缓存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">4.1.2.1.2.</span> <span class="toc-text">协商缓存</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">缓存方案</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98-1"><span class="toc-number">4.1.2.2.1.</span> <span class="toc-text">强制缓存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98-1"><span class="toc-number">4.1.2.2.2.</span> <span class="toc-text">协商缓存</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">缓存的优点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bkeep-alive"><span class="toc-number">4.1.3.</span> <span class="toc-text">3.介绍一下keep-alive</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFkeep-alive"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">1.什么是keep-alive?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-DNS"><span class="toc-number">4.2.</span> <span class="toc-text">2.DNS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDNS"><span class="toc-number">4.2.1.</span> <span class="toc-text">什么是DNS?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">4.2.2.</span> <span class="toc-text">DNS域名解析过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.3.</span> <span class="toc-text">DNS的安全问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS%E6%9C%89%E5%85%B3%E7%9A%84%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">4.2.4.</span> <span class="toc-text">DNS有关的网络性能优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-TCP"><span class="toc-number">4.3.</span> <span class="toc-text">3.TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFTCP-IP"><span class="toc-number">4.3.1.</span> <span class="toc-text">什么是TCP&#x2F;IP?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">4.3.2.</span> <span class="toc-text">TCP的三次握手</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">三次握手流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">为什么是三次握手?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">4.3.3.</span> <span class="toc-text">TCP的四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">四次挥手流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">为什么是四次挥手?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E5%AF%B9%E5%BA%94%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.4.</span> <span class="toc-text">TCP建立连接和关闭连接对应的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-HTTPS"><span class="toc-number">4.5.</span> <span class="toc-text">4.HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.5.1.</span> <span class="toc-text">HTTPS的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPS%E5%92%8CHTTP%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.5.2.</span> <span class="toc-text">HTTPS和HTTP有什么区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-CDN"><span class="toc-number">4.6.</span> <span class="toc-text">5.CDN</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CDN%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.6.1.</span> <span class="toc-text">CDN是什么?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">4.7.</span> <span class="toc-text">6.从输入url到页面展示发生了什么</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/javaScript%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="javaScript面试手写知识点整理"><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440862.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="javaScript面试手写知识点整理"/></a><div class="content"><a class="title" href="/2022/03/22/javaScript%E9%9D%A2%E8%AF%95%E6%89%8B%E5%86%99%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/" title="javaScript面试手写知识点整理">javaScript面试手写知识点整理</a><time datetime="2022-03-22T11:35:35.000Z" title="发表于 2022-03-22 19:35:35">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/javaScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="javaScript面试题整理"><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440795.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="javaScript面试题整理"/></a><div class="content"><a class="title" href="/2022/03/22/javaScript%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="javaScript面试题整理">javaScript面试题整理</a><time datetime="2022-03-22T11:27:40.000Z" title="发表于 2022-03-22 19:27:40">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/css%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="css面试题整理"><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041439031.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="css面试题整理"/></a><div class="content"><a class="title" href="/2022/03/22/css%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="css面试题整理">css面试题整理</a><time datetime="2022-03-22T11:20:16.000Z" title="发表于 2022-03-22 19:20:16">2022-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/19/vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="vue面试题整理"><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041355284.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vue面试题整理"/></a><div class="content"><a class="title" href="/2022/03/19/vue%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" title="vue面试题整理">vue面试题整理</a><time datetime="2022-03-19T02:16:43.000Z" title="发表于 2022-03-19 10:16:43">2022-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/13/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" title="面试知识整理"><img src="https://gitee.com/jwz--jwz/cloud-img/raw/master/piggo/202201041440795.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="面试知识整理"/></a><div class="content"><a class="title" href="/2022/03/13/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" title="面试知识整理">面试知识整理</a><time datetime="2022-03-13T13:05:16.000Z" title="发表于 2022-03-13 21:05:16">2022-03-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By zzm</div><div class="footer_custom_text">你将不再是道具，而是人如其名</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (true) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>